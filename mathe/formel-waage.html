<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formel-Waage ‚Äì Das Spiel</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* Header mit Stats */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: rgba(0,0,0,0.3);
            border-bottom: 3px solid #e94560;
        }

        .logo {
            font-family: 'Fredoka One', cursive;
            font-size: 1.8em;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            font-size: 1.2em;
        }

        .stats-bar {
            display: flex;
            gap: 25px;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 25px;
            font-weight: 600;
        }

        .stat-icon {
            font-size: 1.3em;
        }

        .stat-value {
            font-size: 1.2em;
            color: #ffd700;
            font-weight: 700;
        }

        .home-btn {
            padding: 8px 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s;
            display: none;
        }

        .home-btn.show {
            display: block;
        }

        .home-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .game-stat {
            display: none;
        }

        .game-stat.show {
            display: flex;
        }

        .streak-fire {
            color: #ff6b35;
            animation: flamePulse 0.5s ease infinite alternate;
        }

        @keyframes flamePulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }

        /* Hauptbereich */
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Zwei-Spalten Layout f√ºr Desktop */
        .game-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
        }

        @media (min-width: 900px) {
            .game-content {
                grid-template-columns: 1fr 1fr;
            }
            
            .left-column {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            
            .right-column {
                display: flex;
                flex-direction: column;
            }
        }

        /* Start-Screen */
        .start-screen {
            text-align: center;
            padding: 60px 20px;
        }

        .start-screen h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #e94560);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-screen p {
            font-size: 1.3em;
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
        }
        
        .select-screen {
            display: none;
            text-align: center;
            padding: 20px 20px 40px 20px;
        }
        
        .select-home-btn {
            display: none;
        }
        
        .select-home-btn.show {
            display: flex;
        }
        
        .mode-select {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .mode-btn {
            padding: 30px 50px;
            border: 4px solid transparent;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 1.3em;
            font-weight: 700;
            transition: all 0.3s;
            min-width: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .mode-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .mode-btn.practice {
            border-color: #60a5fa;
            background: rgba(96, 165, 250, 0.2);
        }
        
        .mode-btn.game {
            border-color: #f472b6;
            background: rgba(244, 114, 182, 0.2);
        }
        
        .mode-btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255,255,255,0.3), 0 0 50px currentColor;
        }
        
        .mode-btn .mode-icon {
            font-size: 2.5em;
        }
        
        .mode-btn .mode-desc {
            font-size: 0.7em;
            font-weight: 400;
            opacity: 0.8;
        }

        .difficulty-select {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .topic-select {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .topic-btn {
            padding: 15px 25px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .topic-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.2);
        }
        
        .topic-btn.active {
            border-color: #60a5fa;
            background: rgba(96, 165, 250, 0.3);
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.4);
        }

        .diff-btn {
            padding: 20px 35px;
            border: 3px solid transparent;
            border-radius: 15px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 140px;
        }

        .diff-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .diff-btn.easy {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.2);
        }

        .diff-btn.medium {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.2);
        }

        .diff-btn.hard {
            border-color: #f87171;
            background: rgba(248, 113, 113, 0.2);
        }

        .diff-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255,255,255,0.4), 0 0 60px currentColor;
            border-width: 4px;
            background: rgba(255,255,255,0.25);
            position: relative;
        }

        .diff-btn.active::after {
            content: '‚úì';
            position: absolute;
            top: -10px;
            right: -10px;
            background: #4ade80;
            color: #1a1a2e;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1em;
        }

        .diff-btn.easy.active {
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.6), 0 0 60px rgba(74, 222, 128, 0.3);
            background: rgba(74, 222, 128, 0.35);
        }

        .diff-btn.medium.active {
            box-shadow: 0 0 30px rgba(251, 191, 36, 0.6), 0 0 60px rgba(251, 191, 36, 0.3);
            background: rgba(251, 191, 36, 0.35);
        }

        .diff-btn.hard.active {
            box-shadow: 0 0 30px rgba(248, 113, 113, 0.6), 0 0 60px rgba(248, 113, 113, 0.3);
            background: rgba(248, 113, 113, 0.35);
        }

        .diff-stars {
            display: block;
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .start-btn {
            padding: 20px 60px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #e94560, #ff6b35);
            color: #fff;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            font-size: 1.5em;
            transition: all 0.3s;
            box-shadow: 0 5px 30px rgba(233, 69, 96, 0.5);
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 40px rgba(233, 69, 96, 0.7);
        }

        /* Game Screen */
        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Progress & Timer - volle Breite */
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }

        .progress-bar {
            flex: 1;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        .progress-text {
            font-weight: 700;
            min-width: 80px;
            text-align: right;
        }

        .timer {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 25px;
            font-weight: 700;
            font-size: 1.2em;
        }

        .timer.warning {
            background: rgba(248, 113, 113, 0.3);
            animation: timerPulse 0.5s ease infinite alternate;
        }

        @keyframes timerPulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        /* Formel-Anzeige */
        .formula-card {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px 25px;
            margin-bottom: 15px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .formula-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .formula-name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.3em;
            color: #22d3ee;
            line-height: 1.2;
        }

        .formula-category {
            padding: 6px 15px 5px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 0.9em;
            line-height: 1.2;
        }

        .target-info {
            text-align: center;
            padding: 20px;
            background: rgba(74, 222, 128, 0.15);
            border-radius: 15px;
            border: 2px solid rgba(74, 222, 128, 0.3);
            font-size: 1.3em;
            margin-bottom: 20px;
        }

        .target-info span {
            font-weight: 700;
            color: #4ade80;
            font-size: 1.4em;
        }

        /* Gleichung */
        .equation-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            font-size: 2.2em;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        .equation-side {
            min-width: 150px;
            text-align: center;
            padding: 20px 25px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            color: #ffd700;
        }

        .equation-equals {
            font-size: 1.2em;
            color: #fff;
            font-style: normal;
        }

        /* Operations-Buttons */
        .operations-section {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
        }

        .operations-title {
            font-family: 'Fredoka One', cursive;
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .operations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
        }

        .op-btn {
            padding: 18px 15px;
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            background: rgba(255,255,255,0.05);
            color: #fff;
            cursor: pointer;
            font-size: 1.2em;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        .op-btn .katex {
            font-size: 1.1em;
        }

        .op-btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .op-btn.correct {
            background: rgba(74, 222, 128, 0.4);
            border-color: #4ade80;
            animation: correctBounce 0.5s;
        }

        .op-btn.wrong {
            background: rgba(248, 113, 113, 0.4);
            border-color: #f87171;
            animation: wrongShake 0.5s;
        }

        .op-btn.possible {
            background: rgba(251, 191, 36, 0.4);
            border-color: #fbbf24;
            animation: wrongShake 0.5s;
        }

        @keyframes correctBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        /* Schritte */
        .steps-section {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .steps-title {
            font-family: 'Fredoka One', cursive;
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #22d3ee;
        }

        .steps-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            overflow-y: auto;
        }

        .step-item {
            display: grid;
            grid-template-columns: 40px minmax(80px, 1fr) 30px minmax(80px, 1fr) 30px minmax(60px, auto);
            align-items: center;
            gap: 8px;
            padding: 14px 18px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            animation: stepSlide 0.3s ease;
            border-left: 4px solid #22d3ee;
        }

        @keyframes stepSlide {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .step-num {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #22d3ee, #4ade80);
            color: #1a1a2e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            flex-shrink: 0;
        }

        .step-left {
            font-size: 1.35em;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #ffd700;
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            line-height: 1;
        }

        .step-equals {
            font-size: 1.35em;
            color: #fff;
            text-align: center;
            width: 25px;
            line-height: 1;
        }

        .step-right {
            font-size: 1.35em;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #ffd700;
            text-align: left;
            display: flex;
            align-items: center;
            line-height: 1;
        }

        .step-divider {
            color: #22d3ee;
            font-size: 1.5em;
            font-weight: 300;
            padding: 0 8px;
            line-height: 1;
        }

        .step-op {
            color: #ff6b35;
            font-size: 1.25em;
            font-family: 'Times New Roman', serif;
            min-width: 70px;
            text-align: left;
            line-height: 1;
        }

        /* Feedback-Message */
        .feedback-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px 50px;
            border-radius: 20px;
            font-family: 'Fredoka One', cursive;
            font-size: 2em;
            z-index: 100;
            animation: feedbackPop 0.5s ease;
            pointer-events: none;
        }

        .feedback-msg.correct {
            background: linear-gradient(45deg, #4ade80, #22d3ee);
            color: #1a1a2e;
        }

        .feedback-msg.wrong {
            background: linear-gradient(45deg, #f87171, #e94560);
            color: #fff;
        }

        .feedback-msg.possible {
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            color: #1a1a2e;
            font-size: 1.2em;
            padding: 20px 35px;
        }

        @keyframes feedbackPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Success Screen */
        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .success-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .success-card {
            background: linear-gradient(135deg, #1e3a5f, #16213e);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            border: 3px solid #ffd700;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.3);
            animation: successBounce 0.6s ease;
        }

        @keyframes successBounce {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .success-emoji {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .success-title {
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            background: linear-gradient(45deg, #ffd700, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        .success-formula {
            font-size: 2em;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #ffd700;
            padding: 20px 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin: 20px 0;
            display: inline-block;
        }

        .success-steps {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
        }

        .success-steps .step-item {
            padding: 10px 12px;
            margin-bottom: 8px;
            font-size: 0.9em;
            grid-template-columns: 35px minmax(60px, 1fr) 25px minmax(60px, 1fr) 25px minmax(50px, auto);
        }

        .success-steps .step-item:last-child {
            margin-bottom: 0;
        }

        .success-steps .step-left,
        .success-steps .step-right {
            font-size: 1.25em;
        }

        .success-steps .step-equals {
            font-size: 1.25em;
        }

        .success-steps .step-op {
            font-size: 1.1em;
        }

        .success-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 25px 0;
        }

        .success-stat {
            text-align: center;
        }

        .success-stat-value {
            font-family: 'Fredoka One', cursive;
            font-size: 2em;
            color: #4ade80;
        }

        .success-stat-label {
            color: rgba(255,255,255,0.7);
        }

        .next-btn {
            padding: 18px 50px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #4ade80, #22d3ee);
            color: #1a1a2e;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3em;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .next-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 40px rgba(74, 222, 128, 0.5);
        }

        /* Konfetti */
        .confetti {
            position: fixed;
            width: 12px;
            height: 12px;
            pointer-events: none;
            z-index: 300;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* KaTeX Styling */
        .katex {
            font-size: 1em;
            color: inherit;
        }
        
        .katex .mord {
            color: inherit;
        }

        /* Hint Button */
        .hint-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, #8b5cf6, #6366f1);
            color: #fff;
            cursor: pointer;
            font-size: 1.8em;
            box-shadow: 0 5px 20px rgba(139, 92, 246, 0.5);
            transition: all 0.3s;
        }

        .hint-btn:hover {
            transform: scale(1.1);
        }

        .hint-popup {
            position: fixed;
            bottom: 90px;
            right: 20px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            padding: 20px 25px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: none;
            animation: hintPop 0.3s ease;
        }

        .hint-popup.show {
            display: block;
        }

        @keyframes hintPop {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Level Complete */
        .level-complete-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .level-complete-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .level-card {
            background: linear-gradient(135deg, #1e3a5f, #0f172a);
            padding: 50px 60px;
            border-radius: 30px;
            text-align: center;
            border: 4px solid #ffd700;
        }

        .level-stars {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .level-title {
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .level-summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .summary-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
        }

        .summary-value {
            font-family: 'Fredoka One', cursive;
            font-size: 2em;
            color: #4ade80;
        }

        .summary-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.9em;
        }

        .level-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .menu-btn {
            padding: 18px 35px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50px;
            background: transparent;
            color: #fff;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            font-size: 1.3em;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .menu-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Responsive */
        @media (max-width: 900px) {
            .left-column, .right-column {
                width: 100%;
            }
        }
        
        @media (max-width: 600px) {
            .stats-bar {
                gap: 10px;
            }
            
            .stat-item {
                padding: 6px 12px;
                font-size: 0.9em;
            }
            
            .equation-display {
                font-size: 1.6em;
                flex-wrap: wrap;
            }
            
            .operations-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .step-item {
                grid-template-columns: 35px 1fr auto 1fr auto auto;
                font-size: 0.85em;
                padding: 10px 12px;
            }
            
            .step-left, .step-right {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="game-header">
        <div class="logo">
            <span class="logo-icon">‚öñÔ∏è</span>
            Formel-Waage
        </div>
        <div class="stats-bar">
            <button class="home-btn" onclick="goToMenu()" title="Zur√ºck zum Men√º">üè†</button>
            <button class="home-btn select-home-btn" onclick="goBack()" title="Zur√ºck">üè†</button>
            <div class="stat-item game-stat">
                <span class="stat-icon">‚≠ê</span>
                <span class="stat-value" id="scoreDisplay">0</span>
            </div>
            <div class="stat-item game-stat">
                <span class="stat-icon streak-fire" id="streakIcon">üî•</span>
                <span class="stat-value" id="streakDisplay">0</span>
            </div>
            <div class="stat-item game-stat">
                <span class="stat-icon">‚úì</span>
                <span class="stat-value" id="solvedDisplay">0/5</span>
            </div>
        </div>
    </div>

    <div class="game-container">
        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <p>Stelle Formeln um und lerne Gleichungen zu l√∂sen!</p>
            
            <div class="mode-select">
                <button class="mode-btn practice" onclick="selectMode('practice')">
                    <span class="mode-icon">üìö</span>
                    √úben
                    <span class="mode-desc">Ohne Zeitdruck lernen</span>
                </button>
                <button class="mode-btn game" onclick="selectMode('game')">
                    <span class="mode-icon">üéÆ</span>
                    Spielen
                    <span class="mode-desc">Mit Timer & Punkten</span>
                </button>
            </div>
        </div>
        
        <!-- Auswahl-Bildschirm -->
        <div class="select-screen" id="selectScreen">
            <!-- Themen-Auswahl (√úbungsmodus) -->
            <div class="topic-select" id="topicSelect">
                <button class="topic-btn active" onclick="selectTopic('all', this)">
                    üîÄ Alles gemischt
                </button>
                <button class="topic-btn" onclick="selectTopic('üìê Ebene Figuren', this)">
                    üìê Ebene Figuren
                </button>
                <button class="topic-btn" onclick="selectTopic('üì¶ K√∂rper & Volumen', this)">
                    üì¶ K√∂rper & Volumen
                </button>
                <button class="topic-btn" onclick="selectTopic('üìê Satz des Pythagoras', this)">
                    üìê Pythagoras
                </button>
                <button class="topic-btn" onclick="selectTopic('‚ö° Physik-Formeln', this)">
                    ‚ö° Physik
                </button>
            </div>
            
            <!-- Schwierigkeits-Auswahl (Spielmodus) -->
            <div class="difficulty-select" id="difficultySelect" style="display: none;">
                <button class="diff-btn easy active" onclick="selectDifficulty('easy', this)">
                    <span class="diff-stars">‚≠ê</span>
                    Einfach
                </button>
                <button class="diff-btn medium" onclick="selectDifficulty('medium', this)">
                    <span class="diff-stars">‚≠ê‚≠ê</span>
                    Mittel
                </button>
                <button class="diff-btn hard" onclick="selectDifficulty('hard', this)">
                    <span class="diff-stars">‚≠ê‚≠ê‚≠ê</span>
                    Schwer
                </button>
            </div>
            
            <button class="start-btn" onclick="startGame()">
                üöÄ Los geht's!
            </button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <!-- Progress - volle Breite -->
            <div class="progress-bar-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-text" id="progressText">1/5</div>
                <div class="timer" id="timer">
                    <span>‚è±Ô∏è</span>
                    <span id="timerValue">60</span>
                </div>
            </div>

            <!-- Formula Card - volle Breite -->
            <div class="formula-card">
                <div class="formula-header">
                    <div class="formula-name" id="formulaName">Kreisfl√§che</div>
                    <div class="formula-category" id="formulaCategory">üìê Fl√§chen</div>
                </div>
            </div>

            <!-- Equation Display - volle Breite -->
            <div class="equation-display">
                <div class="equation-side" id="leftSide">A</div>
                <div class="equation-equals">=</div>
                <div class="equation-side" id="rightSide">œÄ ¬∑ r¬≤</div>
            </div>

            <!-- Ziel-Info - volle Breite -->
            <div class="target-info">
                L√∂se nach <span id="targetVar">r</span> auf!
            </div>

            <!-- Zwei-Spalten-Bereich -->
            <div class="game-content">
                <!-- Linke Spalte -->
                <div class="left-column">
                    <!-- Operations -->
                    <div class="operations-section">
                        <div class="operations-title">üîß W√§hle die richtige Operation:</div>
                        <div class="operations-grid" id="opButtons"></div>
                    </div>
                </div>

                <!-- Rechte Spalte -->
                <div class="right-column">
                    <!-- Steps -->
                    <div class="steps-section">
                        <div class="steps-title">üìù Deine Schritte</div>
                        <div class="steps-list" id="stepsList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hint Button -->
    <button class="hint-btn" id="hintBtn" onclick="toggleHint()" style="display: none;">üí°</button>
    <div class="hint-popup" id="hintPopup"></div>

    <!-- Success Overlay -->
    <div class="success-overlay" id="successOverlay">
        <div class="success-card">
            <div class="success-emoji">üéâ</div>
            <div class="success-title">Richtig!</div>
            <div class="success-formula" id="successFormula"></div>
            <div class="success-steps" id="successSteps"></div>
            <div class="success-stats">
                <div class="success-stat">
                    <div class="success-stat-value" id="successPoints">+100</div>
                    <div class="success-stat-label">Punkte</div>
                </div>
                <div class="success-stat">
                    <div class="success-stat-value" id="successTime">12s</div>
                    <div class="success-stat-label">Zeit</div>
                </div>
                <div class="success-stat">
                    <div class="success-stat-value" id="successStreak">üî• 3</div>
                    <div class="success-stat-label">Streak</div>
                </div>
            </div>
            <button class="next-btn" onclick="nextChallenge()">
                Weiter ‚ûú
            </button>
        </div>
    </div>

    <!-- Level Complete Overlay -->
    <div class="level-complete-overlay" id="levelCompleteOverlay">
        <div class="level-card">
            <div class="level-stars" id="levelStars">‚≠ê‚≠ê‚≠ê</div>
            <div class="level-title">Level geschafft!</div>
            <div class="level-summary">
                <div class="summary-item">
                    <div class="summary-value" id="finalScore">500</div>
                    <div class="summary-label">Punkte</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value" id="finalCorrect">5/5</div>
                    <div class="summary-label">Richtig</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value" id="finalStreak">üî• 5</div>
                    <div class="summary-label">Bester Streak</div>
                </div>
            </div>
            <div class="level-buttons">
                <button class="menu-btn" onclick="goToMenu()">üè† Men√º</button>
                <button class="next-btn" onclick="playAgain()">üîÑ Nochmal</button>
            </div>
        </div>
    </div>

    <script>
        // Math HTML helpers
        function frac(num, den) {
            return `<span class="frac"><span class="frac-num">${num}</span><span class="frac-line"></span><span class="frac-den">${den}</span></span>`;
        }
        
        function renderLatex(latex) {
            try {
                return katex.renderToString(latex, { throwOnError: false, displayMode: false });
            } catch(e) {
                console.error('KaTeX error:', latex, e);
                return latex;
            }
        }
        
        // Alle Funktionen geben LaTeX-Strings zur√ºck
        function sqrt(content) {
            return `\\sqrt{${content}}`;
        }
        
        function cbrt(content) {
            return `\\sqrt[3]{${content}}`;
        }
        
        function frac(num, den) {
            return `\\frac{${num}}{${den}}`;
        }
        
        function sup(base, exp) {
            return `{${base}}^{${exp}}`;
        }
        
        function hl(text) {
            return `{\\color{#4ade80}${text}}`;
        }
        
        // Konstanten (LaTeX)
        const MUL = ' \\cdot ';
        const PI = '\\pi';

        // Dynamisches Gleichungssystem
        // Zustand: { leftNum: [], leftDen: [], rightNum: [], rightDen: [], targetSide: 'right' }
        // Faktoren sind Strings wie '2', 'œÄ', 'r', 'r¬≤', etc.
        
        function createState(leftNum, leftDen, rightNum, rightDen, target, targetSide = 'right') {
            return {
                leftNum: [...leftNum],
                leftDen: [...leftDen],
                rightNum: [...rightNum],
                rightDen: [...rightDen],
                target,
                targetSide
            };
        }
        
        function renderFactorLatex(f) {
            // Gibt LaTeX-String f√ºr einen Faktor zur√ºck
            if (f === 'œÄ') return '\\pi';
            if (f === 'r¬≤') return 'r^{2}';
            if (f === 'r¬≥') return 'r^{3}';
            if (f === 'a¬≤') return 'a^{2}';
            if (f === 'a¬≥') return 'a^{3}';
            if (f === 'b¬≤') return 'b^{2}';
            if (f === 'c¬≤') return 'c^{2}';
            if (f === '3/4') return '\\frac{3}{4}';
            if (f === '4/3') return '\\frac{4}{3}';
            if (f === '1/3') return '\\frac{1}{3}';
            return f;
        }
        
        function renderFactor(f) {
            // Rendert Faktor zu HTML mit KaTeX
            return renderLatex(renderFactorLatex(f));
        }
        
        function sortFactors(factors) {
            // Sortiere Faktoren nach mathematischer Konvention: Zahlen vor Variablen
            const priority = (f) => {
                // Reine Zahlen zuerst
                if (/^\d+$/.test(f)) return 0;
                // Br√ºche
                if (f.includes('/')) return 1;
                // Pi
                if (f === 'œÄ') return 2;
                // Gro√übuchstaben (Variablen wie A, G, V, O, U)
                if (/^[A-Z]$/.test(f)) return 3;
                // Kleinbuchstaben
                if (/^[a-z]$/.test(f)) return 4;
                // Potenzen (r¬≤, a¬≥, etc.)
                return 5;
            };
            return [...factors].sort((a, b) => priority(a) - priority(b));
        }
        
        function renderSide(num, den, target) {
            // Sortiere Faktoren nach mathematischer Konvention
            const sortedNum = sortFactors(num);
            const sortedDen = sortFactors(den);
            
            // Baue LaTeX f√ºr Numerator
            let numLatex = sortedNum.map(f => {
                const latex = renderFactorLatex(f);
                return f === target ? hl(latex) : latex;
            }).join(MUL) || '1';
            
            if (sortedDen.length === 0) {
                return renderLatex(numLatex);
            }
            
            // Mit Nenner
            let denLatex = sortedDen.map(f => {
                const latex = renderFactorLatex(f);
                return f === target ? hl(latex) : latex;
            }).join(MUL);
            
            return renderLatex(frac(numLatex, denLatex));
        }
        
        function applyOpToState(state, opId) {
            const newState = createState(state.leftNum, state.leftDen, state.rightNum, state.rightDen, state.target, state.targetSide);
            
            const opParts = opId.split('_');
            const opType = opParts[0]; // 'div', 'mul', 'sqrt', 'cbrt', 'sub', 'add'
            const opVar = opParts[1]; // '2', 'pi', 'r', etc.
            
            // Konvertiere opVar zu Faktor-String
            let factor = opVar;
            if (opVar === 'pi') factor = 'œÄ';
            if (opVar === 'r2') factor = 'r¬≤';
            if (opVar === 'a2') factor = 'a¬≤';
            if (opVar === 'b2') factor = 'b¬≤';
            if (opVar === '34') factor = '3/4';
            if (opVar === '43') factor = '4/3';
            if (opVar === '13') factor = '1/3';
            
            // Kehrwert-Paare
            const reciprocals = { '3/4': '4/3', '4/3': '3/4', '1/3': '3', '3': '1/3' };
            const reciprocal = reciprocals[factor];
            
            if (opType === 'div') {
                // Division: f√ºge Faktor zu beiden Nennern hinzu (oder entferne aus Z√§hler)
                // Links
                const leftNumIdx = newState.leftNum.indexOf(factor);
                const leftNumRecipIdx = reciprocal ? newState.leftNum.indexOf(reciprocal) : -1;
                if (leftNumIdx >= 0) {
                    newState.leftNum.splice(leftNumIdx, 1);
                } else if (leftNumRecipIdx >= 0) {
                    // Division durch 3/4 wenn 4/3 da ist ‚Üí 4/3 wird verst√§rkt, nicht entfernt
                    // Eigentlich: (4/3) / (3/4) = (4/3) * (4/3) = 16/9 - kompliziert
                    // Vereinfachung: Division ist nur sinnvoll wenn Faktor vorhanden
                    newState.leftDen.push(factor);
                } else {
                    newState.leftDen.push(factor);
                }
                // Rechts
                const rightNumIdx = newState.rightNum.indexOf(factor);
                if (rightNumIdx >= 0) {
                    newState.rightNum.splice(rightNumIdx, 1);
                } else {
                    newState.rightDen.push(factor);
                }
            } else if (opType === 'mul') {
                // Multiplikation: f√ºge Faktor zu beiden Z√§hlern hinzu (oder entferne aus Nenner)
                // ODER: entferne Kehrwert aus Z√§hler (3/4 * 4/3 = 1)
                // Links
                const leftDenIdx = newState.leftDen.indexOf(factor);
                const leftNumRecipIdx = reciprocal ? newState.leftNum.indexOf(reciprocal) : -1;
                if (leftDenIdx >= 0) {
                    newState.leftDen.splice(leftDenIdx, 1);
                } else if (leftNumRecipIdx >= 0) {
                    // Multiplikation mit 3/4 wenn 4/3 im Z√§hler ist ‚Üí entferne 4/3
                    newState.leftNum.splice(leftNumRecipIdx, 1);
                } else {
                    newState.leftNum.push(factor);
                }
                // Rechts
                const rightDenIdx = newState.rightDen.indexOf(factor);
                const rightNumRecipIdx = reciprocal ? newState.rightNum.indexOf(reciprocal) : -1;
                if (rightDenIdx >= 0) {
                    newState.rightDen.splice(rightDenIdx, 1);
                } else if (rightNumRecipIdx >= 0) {
                    // Multiplikation mit 3/4 wenn 4/3 im Z√§hler ist ‚Üí entferne 4/3
                    newState.rightNum.splice(rightNumRecipIdx, 1);
                } else {
                    newState.rightNum.push(factor);
                }
            } else if (opId === 'sqrt') {
                // Quadratwurzel: wandle r¬≤ zu r
                const convertSquare = (arr) => {
                    const idx = arr.indexOf('r¬≤');
                    if (idx >= 0) arr[idx] = 'r';
                    const idxA = arr.indexOf('a¬≤');
                    if (idxA >= 0) arr[idxA] = 'a';
                    const idxB = arr.indexOf('b¬≤');
                    if (idxB >= 0) arr[idxB] = 'b';
                    const idxC = arr.indexOf('c¬≤');
                    if (idxC >= 0) arr[idxC] = 'c';
                };
                convertSquare(newState.leftNum);
                convertSquare(newState.rightNum);
                // Auch target updaten wenn n√∂tig
                if (newState.target === 'r¬≤') newState.target = 'r';
                if (newState.target === 'a¬≤') newState.target = 'a';
                if (newState.target === 'b¬≤') newState.target = 'b';
            } else if (opId === 'pow2') {
                // Quadrat: wandle r zu r¬≤, a zu a¬≤, etc.
                const convertToPow2 = (arr) => {
                    const idx = arr.indexOf('r');
                    if (idx >= 0) arr[idx] = 'r¬≤';
                    const idxA = arr.indexOf('a');
                    if (idxA >= 0) arr[idxA] = 'a¬≤';
                    const idxB = arr.indexOf('b');
                    if (idxB >= 0) arr[idxB] = 'b¬≤';
                    const idxC = arr.indexOf('c');
                    if (idxC >= 0) arr[idxC] = 'c¬≤';
                };
                convertToPow2(newState.leftNum);
                convertToPow2(newState.rightNum);
            } else if (opId === 'cbrt') {
                // Kubikwurzel: wandle r¬≥ zu r
                const convertCube = (arr) => {
                    const idx = arr.indexOf('r¬≥');
                    if (idx >= 0) arr[idx] = 'r';
                    const idxA = arr.indexOf('a¬≥');
                    if (idxA >= 0) arr[idxA] = 'a';
                };
                convertCube(newState.leftNum);
                convertCube(newState.rightNum);
                if (newState.target === 'r¬≥') newState.target = 'r';
                if (newState.target === 'a¬≥') newState.target = 'a';
            } else if (opId === 'pow3') {
                // Kubik: wandle r zu r¬≥, a zu a¬≥
                const convertToPow3 = (arr) => {
                    const idx = arr.indexOf('r');
                    if (idx >= 0) arr[idx] = 'r¬≥';
                    const idxA = arr.indexOf('a');
                    if (idxA >= 0) arr[idxA] = 'a¬≥';
                };
                convertToPow3(newState.leftNum);
                convertToPow3(newState.rightNum);
            }
            
            return newState;
        }
        
        function isTargetIsolated(state) {
            // Ziel ist isoliert wenn es alleine im Z√§hler einer Seite steht (ohne Nenner)
            // UND es nicht potenziert ist (r¬≤ oder r¬≥ ist NICHT isoliert wenn Ziel r ist)
            
            function checkIsolated(num, den, target) {
                if (num.length !== 1 || den.length !== 0) return false;
                const factor = num[0];
                // Exakte √úbereinstimmung oder potenzierte Version?
                if (factor === target) return true;
                // Wenn der Faktor eine Potenz des Ziels ist (z.B. r¬≤ wenn Ziel r), ist es NICHT isoliert
                return false;
            }
            
            return checkIsolated(state.rightNum, state.rightDen, state.target) ||
                   checkIsolated(state.leftNum, state.leftDen, state.target);
        }
        
        function needsSqrtStep(state) {
            // Pr√ºft ob r¬≤ (oder a¬≤ etc.) isoliert ist und noch Wurzel gezogen werden muss
            if (!currentFormula || !currentFormula.needsSqrtAtEnd) return false;
            
            const target = state.target; // z.B. 'r¬≤'
            const leftIsolated = state.leftNum.length === 1 && state.leftNum[0] === target && state.leftDen.length === 0;
            const rightIsolated = state.rightNum.length === 1 && state.rightNum[0] === target && state.rightDen.length === 0;
            
            return leftIsolated || rightIsolated;
        }
        
        function needsCbrtStep(state) {
            // Pr√ºft ob r¬≥ (oder a¬≥ etc.) isoliert ist und noch Kubikwurzel gezogen werden muss
            if (!currentFormula || !currentFormula.needsCbrtAtEnd) return false;
            
            const target = state.target; // z.B. 'r¬≥'
            const leftIsolated = state.leftNum.length === 1 && state.leftNum[0] === target && state.leftDen.length === 0;
            const rightIsolated = state.rightNum.length === 1 && state.rightNum[0] === target && state.rightDen.length === 0;
            
            return leftIsolated || rightIsolated;
        }
        
        function getBaseVariable(factor) {
            // Extrahiert die Basisvariable aus einem Faktor (z.B. 'r' aus 'r¬≤')
            if (factor.endsWith('¬≤')) return factor.slice(0, -1);
            if (factor.endsWith('¬≥')) return factor.slice(0, -1);
            return factor;
        }
        
        function factorContainsTarget(factor, target) {
            // Pr√ºft ob ein Faktor das Ziel enth√§lt (direkt oder als Potenz)
            if (factor === target) return true;
            if (getBaseVariable(factor) === target) return true;
            return false;
        }
        
        function countDistractors(state) {
            // Finde wo das Ziel ist und z√§hle St√∂rfaktoren
            const targetInLeftNum = state.leftNum.some(f => factorContainsTarget(f, state.target));
            const targetInLeftDen = state.leftDen.some(f => factorContainsTarget(f, state.target));
            const targetInRightNum = state.rightNum.some(f => factorContainsTarget(f, state.target));
            const targetInRightDen = state.rightDen.some(f => factorContainsTarget(f, state.target));
            
            // Z√§hle auch Potenzen als St√∂rfaktor (r¬≤ wenn Ziel r ist = 1 St√∂rfaktor wegen der Potenz)
            function countPowerPenalty(factors, target) {
                return factors.filter(f => getBaseVariable(f) === target && f !== target).length;
            }
            
            if (targetInLeftNum && !targetInLeftDen) {
                // Ziel ist im linken Z√§hler
                const nonTargetFactors = state.leftNum.filter(f => !factorContainsTarget(f, state.target)).length;
                const powerPenalty = countPowerPenalty(state.leftNum, state.target);
                return nonTargetFactors + state.leftDen.length + powerPenalty;
            } else if (targetInRightNum && !targetInRightDen) {
                // Ziel ist im rechten Z√§hler
                const nonTargetFactors = state.rightNum.filter(f => !factorContainsTarget(f, state.target)).length;
                const powerPenalty = countPowerPenalty(state.rightNum, state.target);
                return nonTargetFactors + state.rightDen.length + powerPenalty;
            } else if (targetInLeftDen) {
                // Ziel ist im linken Nenner - alle Faktoren sind St√∂rfaktoren
                return state.leftNum.length + (state.leftDen.length - 1) + state.rightNum.length + state.rightDen.length;
            } else if (targetInRightDen) {
                // Ziel ist im rechten Nenner - alle Faktoren sind St√∂rfaktoren
                return state.leftNum.length + state.leftDen.length + state.rightNum.length + (state.rightDen.length - 1);
            }
            return 999; // Ziel nicht gefunden
        }
        
        function findTargetLocation(state) {
            if (state.leftNum.some(f => factorContainsTarget(f, state.target))) return 'leftNum';
            if (state.leftDen.some(f => factorContainsTarget(f, state.target))) return 'leftDen';
            if (state.rightNum.some(f => factorContainsTarget(f, state.target))) return 'rightNum';
            if (state.rightDen.some(f => factorContainsTarget(f, state.target))) return 'rightDen';
            return null;
        }
        
        function isOperationHelpful(state, opId) {
            // Potenzen (¬≤) und (¬≥) sind NIE hilfreich - sie machen die Gleichung komplizierter
            if (opId === 'pow2' || opId === 'pow3') {
                return false;
            }
            
            // Spezialfall: Wurzeln sind nur hilfreich wenn das Quadrat/Kubik ALLEIN steht
            if (opId === 'sqrt' || opId === 'cbrt') {
                // Finde wo das Ziel (als Potenz) ist
                const targetLocation = findTargetLocation(state);
                if (!targetLocation) return false;
                
                // Hole die Faktoren auf der Zielseite
                let factors, den;
                if (targetLocation === 'leftNum') {
                    factors = state.leftNum;
                    den = state.leftDen;
                } else if (targetLocation === 'rightNum') {
                    factors = state.rightNum;
                    den = state.rightDen;
                } else {
                    // Ziel im Nenner - Wurzel macht keinen Sinn
                    return false;
                }
                
                // Finde die passende Potenz
                const powerSuffix = opId === 'sqrt' ? '¬≤' : '¬≥';
                const poweredFactor = factors.find(f => f.endsWith(powerSuffix) && getBaseVariable(f) === state.target);
                
                // Keine passende Potenz gefunden
                if (!poweredFactor) return false;
                
                // Wurzel ist nur hilfreich wenn:
                // 1. Das Quadrat/Kubik der EINZIGE Faktor im Z√§hler ist
                // 2. Kein Nenner vorhanden ist (auf der Zielseite)
                if (factors.length !== 1) {
                    // Andere Faktoren vorhanden (wie 4/3 oder œÄ)
                    return false;
                }
                if (den.length > 0) {
                    // Nenner vorhanden auf der Zielseite
                    return false;
                }
                
                return true;
            }
            
            const newState = applyOpToState(state, opId);
            
            const oldLocation = findTargetLocation(state);
            const newLocation = findTargetLocation(newState);
            
            // Ziel verschwunden? ‚Üí schlecht
            if (!newLocation) return false;
            
            // Von Nenner zu Z√§hler gewechselt? ‚Üí gut!
            if ((oldLocation === 'leftDen' || oldLocation === 'rightDen') &&
                (newLocation === 'leftNum' || newLocation === 'rightNum')) {
                return true;
            }
            
            // Von Z√§hler zu Nenner gewechselt? ‚Üí schlecht!
            if ((oldLocation === 'leftNum' || oldLocation === 'rightNum') &&
                (newLocation === 'leftDen' || newLocation === 'rightDen')) {
                return false;
            }
            
            // Ansonsten: Werden St√∂rfaktoren reduziert?
            const before = countDistractors(state);
            const after = countDistractors(newState);
            return after < before;
        }

        // Formulas by difficulty - mit State-basiertem System
        // REGELN:
        // Einfach: Nur Division/Multiplikation, max. 2 Schritte, keine Wurzeln, keine Subtraktion
        // Mittel: Wurzeln ODER Subtraktion, max. 2-3 Schritte
        // Schwer: Bruch-Faktoren (4/3, 1/3) MIT Wurzel ODER 3+ Schritte mit Wurzel
        
        const formulasByDifficulty = {
            easy: [
                // === RECHTECK ===
                {
                    name: "Rechteck (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = a ${MUL} b`,
                    variables: ["a", "b"],
                    getInitialState: (target) => createState(['A'], [], ['a', 'b'], [], target)
                },
                // === QUADRAT ===
                {
                    name: "Quadrat (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 4 ${MUL} a`,
                    variables: ["a"],
                    getInitialState: (target) => createState(['U'], [], ['4', 'a'], [], 'a')
                },
                // === DREIECK ===
                {
                    name: "Dreieck (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${frac(`g ${MUL} h`, '2')}`,
                    variables: ["g", "h"],
                    getInitialState: (target) => createState(['A'], [], ['g', 'h'], ['2'], target)
                },
                // === PARALLELOGRAMM ===
                {
                    name: "Parallelenviereck (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = a ${MUL} h`,
                    variables: ["a", "h"],
                    getInitialState: (target) => createState(['A'], [], ['a', 'h'], [], target)
                },
                // === RHOMBUS ===
                {
                    name: "Rhombus (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${frac(`e ${MUL} f`, '2')}`,
                    variables: ["e", "f"],
                    getInitialState: (target) => createState(['A'], [], ['e', 'f'], ['2'], target)
                },
                {
                    name: "Rhombus (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 4 ${MUL} a`,
                    variables: ["a"],
                    getInitialState: (target) => createState(['U'], [], ['4', 'a'], [], 'a')
                },
                // === DRACHENVIERECK ===
                {
                    name: "Drachen (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${frac(`e ${MUL} f`, '2')}`,
                    variables: ["e", "f"],
                    getInitialState: (target) => createState(['A'], [], ['e', 'f'], ['2'], target)
                },
                // === KREIS ===
                {
                    name: "Kreis (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 2 ${MUL} ${PI} ${MUL} r`,
                    variables: ["r"],
                    getInitialState: (target) => createState(['U'], [], ['2', 'œÄ', 'r'], [], target)
                },
                // === K√ñRPER ===
                {
                    name: "Prisma (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = G ${MUL} h`,
                    variables: ["G", "h"],
                    getInitialState: (target) => createState(['V'], [], ['G', 'h'], [], target)
                },
                // === PHYSIK ===
                {
                    name: "Geschwindigkeit",
                    category: "‚ö° Physik-Formeln",
                    displayFormula: () => `v = ${frac('s', 't')}`,
                    variables: ["s", "t"],
                    getInitialState: (target) => createState(['v'], [], ['s'], ['t'], target)
                },
                {
                    name: "Ohmsches Gesetz",
                    category: "‚ö° Physik-Formeln",
                    displayFormula: () => `U = R ${MUL} I`,
                    variables: ["R", "I"],
                    getInitialState: (target) => createState(['U'], [], ['R', 'I'], [], target)
                }
            ],
            medium: [
                // === RECHTECK (Umfang mit Subtraktion) ===
                {
                    name: "Rechteck (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 2 ${MUL} a + 2 ${MUL} b`,
                    variables: ["a", "b"],
                    useOldSystem: true,
                    allowedOps: ['div_2', 'mul_2', 'sub_2a', 'sub_2b', 'add_2a', 'add_2b'],
                    getSteps: function(target) {
                        if (target === 'a') {
                            return {
                                start: { left: 'U', right: `2 ${MUL} ${hl('a')} + 2 ${MUL} b` },
                                steps: [
                                    { op: `‚àí 2¬∑b`, opId: 'sub_2b', left: `U - 2 ${MUL} b`, right: `2 ${MUL} ${hl('a')}` },
                                    { op: `: 2`, opId: 'div_2', left: frac(`U - 2 ${MUL} b`, '2'), right: hl('a'), final: { left: hl('a'), right: frac(`U - 2 ${MUL} b`, '2') } }
                                ]
                            };
                        } else {
                            return {
                                start: { left: 'U', right: `2 ${MUL} a + 2 ${MUL} ${hl('b')}` },
                                steps: [
                                    { op: `‚àí 2¬∑a`, opId: 'sub_2a', left: `U - 2 ${MUL} a`, right: `2 ${MUL} ${hl('b')}` },
                                    { op: `: 2`, opId: 'div_2', left: frac(`U - 2 ${MUL} a`, '2'), right: hl('b'), final: { left: hl('b'), right: frac(`U - 2 ${MUL} a`, '2') } }
                                ]
                            };
                        }
                    }
                },
                // === QUADRAT (Fl√§che mit Wurzel) ===
                {
                    name: "Quadrat (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${sup('a','2')}`,
                    variables: ["a"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2', 'cbrt', 'pow3', 'div_a', 'mul_a'],
                    getSteps: function(target) {
                        return {
                            start: { left: 'A', right: sup(hl('a'),'2') },
                            steps: [{ op: `‚àö`, opId: 'sqrt', left: sqrt('A'), right: hl('a'), final: { left: hl('a'), right: sqrt('A') } }]
                        };
                    }
                },
                // === KREIS (Fl√§che mit Wurzel) ===
                {
                    name: "Kreis (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${PI} ${MUL} ${sup('r','2')}`,
                    variables: ["r"],
                    // State-System mit r¬≤ als Zwischenziel, dann Wurzel
                    getInitialState: (target) => createState(['A'], [], ['œÄ', 'r¬≤'], [], 'r¬≤'),
                    needsSqrtAtEnd: true
                },
                // === PYTHAGORAS (mit Wurzel und/oder Subtraktion) ===
                {
                    name: "Pythagoras (c)",
                    category: "üìê Satz des Pythagoras",
                    displayFormula: () => `${sup('c','2')} = ${sup('a','2')} + ${sup('b','2')}`,
                    variables: ["c"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2', 'cbrt', 'pow3', 'sub_a2', 'add_a2', 'sub_b2', 'add_b2'],
                    getSteps: function(target) {
                        return {
                            start: { left: sup(hl('c'),'2'), right: `${sup('a','2')} + ${sup('b','2')}` },
                            steps: [{ op: `‚àö`, opId: 'sqrt', left: hl('c'), right: sqrt(`${sup('a','2')} + ${sup('b','2')}`) }]
                        };
                    }
                },
                {
                    name: "Pythagoras (a)",
                    category: "üìê Satz des Pythagoras",
                    displayFormula: () => `${sup('c','2')} = ${sup('a','2')} + ${sup('b','2')}`,
                    variables: ["a"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2', 'cbrt', 'pow3', 'sub_a2', 'add_a2', 'sub_b2', 'add_b2', 'sub_c2', 'add_c2'],
                    getSteps: function(target) {
                        return {
                            start: { left: sup('c','2'), right: `${sup(hl('a'),'2')} + ${sup('b','2')}` },
                            steps: [
                                { op: `‚àí b¬≤`, opId: 'sub_b2', left: `${sup('c','2')} - ${sup('b','2')}`, right: sup(hl('a'),'2') },
                                { op: `‚àö`, opId: 'sqrt', left: sqrt(`${sup('c','2')} - ${sup('b','2')}`), right: hl('a'), final: { left: hl('a'), right: sqrt(`${sup('c','2')} - ${sup('b','2')}`) } }
                            ]
                        };
                    }
                },
                {
                    name: "Pythagoras (b)",
                    category: "üìê Satz des Pythagoras",
                    displayFormula: () => `${sup('c','2')} = ${sup('a','2')} + ${sup('b','2')}`,
                    variables: ["b"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2', 'cbrt', 'pow3', 'sub_a2', 'add_a2', 'sub_b2', 'add_b2', 'sub_c2', 'add_c2'],
                    getSteps: function(target) {
                        return {
                            start: { left: sup('c','2'), right: `${sup('a','2')} + ${sup(hl('b'),'2')}` },
                            steps: [
                                { op: `‚àí a¬≤`, opId: 'sub_a2', left: `${sup('c','2')} - ${sup('a','2')}`, right: sup(hl('b'),'2') },
                                { op: `‚àö`, opId: 'sqrt', left: sqrt(`${sup('c','2')} - ${sup('a','2')}`), right: hl('b'), final: { left: hl('b'), right: sqrt(`${sup('c','2')} - ${sup('a','2')}`) } }
                            ]
                        };
                    }
                },
                // === K√ñRPER (mit Wurzel) ===
                {
                    name: "W√ºrfel (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${sup('a','3')}`,
                    variables: ["a"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2', 'cbrt', 'pow3', 'div_a', 'mul_a'],
                    getSteps: function(target) {
                        return {
                            start: { left: 'V', right: sup(hl('a'),'3') },
                            steps: [{ op: `¬≥‚àö`, opId: 'cbrt', left: cbrt('V'), right: hl('a'), final: { left: hl('a'), right: cbrt('V') } }]
                        };
                    }
                },
                // === PYRAMIDE (Bruch aber keine Wurzel ‚Üí Mittel) ===
                {
                    name: "Pyramide (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${frac('1','3')} ${MUL} G ${MUL} h`,
                    variables: ["G", "h"],
                    getInitialState: (target) => createState(['V'], [], ['1/3', 'G', 'h'], [], target)
                }
            ],
            hard: [
                // === KUGEL OBERFL√ÑCHE (flexibel: :4 und :œÄ in beliebiger Reihenfolge) ===
                {
                    name: "Kugel (Oberfl√§che)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `S = 4 ${MUL} ${PI} ${MUL} ${sup('r','2')}`,
                    variables: ["r"],
                    // State-System mit r¬≤ als Zwischenziel, dann Wurzel
                    getInitialState: (target) => createState(['S'], [], ['4', 'œÄ', 'r¬≤'], [], 'r¬≤'),
                    needsSqrtAtEnd: true
                },
                // === ZYLINDER ===
                {
                    name: "Zylinder (h)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${PI} ${MUL} ${sup('r','2')} ${MUL} h`,
                    variables: ["h"],
                    getInitialState: (target) => createState(['V'], [], ['œÄ', 'r¬≤', 'h'], [], 'h')
                },
                {
                    name: "Zylinder (r)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${PI} ${MUL} ${sup('r','2')} ${MUL} h`,
                    variables: ["r"],
                    // State-System mit r¬≤ als Zwischenziel, dann Wurzel
                    getInitialState: (target) => createState(['V'], [], ['œÄ', 'r¬≤', 'h'], [], 'r¬≤'),
                    needsSqrtAtEnd: true
                },
                // === KUGEL VOLUMEN (flexibel: :œÄ, ¬∑3, :4 in beliebiger Reihenfolge) ===
                {
                    name: "Kugel (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${frac('4','3')} ${MUL} ${PI} ${MUL} ${sup('r','3')}`,
                    variables: ["r"],
                    // State-System: V = (4/3)¬∑œÄ¬∑r¬≥ ‚Üí modelliert als 4¬∑œÄ¬∑r¬≥/3
                    // Links: V, Rechts: 4¬∑œÄ¬∑r¬≥ im Z√§hler, 3 im Nenner
                    getInitialState: (target) => createState(['V'], [], ['4', 'œÄ', 'r¬≥'], ['3'], 'r¬≥'),
                    needsCbrtAtEnd: true
                }
            ]
        };

        // All operations (LaTeX strings)
        const allOpsLatex = {
            'div_pi': `: \\pi`, 'mul_pi': `\\cdot \\pi`,
            'div_2': `: 2`, 'mul_2': `\\cdot 2`,
            'div_4': `: 4`, 'mul_4': `\\cdot 4`,
            'div_a': `: a`, 'mul_a': `\\cdot a`,
            'div_b': `: b`, 'mul_b': `\\cdot b`,
            'div_r': `: r`, 'mul_r': `\\cdot r`,
            'div_s': `: s`, 'mul_s': `\\cdot s`,
            'div_r2': `: r^2`, 'mul_r2': `\\cdot r^2`,
            'div_h': `: h`, 'mul_h': `\\cdot h`,
            'div_v': `: v`, 'mul_v': `\\cdot v`,
            'mul_t': `\\cdot t`, 'div_t': `: t`,
            'div_I': `: I`, 'mul_I': `\\cdot I`,
            'div_R': `: R`, 'mul_R': `\\cdot R`,
            'div_G': `: G`, 'mul_G': `\\cdot G`,
            'div_e': `: e`, 'mul_e': `\\cdot e`,
            'div_f': `: f`, 'mul_f': `\\cdot f`,
            'div_g': `: g`, 'mul_g': `\\cdot g`,
            'sqrt': `\\sqrt{\\phantom{x}}`,
            'pow2': `\\text{hoch } 2`,
            'cbrt': `\\sqrt[3]{\\phantom{x}}`,
            'pow3': `\\text{hoch } 3`,
            'sub_a': `- a`, 'add_a': `+ a`,
            'sub_b': `- b`, 'add_b': `+ b`,
            'sub_2a': `- 2 \\cdot a`, 'add_2a': `+ 2 \\cdot a`,
            'sub_2b': `- 2 \\cdot b`, 'add_2b': `+ 2 \\cdot b`,
            'sub_a2': `- a^2`, 'add_a2': `+ a^2`,
            'sub_b2': `- b^2`, 'add_b2': `+ b^2`,
            'sub_c2': `- c^2`, 'add_c2': `+ c^2`,
            'mul_3': `\\cdot 3`,
            'div_3': `: 3`
        };

        // Game state
        let difficulty = 'easy';
        let score = 0;
        let streak = 0;
        let maxStreak = 0;
        let solved = 0;
        let totalChallenges = 5;
        let currentFormula = null;
        let currentTarget = null;
        let currentSteps = null;
        let currentStepIndex = 0;
        let currentEquationState = null;  // Neues State-System
        let stepsHistory = [];  // Historie der angewendeten Operationen
        let challengeStartTime = 0;
        let timerInterval = null;
        let timeLeft = 60;
        let wrongAttempts = 0;
        let challenges = [];
        let gameMode = 'practice';  // 'practice' oder 'game'
        let practiceIndex = 0;  // F√ºr √úbungsmodus
        let allPracticeChallenges = [];  // Alle verf√ºgbaren Aufgaben
        let selectedTopic = 'all';  // F√ºr √úbungsmodus

        function selectMode(mode) {
            gameMode = mode;
            
            // Wechsle zum Auswahlbildschirm
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('selectScreen').style.display = 'block';
            
            // Home-Button zeigen
            document.querySelector('.select-home-btn').classList.add('show');
            
            // Zeige passende Auswahl
            if (mode === 'practice') {
                document.getElementById('topicSelect').style.display = 'flex';
                document.getElementById('difficultySelect').style.display = 'none';
            } else {
                document.getElementById('topicSelect').style.display = 'none';
                document.getElementById('difficultySelect').style.display = 'flex';
            }
        }
        
        function goBack() {
            document.getElementById('selectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            document.querySelector('.select-home-btn').classList.remove('show');
        }
        
        function selectTopic(topic, btn) {
            selectedTopic = topic;
            document.querySelectorAll('.topic-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        function selectDifficulty(diff, btn) {
            difficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        function startGame() {
            score = 0;
            streak = 0;
            maxStreak = 0;
            solved = 0;
            practiceIndex = 0;
            
            let allPossibleChallenges = [];
            
            if (gameMode === 'practice') {
                // √úbungsmodus: Alle Formeln aus ALLEN Schwierigkeiten
                const allFormulas = [
                    ...formulasByDifficulty.easy,
                    ...formulasByDifficulty.medium,
                    ...formulasByDifficulty.hard
                ];
                
                // Nach Thema filtern
                const filteredFormulas = selectedTopic === 'all' 
                    ? allFormulas 
                    : allFormulas.filter(f => f.category === selectedTopic);
                
                // Erstelle alle m√∂glichen Kombinationen
                filteredFormulas.forEach(formula => {
                    formula.variables.forEach(variable => {
                        allPossibleChallenges.push({ formula, target: variable });
                    });
                });
                
                // Mische die Kombinationen
                allPossibleChallenges.sort(() => Math.random() - 0.5);
                
                allPracticeChallenges = allPossibleChallenges;
                challenges = [allPracticeChallenges[0]];
                totalChallenges = 999;
                
                // Timer und Stats verstecken
                document.getElementById('timer').style.display = 'none';
                document.querySelectorAll('.game-stat').forEach(el => el.style.display = 'none');
                document.getElementById('progressText').textContent = `Aufgabe ${practiceIndex + 1}`;
            } else {
                // Spielmodus: Nach Schwierigkeit
                const formulas = formulasByDifficulty[difficulty];
                
                formulas.forEach(formula => {
                    formula.variables.forEach(variable => {
                        allPossibleChallenges.push({ formula, target: variable });
                    });
                });
                
                allPossibleChallenges.sort(() => Math.random() - 0.5);
                
                challenges = allPossibleChallenges.slice(0, 5);
                totalChallenges = 5;
                
                // Timer und Stats zeigen
                document.getElementById('timer').style.display = 'flex';
                document.querySelectorAll('.game-stat').forEach(el => el.style.display = 'flex');
                
                // Falls nicht genug Kombinationen, f√ºlle mit zuf√§lligen auf
                while (challenges.length < totalChallenges) {
                    const randomFormula = formulas[Math.floor(Math.random() * formulas.length)];
                    const randomTarget = randomFormula.variables[Math.floor(Math.random() * randomFormula.variables.length)];
                    challenges.push({ formula: randomFormula, target: randomTarget });
                }
            }
            
            updateStats();
            
            document.getElementById('selectScreen').style.display = 'none';
            document.getElementById('gameScreen').classList.add('active');
            document.getElementById('hintBtn').style.display = 'block';
            
            // Select-Home-Button verstecken, Game-Home-Button zeigen
            document.querySelector('.select-home-btn').classList.remove('show');
            document.querySelector('.home-btn:not(.select-home-btn)').classList.add('show');
            
            // Stats nur im Spielmodus einblenden
            if (gameMode === 'game') {
                document.querySelectorAll('.game-stat').forEach(el => el.classList.add('show'));
            }
            
            loadChallenge(0);
        }

        function loadChallenge(index) {
            if (gameMode === 'game' && index >= totalChallenges) {
                showLevelComplete();
                return;
            }
            
            // Im √úbungsmodus: n√§chste Aufgabe aus dem Pool laden
            if (gameMode === 'practice') {
                if (index >= allPracticeChallenges.length) {
                    // Neu mischen wenn alle durch sind
                    allPracticeChallenges.sort(() => Math.random() - 0.5);
                    index = 0;
                }
                practiceIndex = index;
                challenges = [allPracticeChallenges[index]];
                document.getElementById('progressText').textContent = `Aufgabe ${practiceIndex + 1}`;
            }
            
            const challenge = gameMode === 'practice' ? allPracticeChallenges[index] : challenges[index];
            currentFormula = challenge.formula;
            currentTarget = challenge.target;
            wrongAttempts = 0;
            challengeStartTime = Date.now();
            stepsHistory = [];
            
            // Neues State-System oder altes Step-System?
            if (currentFormula.getInitialState && !currentFormula.useOldSystem) {
                currentEquationState = currentFormula.getInitialState(currentTarget);
                currentSteps = null;
                currentStepIndex = 0;
            } else {
                currentSteps = currentFormula.getSteps(currentTarget);
                currentEquationState = null;
                currentStepIndex = 0;
            }
            
            // Timer nur im Spielmodus
            if (gameMode === 'game') {
                timeLeft = difficulty === 'easy' ? 90 : difficulty === 'medium' ? 60 : 45;
                startTimer();
            }
            
            // Update UI
            document.getElementById('formulaName').textContent = currentFormula.name;
            document.getElementById('formulaCategory').textContent = currentFormula.category;
            document.getElementById('targetVar').textContent = currentTarget;
            
            updateEquationDisplay();
            renderOperationButtons();
            resetStepsDisplay();
            updateProgress();
            animateBalance(0);
            
            document.getElementById('hintPopup').classList.remove('show');
        }

        function updateEquationDisplay() {
            const left = document.getElementById('leftSide');
            const right = document.getElementById('rightSide');
            
            if (currentEquationState) {
                // Neues State-System
                left.innerHTML = renderSide(currentEquationState.leftNum, currentEquationState.leftDen, currentEquationState.target);
                right.innerHTML = renderSide(currentEquationState.rightNum, currentEquationState.rightDen, currentEquationState.target);
            } else if (currentSteps) {
                // Altes Step-System - rendere LaTeX zu HTML
                if (currentStepIndex === 0) {
                    left.innerHTML = renderLatex(currentSteps.start.left);
                    right.innerHTML = renderLatex(currentSteps.start.right);
                } else {
                    const step = currentSteps.steps[currentStepIndex - 1];
                    left.innerHTML = renderLatex(step.left);
                    right.innerHTML = renderLatex(step.right);
                }
            }
        }

        function renderOperationButtons() {
            const container = document.getElementById('opButtons');
            
            let opIds = new Set();
            
            if (currentEquationState) {
                // Neues State-System - zeige Operationen basierend auf aktuellem State
                
                // Spezialfall: r¬≤ ist isoliert, brauchen noch Wurzel
                if (needsSqrtStep(currentEquationState)) {
                    // Zeige nur Wurzel-Buttons
                    container.innerHTML = `
                        <button class="op-btn" data-op="sqrt" onclick="applyOperation('sqrt', this)">${renderLatex('\\sqrt{\\phantom{x}}')}</button>
                        <button class="op-btn" data-op="pow2" onclick="applyOperation('pow2', this)">${renderLatex('\\text{hoch } 2')}</button>
                    `;
                    return;
                }
                
                // Spezialfall: r¬≥ ist isoliert, brauchen noch Kubikwurzel
                if (needsCbrtStep(currentEquationState)) {
                    // Zeige nur Kubikwurzel-Buttons
                    container.innerHTML = `
                        <button class="op-btn" data-op="cbrt" onclick="applyOperation('cbrt', this)">${renderLatex('\\sqrt[3]{\\phantom{x}}')}</button>
                        <button class="op-btn" data-op="pow3" onclick="applyOperation('pow3', this)">${renderLatex('\\text{hoch } 3')}</button>
                    `;
                    return;
                }
                
                if (isTargetIsolated(currentEquationState)) {
                    container.innerHTML = '';
                    return;
                }
                
                // Finde wo das Ziel ist
                const targetLocation = findTargetLocation(currentEquationState);
                
                // Alle Faktoren sammeln f√ºr potenzielle Operationen
                const allFactors = [
                    ...currentEquationState.leftNum,
                    ...currentEquationState.leftDen,
                    ...currentEquationState.rightNum,
                    ...currentEquationState.rightDen
                ];
                
                // Einzigartige Faktoren
                const uniqueFactors = [...new Set(allFactors)];
                
                // F√ºr jeden Faktor: Division und Multiplikation anbieten
                uniqueFactors.forEach(f => {
                    const divOpId = factorToOpId(f, 'div');
                    if (divOpId) opIds.add(divOpId);
                    const mulOpId = factorToOpId(f, 'mul');
                    if (mulOpId) opIds.add(mulOpId);
                });
                
                // Wurzeln: wenn irgendeine Potenz vorhanden ist, zeige BEIDE Wurzeln als Optionen
                const hasSquare = allFactors.some(f => f.includes('¬≤'));
                const hasCube = allFactors.some(f => f.includes('¬≥'));
                if (hasSquare || hasCube) {
                    opIds.add('sqrt');
                    opIds.add('cbrt');
                }
                
                // Einige weitere Distraktoren basierend auf der urspr√ºnglichen Formel
                const formulaStr = currentFormula.displayFormula();
                if (formulaStr.includes('\\pi')) { opIds.add('div_pi'); opIds.add('mul_pi'); }
                if (formulaStr.includes('2')) { opIds.add('div_2'); opIds.add('mul_2'); }
                
            } else if (currentSteps) {
                // Altes Step-System
                if (currentStepIndex >= currentSteps.steps.length) {
                    container.innerHTML = '';
                    return;
                }
                
                opIds.add(currentSteps.steps[currentStepIndex].opId);
                
                // Wenn spezielle erlaubte Operationen definiert sind (z.B. Pythagoras), nur diese verwenden
                if (currentFormula.allowedOps) {
                    currentFormula.allowedOps.forEach(op => opIds.add(op));
                } else {
                    // Add distractors based on formula
                    const formulaStr = currentFormula.displayFormula();
                    const vars = currentFormula.variables;
                    
                    if (formulaStr.includes('\\pi')) { opIds.add('div_pi'); opIds.add('mul_pi'); }
                    if (formulaStr.includes('2') && !formulaStr.includes('^{2}')) { 
                        opIds.add('div_2'); opIds.add('mul_2'); 
                    }
                    if (vars.includes('a') || formulaStr.includes(' a')) { opIds.add('div_a'); opIds.add('mul_a'); }
                    if (vars.includes('b') || formulaStr.includes(' b')) { opIds.add('div_b'); opIds.add('mul_b'); }
                    if (vars.includes('r') || formulaStr.includes(' r') || formulaStr.includes('r}^')) { opIds.add('div_r'); opIds.add('mul_r'); }
                    if (vars.includes('s') || formulaStr.includes(' s')) { opIds.add('div_s'); opIds.add('mul_s'); }
                    if (vars.includes('t') || formulaStr.includes(' t') || formulaStr.includes('/t')) { opIds.add('mul_t'); opIds.add('div_t'); }
                    if (vars.includes('h') || formulaStr.includes(' h')) { opIds.add('div_h'); opIds.add('mul_h'); }
                    if (vars.includes('v') || formulaStr.includes('v ') || formulaStr.startsWith('v')) { opIds.add('div_v'); opIds.add('mul_v'); }
                    if (vars.includes('I') || formulaStr.includes(' I')) { opIds.add('div_I'); opIds.add('mul_I'); }
                    if (vars.includes('R') || formulaStr.includes(' R')) { opIds.add('div_R'); opIds.add('mul_R'); }
                    // Beide Wurzeln bei Potenzen anzeigen
                    if (formulaStr.includes('^{2}') || formulaStr.includes('^{3}')) { 
                        opIds.add('sqrt'); 
                        opIds.add('cbrt'); 
                    }
                    if (formulaStr.includes('a}^{2}') || formulaStr.includes('b}^{2}')) { opIds.add('sub_a2'); opIds.add('sub_b2'); }
                }
            }
            
            // Gegenoperationen-Paare erzwingen: Wenn eine Operation da ist, kommt die Gegenoperation auch dazu
            const addCounterOperations = (opIds) => {
                const counterOps = {
                    'sqrt': 'pow2', 'pow2': 'sqrt',
                    'cbrt': 'pow3', 'pow3': 'cbrt'
                };
                
                // F√ºr mul/div, add/sub Paare
                const newOps = new Set(opIds);
                opIds.forEach(opId => {
                    // Wurzel/Potenz Paare
                    if (counterOps[opId]) {
                        newOps.add(counterOps[opId]);
                    }
                    
                    // mul/div Paare
                    if (opId.startsWith('mul_')) {
                        newOps.add('div_' + opId.substring(4));
                    } else if (opId.startsWith('div_')) {
                        newOps.add('mul_' + opId.substring(4));
                    }
                    
                    // add/sub Paare
                    if (opId.startsWith('add_')) {
                        newOps.add('sub_' + opId.substring(4));
                    } else if (opId.startsWith('sub_')) {
                        newOps.add('add_' + opId.substring(4));
                    }
                });
                return newOps;
            };
            
            opIds = addCounterOperations(opIds);
            
            // Gruppierte Sortierung: zusammengeh√∂rige Operationen nebeneinander (¬∑2, :2, ¬∑œÄ, :œÄ, etc.)
            const getOpSortKey = (opId) => {
                // Definiere Reihenfolge der Basen
                const baseOrder = ['2', '3', '4', 'pi', 'a', 'b', 'c', 'e', 'f', 'g', 'h', 'r', 's', 't', 'v', 'G', 'I', 'R', 'r2', 'a2', 'b2', 'c2', 'a3', '2a', '2b'];
                const parts = opId.split('_');
                const opType = parts[0]; // mul, div, sqrt, cbrt, pow2, pow3, sub, add
                const base = parts[1] || opId;
                
                // Spezielle Operationen (sqrt, pow2, cbrt, pow3) ans Ende
                if (opId === 'sqrt') return [100, 0];
                if (opId === 'pow2') return [100, 1];
                if (opId === 'cbrt') return [101, 0];
                if (opId === 'pow3') return [101, 1];
                
                const baseIdx = baseOrder.indexOf(base);
                const basePos = baseIdx >= 0 ? baseIdx : 50;
                
                // Innerhalb der Gruppe: mul=0, div=1, add=2, sub=3
                const typeOrder = { 'mul': 0, 'div': 1, 'add': 2, 'sub': 3 };
                const typePos = typeOrder[opType] ?? 4;
                
                return [basePos, typePos];
            };
            
            const opsArray = Array.from(opIds)
                .filter(id => allOpsLatex[id])
                .sort((a, b) => {
                    const [aBase, aType] = getOpSortKey(a);
                    const [bBase, bType] = getOpSortKey(b);
                    if (aBase !== bBase) return aBase - bBase;
                    return aType - bType;
                });
            
            container.innerHTML = opsArray.map(opId => 
                `<button class="op-btn" data-op="${opId}" onclick="applyOperation('${opId}', this)">${renderLatex(allOpsLatex[opId])}</button>`
            ).join('');
        }
        
        function factorToOpId(factor, type) {
            // Konvertiert Faktor zu OpId
            // Bei Br√ºchen wie 1/3 verwenden wir den Kehrwert (3) f√ºr die Operationen
            const mapping = {
                '2': '2', '4': '4', 'œÄ': 'pi', 
                'r': 'r', 'r¬≤': 'r2', 'r¬≥': 'r3',
                'a': 'a', 'a¬≤': 'a2', 'a¬≥': 'a3', 
                'b': 'b', 'b¬≤': 'b2',
                'c': 'c', 'c¬≤': 'c2', 
                's': 's', 't': 't', 'h': 'h', 'v': 'v',
                'R': 'R', 'I': 'I', 'G': 'G',
                'e': 'e', 'f': 'f', 'g': 'g',
                '4/3': '3', '3/4': '4', '1/3': '3', '3': '3'
            };
            const suffix = mapping[factor];
            if (!suffix) return null;
            return `${type}_${suffix}`;
        }

        function applyOperation(opId, btn) {
            if (currentEquationState) {
                // Neues State-System
                
                // Spezialfall: Wurzel-Schritt am Ende (z.B. Zylinder r)
                if (needsSqrtStep(currentEquationState) && opId === 'sqrt') {
                    btn.classList.add('correct');
                    animateBalance(1);
                    showFeedback('correct', '‚úì Richtig!');
                    
                    setTimeout(() => {
                        // F√ºge Wurzel-Schritt zur Anzeige hinzu
                        const target = currentEquationState.target; // z.B. 'r¬≤'
                        const baseVar = target.replace('¬≤', '').replace('¬≥', ''); // z.B. 'r'
                        
                        // Finde die andere Seite (nicht das Target)
                        let otherSideNum, otherSideDen;
                        if (currentEquationState.leftNum[0] === target) {
                            otherSideNum = currentEquationState.rightNum;
                            otherSideDen = currentEquationState.rightDen;
                        } else {
                            otherSideNum = currentEquationState.leftNum;
                            otherSideDen = currentEquationState.leftDen;
                        }
                        
                        // Erstelle LaTeX f√ºr die andere Seite (sortiert: Zahlen vor Variablen)
                        const sortedNum = sortFactors(otherSideNum);
                        const otherLatex = sortedNum.map(f => renderFactorLatex(f)).join(MUL);
                        const otherDenLatex = otherSideDen.length > 0 ? sortFactors(otherSideDen).map(f => renderFactorLatex(f)).join(MUL) : null;
                        const fullOtherLatex = otherDenLatex ? frac(otherLatex, otherDenLatex) : otherLatex;
                        
                        // F√ºge Schritt hinzu
                        const list = document.getElementById('stepsList');
                        const prevStep = list.lastElementChild;
                        if (prevStep) {
                            const prevOp = prevStep.querySelector('.step-op');
                            const prevDivider = prevStep.querySelector('.step-divider');
                            if (prevOp) prevOp.innerHTML = renderLatex('\\sqrt{\\phantom{x}}');
                            if (prevDivider) prevDivider.textContent = '|';
                        }
                        
                        currentStepIndex++;
                        const div = document.createElement('div');
                        div.className = 'step-item';
                        div.innerHTML = `
                            <div class="step-num">${currentStepIndex}</div>
                            <div class="step-left">${renderLatex(hl(baseVar))}</div>
                            <div class="step-equals">=</div>
                            <div class="step-right">${renderLatex(sqrt(fullOtherLatex))}</div>
                            <div class="step-divider"></div>
                            <div class="step-op"></div>
                        `;
                        list.appendChild(div);
                        
                        // Fertig!
                        clearInterval(timerInterval);
                        const timeTaken = Math.round((Date.now() - challengeStartTime) / 1000);
                        calculateScore(timeTaken);
                        
                        // Zeige Erfolg mit Wurzel-Formel
                        document.getElementById('successFormula').innerHTML = 
                            `${renderLatex(hl(baseVar))} = ${renderLatex(sqrt(fullOtherLatex))}`;
                        
                        const stepsHtml = document.getElementById('stepsList').innerHTML;
                        document.getElementById('successSteps').innerHTML = stepsHtml;
                        
                        document.getElementById('successPoints').textContent = `+${Math.round(score / solved)}`;
                        document.getElementById('successTime').textContent = `${timeTaken}s`;
                        document.getElementById('successStreak').textContent = `üî• ${streak}`;
                        
                        document.getElementById('successOverlay').classList.add('show');
                        createConfetti();
                    }, 400);
                    return;
                }
                
                // Spezialfall: Bei needsSqrtStep ist nur sqrt richtig
                if (needsSqrtStep(currentEquationState) && opId !== 'sqrt') {
                    btn.classList.add('wrong');
                    showFeedback('wrong', '‚úó Jetzt musst du die Wurzel ziehen!');
                    wrongAttempts++;
                    streak = 0;
                    updateStats();
                    setTimeout(() => btn.classList.remove('wrong'), 500);
                    return;
                }
                
                // Spezialfall: Kubikwurzel-Schritt am Ende (z.B. Kugel Volumen)
                if (needsCbrtStep(currentEquationState) && opId === 'cbrt') {
                    btn.classList.add('correct');
                    animateBalance(1);
                    showFeedback('correct', '‚úì Richtig!');
                    
                    setTimeout(() => {
                        // F√ºge Kubikwurzel-Schritt zur Anzeige hinzu
                        const target = currentEquationState.target; // z.B. 'r¬≥'
                        const baseVar = target.replace('¬≤', '').replace('¬≥', ''); // z.B. 'r'
                        
                        // Finde die andere Seite (nicht das Target)
                        let otherSideNum, otherSideDen;
                        if (currentEquationState.leftNum[0] === target) {
                            otherSideNum = currentEquationState.rightNum;
                            otherSideDen = currentEquationState.rightDen;
                        } else {
                            otherSideNum = currentEquationState.leftNum;
                            otherSideDen = currentEquationState.leftDen;
                        }
                        
                        // Erstelle LaTeX f√ºr die andere Seite (sortiert: Zahlen vor Variablen)
                        const sortedNum = sortFactors(otherSideNum);
                        const otherLatex = sortedNum.map(f => renderFactorLatex(f)).join(MUL);
                        const otherDenLatex = otherSideDen.length > 0 ? sortFactors(otherSideDen).map(f => renderFactorLatex(f)).join(MUL) : null;
                        const fullOtherLatex = otherDenLatex ? frac(otherLatex, otherDenLatex) : otherLatex;
                        
                        // F√ºge Schritt hinzu
                        const list = document.getElementById('stepsList');
                        const prevStep = list.lastElementChild;
                        if (prevStep) {
                            const prevOp = prevStep.querySelector('.step-op');
                            const prevDivider = prevStep.querySelector('.step-divider');
                            if (prevOp) prevOp.innerHTML = renderLatex('\\sqrt[3]{\\phantom{x}}');
                            if (prevDivider) prevDivider.textContent = '|';
                        }
                        
                        currentStepIndex++;
                        const div = document.createElement('div');
                        div.className = 'step-item';
                        div.innerHTML = `
                            <div class="step-num">${currentStepIndex}</div>
                            <div class="step-left">${renderLatex(hl(baseVar))}</div>
                            <div class="step-equals">=</div>
                            <div class="step-right">${renderLatex(cbrt(fullOtherLatex))}</div>
                            <div class="step-divider"></div>
                            <div class="step-op"></div>
                        `;
                        list.appendChild(div);
                        
                        // Fertig!
                        clearInterval(timerInterval);
                        const timeTaken = Math.round((Date.now() - challengeStartTime) / 1000);
                        calculateScore(timeTaken);
                        
                        // Zeige Erfolg mit Kubikwurzel-Formel
                        document.getElementById('successFormula').innerHTML = 
                            `${renderLatex(hl(baseVar))} = ${renderLatex(cbrt(fullOtherLatex))}`;
                        
                        const stepsHtml = document.getElementById('stepsList').innerHTML;
                        document.getElementById('successSteps').innerHTML = stepsHtml;
                        
                        document.getElementById('successPoints').textContent = `+${Math.round(score / solved)}`;
                        document.getElementById('successTime').textContent = `${timeTaken}s`;
                        document.getElementById('successStreak').textContent = `üî• ${streak}`;
                        
                        document.getElementById('successOverlay').classList.add('show');
                        createConfetti();
                    }, 400);
                    return;
                }
                
                // Spezialfall: Bei needsCbrtStep ist nur cbrt richtig
                if (needsCbrtStep(currentEquationState) && opId !== 'cbrt') {
                    btn.classList.add('wrong');
                    showFeedback('wrong', '‚úó Jetzt musst du die Kubikwurzel ziehen!');
                    wrongAttempts++;
                    streak = 0;
                    updateStats();
                    setTimeout(() => btn.classList.remove('wrong'), 500);
                    return;
                }
                
                if (isTargetIsolated(currentEquationState)) return;
                
                const isHelpful = isOperationHelpful(currentEquationState, opId);
                
                if (isHelpful) {
                    // Korrekt - Operation hilft!
                    btn.classList.add('correct');
                    animateBalance(1);
                    showFeedback('correct', '‚úì Richtig!');
                    
                    // Speichere alten State f√ºr Anzeige
                    const oldState = currentEquationState;
                    
                    setTimeout(() => {
                        // Wende Operation an
                        currentEquationState = applyOpToState(currentEquationState, opId);
                        currentStepIndex++;
                        
                        // F√ºge Schritt zur Anzeige hinzu
                        addStepToDisplayFromState(oldState, currentEquationState, opId);
                        
                        if (isTargetIsolated(currentEquationState) && !needsSqrtStep(currentEquationState) && !needsCbrtStep(currentEquationState)) {
                            // Fertig!
                            clearInterval(timerInterval);
                            const timeTaken = Math.round((Date.now() - challengeStartTime) / 1000);
                            calculateScore(timeTaken);
                            setTimeout(() => showSuccessFromState(timeTaken), 300);
                        } else {
                            updateEquationDisplay();
                            renderOperationButtons();
                            animateBalance(0);
                        }
                    }, 400);
                } else {
                    // Nicht hilfreich - aber ist es in der Formel?
                    const formulaStr = currentFormula.displayFormula();
                    const opParts = opId.split('_');
                    const opVar = opParts[1];
                    
                    let isInFormula = checkIfInFormula(opId, opVar, formulaStr);
                    
                    wrongAttempts++;
                    streak = 0;
                    updateStats();
                    animateBalance(-1);
                    
                    if (isInFormula) {
                        btn.classList.add('possible');
                        showFeedback('possible', 'ü§î M√∂glich, aber nicht zielf√ºhrend!');
                        setTimeout(() => {
                            btn.classList.remove('possible');
                            animateBalance(0);
                        }, 500);
                    } else {
                        btn.classList.add('wrong');
                        showFeedback('wrong', '‚úó Falsch!');
                        setTimeout(() => {
                            btn.classList.remove('wrong');
                            animateBalance(0);
                        }, 500);
                    }
                }
                return;
            }
            
            // Altes Step-System
            if (!currentSteps || currentStepIndex >= currentSteps.steps.length) return;
            
            const currentStep = currentSteps.steps[currentStepIndex];
            const correctOpId = currentStep.opId;
            const alsoCorrect = currentStep.alsoCorrect || [];
            
            const isCorrect = (opId === correctOpId) || alsoCorrect.includes(opId);
            
            if (isCorrect) {
                btn.classList.add('correct');
                animateBalance(1);
                showFeedback('correct', '‚úì Richtig!');
                
                setTimeout(() => {
                    currentStepIndex++;
                    addStepToDisplay(currentSteps.steps[currentStepIndex - 1]);
                    
                    if (currentStepIndex >= currentSteps.steps.length) {
                        clearInterval(timerInterval);
                        const timeTaken = Math.round((Date.now() - challengeStartTime) / 1000);
                        calculateScore(timeTaken);
                        setTimeout(() => showSuccess(timeTaken), 300);
                    } else {
                        updateEquationDisplay();
                        renderOperationButtons();
                        animateBalance(0);
                    }
                }, 400);
            } else {
                const formulaStr = currentFormula.displayFormula();
                const opParts = opId.split('_');
                const opVar = opParts[1];
                
                let isInFormula = checkIfInFormula(opId, opVar, formulaStr);
                
                wrongAttempts++;
                streak = 0;
                updateStats();
                animateBalance(-1);
                
                if (isInFormula) {
                    btn.classList.add('possible');
                    showFeedback('possible', 'ü§î M√∂glich, aber nicht zielf√ºhrend!');
                    setTimeout(() => {
                        btn.classList.remove('possible');
                        animateBalance(0);
                    }, 500);
                } else {
                    btn.classList.add('wrong');
                    showFeedback('wrong', '‚úó Falsch!');
                    setTimeout(() => {
                        btn.classList.remove('wrong');
                        animateBalance(0);
                    }, 500);
                }
            }
        }
        
        function checkIfInFormula(opId, opVar, formulaStr) {
            const vars = currentFormula.variables;
            
            if (opVar === 'pi') return formulaStr.includes('\\pi');
            if (opVar === '2') return formulaStr.includes('2') && !formulaStr.includes('^{2}');
            if (opVar === 'r2') return formulaStr.includes('r}^{2}');
            if (opVar === '34' || opVar === '43') return formulaStr.includes('3') && formulaStr.includes('4');
            if (opVar === 'a2') return formulaStr.includes('a}^{2}');
            if (opVar === 'b2') return formulaStr.includes('b}^{2}');
            if (opVar === 'r') return vars.includes('r') || formulaStr.includes(' r') || formulaStr.includes('r}^');
            if (opVar === 's') return vars.includes('s') || formulaStr.includes(' s') || formulaStr.includes('/s');
            if (opVar === 't') return vars.includes('t') || formulaStr.includes(' t') || formulaStr.includes('/t');
            if (opVar === 'v') return vars.includes('v') || formulaStr.includes('v ') || formulaStr.startsWith('v');
            if (opVar === 'a') return vars.includes('a') || formulaStr.includes(' a') || formulaStr.includes('a}^');
            if (opVar === 'b') return vars.includes('b') || formulaStr.includes(' b') || formulaStr.includes('b}^');
            if (opVar === 'h') return vars.includes('h') || formulaStr.includes(' h');
            if (opVar === 'I') return vars.includes('I') || formulaStr.includes(' I');
            if (opVar === 'R') return vars.includes('R') || formulaStr.includes(' R');
            // Wurzeln sind "m√∂glich" wenn irgendeine Potenz vorhanden ist
            if (opId === 'sqrt') return formulaStr.includes('^{2}') || formulaStr.includes('^{3}');
            if (opId === 'cbrt') return formulaStr.includes('^{2}') || formulaStr.includes('^{3}');
            // Potenzen sind "m√∂glich" wenn Variablen vorhanden sind
            if (opId === 'pow2') return formulaStr.includes('^{2}') || formulaStr.includes('^{3}') || vars.length > 0;
            if (opId === 'pow3') return formulaStr.includes('^{2}') || formulaStr.includes('^{3}') || vars.length > 0;
            
            return false;
        }
        
        function addStepToDisplayFromState(oldState, newState, opId) {
            const list = document.getElementById('stepsList');
            
            // Operation zur vorherigen Zeile hinzuf√ºgen
            const prevStep = list.lastElementChild;
            if (prevStep) {
                const prevOp = prevStep.querySelector('.step-op');
                const prevDivider = prevStep.querySelector('.step-divider');
                if (prevOp) prevOp.innerHTML = renderLatex(allOpsLatex[opId]) || opId;
                if (prevDivider) prevDivider.textContent = '|';
            }
            
            // Neue Zeile (Ergebnis) hinzuf√ºgen
            const div = document.createElement('div');
            div.className = 'step-item';
            
            const leftHtml = renderSide(newState.leftNum, newState.leftDen, newState.target);
            const rightHtml = renderSide(newState.rightNum, newState.rightDen, newState.target);
            
            div.innerHTML = `
                <div class="step-num">${currentStepIndex}</div>
                <div class="step-left">${leftHtml}</div>
                <div class="step-equals">=</div>
                <div class="step-right">${rightHtml}</div>
                <div class="step-divider"></div>
                <div class="step-op"></div>
            `;
            list.appendChild(div);
        }
        
        function showSuccessFromState(timeTaken) {
            // Zeige finale Gleichung mit Variable links
            const target = currentEquationState.target;
            const leftSide = currentEquationState.leftNum;
            const rightSide = currentEquationState.rightNum;
            const leftDen = currentEquationState.leftDen;
            const rightDen = currentEquationState.rightDen;
            
            // Finde wo das Ziel jetzt ist
            const targetOnLeft = leftSide.includes(target) && leftSide.length === 1 && leftDen.length === 0;
            const targetOnRight = rightSide.includes(target) && rightSide.length === 1 && rightDen.length === 0;
            
            // Ziel soll links stehen in der Endanzeige
            let finalLeft, finalRight;
            if (targetOnRight) {
                // Ziel ist rechts, tausche
                finalLeft = renderSide(rightSide, rightDen, target);
                finalRight = renderSide(leftSide, leftDen, target);
            } else {
                // Ziel ist links (oder wir lassen es wie es ist)
                finalLeft = renderSide(leftSide, leftDen, target);
                finalRight = renderSide(rightSide, rightDen, target);
            }
            
            document.getElementById('successFormula').innerHTML = `${finalLeft} = ${finalRight}`;
            
            // Schritte kopieren
            const stepsHtml = document.getElementById('stepsList').innerHTML;
            document.getElementById('successSteps').innerHTML = stepsHtml;
            
            // Stats nur im Spielmodus zeigen
            const successStats = document.querySelector('.success-stats');
            if (gameMode === 'practice') {
                successStats.style.display = 'none';
            } else {
                successStats.style.display = 'flex';
                const points = score;
                document.getElementById('successPoints').textContent = `+${Math.round(points / solved)}`;
                document.getElementById('successTime').textContent = `${timeTaken}s`;
                document.getElementById('successStreak').textContent = `üî• ${streak}`;
            }
            
            document.getElementById('successOverlay').classList.add('show');
            createConfetti();
        }

        function calculateScore(timeTaken) {
            let points = 100;
            
            // Time bonus
            const maxTime = difficulty === 'easy' ? 90 : difficulty === 'medium' ? 60 : 45;
            const timeBonus = Math.max(0, Math.round((maxTime - timeTaken) / maxTime * 50));
            points += timeBonus;
            
            // Difficulty multiplier
            const diffMultiplier = difficulty === 'easy' ? 1 : difficulty === 'medium' ? 1.5 : 2;
            points = Math.round(points * diffMultiplier);
            
            // Penalty for wrong attempts
            points -= wrongAttempts * 10;
            points = Math.max(10, points);
            
            // Streak bonus
            streak++;
            if (streak > maxStreak) maxStreak = streak;
            if (streak >= 3) points += 25;
            if (streak >= 5) points += 50;
            
            score += points;
            solved++;
            updateStats();
            
            return points;
        }

        function showFeedback(type, text) {
            const msg = document.createElement('div');
            msg.className = `feedback-msg ${type}`;
            msg.textContent = text;
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 1200);
        }

        function showSuccess(timeTaken) {
            const lastStep = currentSteps.steps[currentSteps.steps.length - 1];
            // Verwende final wenn vorhanden, sonst tausche links/rechts
            const finalLeft = lastStep.final ? lastStep.final.left : lastStep.right;
            const finalRight = lastStep.final ? lastStep.final.right : lastStep.left;
            document.getElementById('successFormula').innerHTML = `${renderLatex(finalLeft)} = ${renderLatex(finalRight)}`;
            
            // Schritte kopieren
            const stepsHtml = document.getElementById('stepsList').innerHTML;
            document.getElementById('successSteps').innerHTML = stepsHtml;
            
            // Stats nur im Spielmodus zeigen
            const successStats = document.querySelector('.success-stats');
            if (gameMode === 'practice') {
                successStats.style.display = 'none';
            } else {
                successStats.style.display = 'flex';
                const points = score;
                document.getElementById('successPoints').textContent = `+${Math.round(points / solved)}`;
                document.getElementById('successTime').textContent = `${timeTaken}s`;
                document.getElementById('successStreak').textContent = `üî• ${streak}`;
            }
            
            document.getElementById('successOverlay').classList.add('show');
            createConfetti();
        }

        function nextChallenge() {
            document.getElementById('successOverlay').classList.remove('show');
            if (gameMode === 'practice') {
                loadChallenge(practiceIndex + 1);
            } else {
                loadChallenge(solved);
            }
        }

        function showLevelComplete() {
            clearInterval(timerInterval);
            
            document.getElementById('gameScreen').classList.remove('active');
            document.getElementById('hintBtn').style.display = 'none';
            
            // Calculate stars
            const accuracy = solved / totalChallenges;
            let stars = '‚≠ê';
            if (accuracy >= 0.6) stars = '‚≠ê‚≠ê';
            if (accuracy >= 0.8 && maxStreak >= 3) stars = '‚≠ê‚≠ê‚≠ê';
            
            document.getElementById('levelStars').textContent = stars;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalCorrect').textContent = `${solved}/${totalChallenges}`;
            document.getElementById('finalStreak').textContent = `üî• ${maxStreak}`;
            
            document.getElementById('levelCompleteOverlay').classList.add('show');
            createConfetti();
        }

        function goToMenu() {
            clearInterval(timerInterval);
            document.getElementById('levelCompleteOverlay').classList.remove('show');
            document.getElementById('successOverlay').classList.remove('show');
            document.getElementById('gameScreen').classList.remove('active');
            document.getElementById('hintBtn').style.display = 'none';
            document.getElementById('hintPopup').classList.remove('show');
            document.getElementById('startScreen').style.display = 'block';
            
            // Home-Buttons und Stats ausblenden
            document.querySelectorAll('.home-btn').forEach(btn => btn.classList.remove('show'));
            document.querySelectorAll('.game-stat').forEach(el => el.classList.remove('show'));
        }

        function playAgain() {
            document.getElementById('levelCompleteOverlay').classList.remove('show');
            document.getElementById('selectScreen').style.display = 'block';
            document.querySelector('.select-home-btn').classList.add('show');
            document.querySelector('.home-btn:not(.select-home-btn)').classList.remove('show');
        }

        function startTimer() {
            clearInterval(timerInterval);
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 10) {
                    document.getElementById('timer').classList.add('warning');
                }
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    // Time's up - skip to next
                    streak = 0;
                    solved++;
                    updateStats();
                    loadChallenge(solved);
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            document.getElementById('timerValue').textContent = timeLeft;
            document.getElementById('timer').classList.toggle('warning', timeLeft <= 10);
        }

        function updateStats() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('streakDisplay').textContent = streak;
            document.getElementById('solvedDisplay').textContent = `${solved}/${totalChallenges}`;
            
            const streakIcon = document.getElementById('streakIcon');
            if (streak >= 3) {
                streakIcon.style.animation = 'flamePulse 0.3s ease infinite alternate';
            } else {
                streakIcon.style.animation = '';
            }
        }

        function updateProgress() {
            if (gameMode === 'practice') {
                // Im √úbungsmodus: einfach die Aufgabennummer anzeigen
                document.getElementById('progressFill').style.width = '100%';
                document.getElementById('progressText').textContent = `Aufgabe ${practiceIndex + 1}`;
            } else {
                const progress = (solved / totalChallenges) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressText').textContent = `${solved + 1}/${totalChallenges}`;
            }
        }

        function addStepToDisplay(step) {
            const list = document.getElementById('stepsList');
            
            // Operation zur vorherigen Zeile hinzuf√ºgen
            const prevStep = list.lastElementChild;
            if (prevStep) {
                const prevOp = prevStep.querySelector('.step-op');
                const prevDivider = prevStep.querySelector('.step-divider');
                if (prevOp) prevOp.innerHTML = step.op;
                if (prevDivider) prevDivider.textContent = '|';
            }
            
            // Neue Zeile (Ergebnis) hinzuf√ºgen - rendere LaTeX zu HTML
            const div = document.createElement('div');
            div.className = 'step-item';
            
            div.innerHTML = `
                <div class="step-num">${currentStepIndex}</div>
                <div class="step-left">${renderLatex(step.left)}</div>
                <div class="step-equals">=</div>
                <div class="step-right">${renderLatex(step.right)}</div>
                <div class="step-divider"></div>
                <div class="step-op"></div>
            `;
            list.appendChild(div);
        }

        function resetStepsDisplay() {
            const list = document.getElementById('stepsList');
            
            let leftHtml, rightHtml;
            if (currentEquationState) {
                leftHtml = renderSide(currentEquationState.leftNum, currentEquationState.leftDen, currentEquationState.target);
                rightHtml = renderSide(currentEquationState.rightNum, currentEquationState.rightDen, currentEquationState.target);
            } else if (currentSteps) {
                leftHtml = renderLatex(currentSteps.start.left);
                rightHtml = renderLatex(currentSteps.start.right);
            }
            
            list.innerHTML = `<div class="step-item">
                <div class="step-num">0</div>
                <div class="step-left">${leftHtml}</div>
                <div class="step-equals">=</div>
                <div class="step-right">${rightHtml}</div>
                <div class="step-divider"></div>
                <div class="step-op"></div>
            </div>`;
        }

        function animateBalance(direction) {
            // Waage entfernt - Funktion bleibt leer f√ºr Kompatibilit√§t
        }

        function toggleHint() {
            const popup = document.getElementById('hintPopup');
            if (popup.classList.contains('show')) {
                popup.classList.remove('show');
            } else {
                let hint = '';
                
                // Neues State-System
                if (currentEquationState) {
                    // Pr√ºfe ob Wurzel-Schritt n√∂tig
                    if (needsSqrtStep(currentEquationState)) {
                        hint = 'üí° Zieh die Quadratwurzel!';
                    } else if (needsCbrtStep(currentEquationState)) {
                        hint = 'üí° Zieh die Kubikwurzel!';
                    } else {
                        // Finde eine hilfreiche Operation
                        const helpfulOps = [];
                        const allOpIds = ['div_2', 'div_3', 'div_4', 'div_pi', 'mul_2', 'mul_3', 'mul_4', 'mul_pi', 
                                          'div_a', 'div_b', 'div_c', 'div_h', 'div_g', 'div_r', 'div_s', 'div_t',
                                          'mul_a', 'mul_b', 'mul_c', 'mul_h', 'mul_g', 'mul_r', 'mul_s', 'mul_t',
                                          'sub_a2', 'sub_b2', 'sub_c2', 'add_a2', 'add_b2', 'add_c2'];
                        
                        for (const opId of allOpIds) {
                            if (isOperationHelpful(currentEquationState, opId)) {
                                helpfulOps.push(opId);
                            }
                        }
                        
                        if (helpfulOps.length > 0) {
                            const randomOp = helpfulOps[Math.floor(Math.random() * helpfulOps.length)];
                            if (randomOp.startsWith('div_')) {
                                hint = 'üí° Versuch mal zu teilen!';
                            } else if (randomOp.startsWith('mul_')) {
                                hint = 'üí° Versuch mal zu multiplizieren!';
                            } else if (randomOp.startsWith('sub_')) {
                                hint = 'üí° Versuch mal zu subtrahieren!';
                            } else if (randomOp.startsWith('add_')) {
                                hint = 'üí° Versuch mal zu addieren!';
                            }
                        } else {
                            hint = 'üí° Schau dir die Faktoren genau an!';
                        }
                    }
                }
                // Altes Step-System
                else if (currentSteps && currentStepIndex < currentSteps.steps.length) {
                    const correctOp = currentSteps.steps[currentStepIndex].opId;
                    
                    if (correctOp.includes('div')) {
                        hint = 'üí° Versuch mal zu teilen!';
                    } else if (correctOp.includes('mul')) {
                        hint = 'üí° Versuch mal zu multiplizieren!';
                    } else if (correctOp.includes('sqrt') || correctOp.includes('cbrt')) {
                        hint = 'üí° Zieh eine Wurzel!';
                    } else if (correctOp.includes('sub')) {
                        hint = 'üí° Versuch mal zu subtrahieren!';
                    } else {
                        hint = 'üí° Welche Operation macht die letzte r√ºckg√§ngig?';
                    }
                }
                
                if (hint) {
                    popup.textContent = hint;
                    popup.classList.add('show');
                }
            }
        }

        function createConfetti() {
            const colors = ['#ffd700', '#ff6b35', '#e94560', '#4ade80', '#22d3ee', '#8b5cf6'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }
    </script>
</body>
</html>
