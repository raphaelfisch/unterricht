<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Körper im Würfel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #fff;
            color: #000;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        h1 { font-size: 1.2rem; font-weight: 500; margin-bottom: 20px; text-align: center; }
        
        .task-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 16px;
        }
        .view-box { text-align: center; }
        .view-box label { display: block; font-size: 0.85rem; color: #666; margin-bottom: 6px; }
        .view-box canvas { border: 1px solid #ccc; background: #fff; }
        
        .new-task-btn {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 0 auto 16px;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 0.95rem;
            background: #2563eb;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .new-task-btn:hover { background: #1d4ed8; }
        
        .workspace { width: 100%; position: relative; }
        #canvas3d { 
            border: 1px solid #ccc; 
            cursor: grab; 
            display: block; 
            background: #fff;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }
        #canvas3d:active { cursor: grabbing; }
        
        .controls { 
            margin-top: 12px; 
            display: flex; 
            gap: 8px; 
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            font-family: inherit; font-size: 0.85rem; padding: 6px 14px;
            border: 1px solid #ccc; background: #fff; cursor: pointer; border-radius: 3px;
        }
        button:hover { background: #f5f5f5; }
        button.active { background: #000; color: #fff; border-color: #000; }
        button.success { background: #16a34a; color: #fff; border-color: #16a34a; }
        button.success:hover { background: #15803d; }
        
        .status { 
            margin-top: 12px; 
            font-size: 0.85rem; 
            color: #666; 
            text-align: center;
        }
        .divider { width: 1px; background: #ddd; margin: 0 4px; }
        .feedback { 
            margin-top: 8px; 
            padding: 8px 12px; 
            border-radius: 4px; 
            font-size: 0.85rem; 
            display: none;
            text-align: center;
        }
        .feedback.correct { display: block; background: #dcfce7; color: #166534; border: 1px solid #86efac; }
        .feedback.incorrect { display: block; background: #fef2f2; color: #991b1b; border: 1px solid #fca5a5; }
        
        /* Mobile responsive */
        @media (max-width: 480px) {
            body { padding: 10px; }
            h1 { font-size: 1rem; margin-bottom: 12px; }
            
            .task-section {
                gap: 8px;
                margin-bottom: 10px;
            }
            .view-box label { font-size: 0.7rem; margin-bottom: 3px; }
            .view-box canvas { 
                width: 90px !important; 
                height: 90px !important; 
            }
            
            .new-task-btn {
                padding: 8px 16px;
                font-size: 0.85rem;
                margin-bottom: 10px;
            }
            
            #canvas3d {
                height: 300px !important;
            }
            
            .controls {
                gap: 5px;
                margin-top: 8px;
            }
            button {
                font-size: 0.75rem;
                padding: 5px 8px;
            }
            
            .status {
                font-size: 0.75rem;
                margin-top: 8px;
            }
            .feedback {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
        }
        
        /* Very small screens */
        @media (max-width: 360px) {
            .view-box canvas { 
                width: 75px !important; 
                height: 75px !important; 
            }
            button {
                font-size: 0.7rem;
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <h1>Körper im Würfel</h1>
    
    <div class="task-section">
        <div class="view-box">
            <label>von vorne</label>
            <canvas id="viewFront" width="120" height="120"></canvas>
        </div>
        <div class="view-box">
            <label>von rechts</label>
            <canvas id="viewRight" width="120" height="120"></canvas>
        </div>
        <div class="view-box">
            <label>von oben</label>
            <canvas id="viewTop" width="120" height="120"></canvas>
        </div>
    </div>
    
    <button class="new-task-btn" onclick="newTask()">Neue Aufgabe</button>
    
    <div class="workspace">
        <canvas id="canvas3d" width="600" height="450"></canvas>
        <div class="controls">
            <button onclick="setView('front')">von vorne</button>
            <button onclick="setView('right')">von rechts</button>
            <button onclick="setView('top')">von oben</button>
            <button onclick="setView('iso')" class="active" id="btnIso">Schrägbild</button>
        </div>
        <div class="controls">
            <button onclick="clearAll()">Löschen</button>
            <button class="success" onclick="checkSolution()">✓ Prüfen</button>
            <button onclick="showSolution()">Lösung</button>
        </div>
        <div class="status">
            <span id="statusText">Klicke zwei Punkte um eine Kante zu zeichnen</span>
            · <span id="edgeCount">0</span> Kanten
        </div>
        <div class="feedback" id="feedback"></div>
    </div>

    <script>
        let scene, camera, renderer;
        let edges = [];
        let selectedPoint = null;
        let pointMeshes = [];
        let hitBoxes = [];
        let edgeLines = [];
        let cubeEdgeLines = [];
        let faceMeshes = [];
        let raycaster, mouse;
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cubeGroup;
        let currentShape = null;
        
        // Camera orbit - Standard isometric like reference image
        // Looking from front-right-top towards center
        let cameraTheta = Math.PI / 5;    // slightly less than 45° horizontal
        let cameraPhi = Math.PI * 0.38;   // about 68° from top (more frontal view)
        const center = new THREE.Vector3(1, 1, 1);
        const cameraDistance = 4;
        
        const GRID_SIZE = 2;
        
        // Cube edge definitions with face information
        const cubeEdgeDefinitions = [
            // Bottom face edges (y=0)
            { from: [0,0,0], to: [2,0,0], faces: ['y0', 'z0'] },
            { from: [2,0,0], to: [2,0,2], faces: ['y0', 'x2'] },
            { from: [2,0,2], to: [0,0,2], faces: ['y0', 'z2'] },
            { from: [0,0,2], to: [0,0,0], faces: ['y0', 'x0'] },
            // Top face edges (y=2)
            { from: [0,2,0], to: [2,2,0], faces: ['y2', 'z0'] },
            { from: [2,2,0], to: [2,2,2], faces: ['y2', 'x2'] },
            { from: [2,2,2], to: [0,2,2], faces: ['y2', 'z2'] },
            { from: [0,2,2], to: [0,2,0], faces: ['y2', 'x0'] },
            // Vertical edges
            { from: [0,0,0], to: [0,2,0], faces: ['x0', 'z0'] },
            { from: [2,0,0], to: [2,2,0], faces: ['x2', 'z0'] },
            { from: [2,0,2], to: [2,2,2], faces: ['x2', 'z2'] },
            { from: [0,0,2], to: [0,2,2], faces: ['x0', 'z2'] }
        ];
        
        const shapes = {
            // ==================== WÜRFEL ====================
            wuerfel_gross: {
                name: "Würfel 2×2×2",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[0,2,2]], [[0,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[2,0,2],[2,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,0,2], [2,0,2], [2,2,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]], [[0,2,0], [2,2,0], [2,2,2], [0,2,2]]
                ]
            },
            wuerfel_klein_000: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,1,0],[1,1,0]], [[1,1,0],[1,1,1]], [[1,1,1],[0,1,1]], [[0,1,1],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[1,1,0]], [[1,0,1],[1,1,1]], [[0,0,1],[0,1,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,0,1], [1,0,1], [1,1,1], [0,1,1]],
                    [[0,0,0], [0,0,1], [0,1,1], [0,1,0]], [[1,0,0], [1,0,1], [1,1,1], [1,1,0]],
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]], [[0,1,0], [1,1,0], [1,1,1], [0,1,1]]
                ]
            },
            wuerfel_klein_100: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[1,0,1]], [[1,0,1],[1,0,0]],
                    [[1,1,0],[2,1,0]], [[2,1,0],[2,1,1]], [[2,1,1],[1,1,1]], [[1,1,1],[1,1,0]],
                    [[1,0,0],[1,1,0]], [[2,0,0],[2,1,0]], [[2,0,1],[2,1,1]], [[1,0,1],[1,1,1]]
                ],
                faces: [
                    [[1,0,0], [2,0,0], [2,1,0], [1,1,0]], [[1,0,1], [2,0,1], [2,1,1], [1,1,1]],
                    [[1,0,0], [1,0,1], [1,1,1], [1,1,0]], [[2,0,0], [2,0,1], [2,1,1], [2,1,0]],
                    [[1,0,0], [2,0,0], [2,0,1], [1,0,1]], [[1,1,0], [2,1,0], [2,1,1], [1,1,1]]
                ]
            },
            wuerfel_klein_111: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,1,1],[2,1,1]], [[2,1,1],[2,1,2]], [[2,1,2],[1,1,2]], [[1,1,2],[1,1,1]],
                    [[1,2,1],[2,2,1]], [[2,2,1],[2,2,2]], [[2,2,2],[1,2,2]], [[1,2,2],[1,2,1]],
                    [[1,1,1],[1,2,1]], [[2,1,1],[2,2,1]], [[2,1,2],[2,2,2]], [[1,1,2],[1,2,2]]
                ],
                faces: [
                    [[1,1,1], [2,1,1], [2,2,1], [1,2,1]], [[1,1,2], [2,1,2], [2,2,2], [1,2,2]],
                    [[1,1,1], [1,1,2], [1,2,2], [1,2,1]], [[2,1,1], [2,1,2], [2,2,2], [2,2,1]],
                    [[1,1,1], [2,1,1], [2,1,2], [1,1,2]], [[1,2,1], [2,2,1], [2,2,2], [1,2,2]]
                ]
            },
            wuerfel_klein_011: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,1,1],[1,1,1]], [[1,1,1],[1,1,2]], [[1,1,2],[0,1,2]], [[0,1,2],[0,1,1]],
                    [[0,2,1],[1,2,1]], [[1,2,1],[1,2,2]], [[1,2,2],[0,2,2]], [[0,2,2],[0,2,1]],
                    [[0,1,1],[0,2,1]], [[1,1,1],[1,2,1]], [[1,1,2],[1,2,2]], [[0,1,2],[0,2,2]]
                ],
                faces: [
                    [[0,1,1], [1,1,1], [1,2,1], [0,2,1]], [[0,1,2], [1,1,2], [1,2,2], [0,2,2]],
                    [[0,1,1], [0,1,2], [0,2,2], [0,2,1]], [[1,1,1], [1,1,2], [1,2,2], [1,2,1]],
                    [[0,1,1], [1,1,1], [1,1,2], [0,1,2]], [[0,2,1], [1,2,1], [1,2,2], [0,2,2]]
                ]
            },
            
            // ==================== QUADER ====================
            quader_2x2x1: {
                name: "Quader 2×2×1",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[0,1,2]], [[0,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,2],[2,1,2]], [[0,0,2],[0,1,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,1,0], [0,1,0]], [[0,0,2], [2,0,2], [2,1,2], [0,1,2]],
                    [[0,0,0], [0,0,2], [0,1,2], [0,1,0]], [[2,0,0], [2,0,2], [2,1,2], [2,1,0]],
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]], [[0,1,0], [2,1,0], [2,1,2], [0,1,2]]
                ]
            },
            quader_2x1x2: {
                name: "Quader 2×1×2",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,2,1]], [[2,2,1],[0,2,1]], [[0,2,1],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[2,0,1],[2,2,1]], [[0,0,1],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,0,1], [2,0,1], [2,2,1], [0,2,1]],
                    [[0,0,0], [0,0,1], [0,2,1], [0,2,0]], [[2,0,0], [2,0,1], [2,2,1], [2,2,0]],
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]], [[0,2,0], [2,2,0], [2,2,1], [0,2,1]]
                ]
            },
            quader_1x2x2: {
                name: "Quader 1×2×2",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,2,0],[1,2,0]], [[1,2,0],[1,2,2]], [[1,2,2],[0,2,2]], [[0,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[1,2,0]], [[1,0,2],[1,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,2,0], [0,2,0]], [[0,0,2], [1,0,2], [1,2,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[1,0,0], [1,0,2], [1,2,2], [1,2,0]],
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]], [[0,2,0], [1,2,0], [1,2,2], [0,2,2]]
                ]
            },
            quader_2x1x1: {
                name: "Quader 2×1×1",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,1]], [[2,1,1],[0,1,1]], [[0,1,1],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,1],[2,1,1]], [[0,0,1],[0,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,1,0], [0,1,0]], [[0,0,1], [2,0,1], [2,1,1], [0,1,1]],
                    [[0,0,0], [0,0,1], [0,1,1], [0,1,0]], [[2,0,0], [2,0,1], [2,1,1], [2,1,0]],
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]], [[0,1,0], [2,1,0], [2,1,1], [0,1,1]]
                ]
            },
            quader_1x2x1: {
                name: "Quader 1×2×1",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,2,0],[1,2,0]], [[1,2,0],[1,2,1]], [[1,2,1],[0,2,1]], [[0,2,1],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[1,2,0]], [[1,0,1],[1,2,1]], [[0,0,1],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,2,0], [0,2,0]], [[0,0,1], [1,0,1], [1,2,1], [0,2,1]],
                    [[0,0,0], [0,0,1], [0,2,1], [0,2,0]], [[1,0,0], [1,0,1], [1,2,1], [1,2,0]],
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]], [[0,2,0], [1,2,0], [1,2,1], [0,2,1]]
                ]
            },
            quader_1x1x2: {
                name: "Quader 1×1×2",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,0],[1,1,0]], [[1,1,0],[1,1,2]], [[1,1,2],[0,1,2]], [[0,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[1,1,0]], [[1,0,2],[1,1,2]], [[0,0,2],[0,1,2]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,0,2], [1,0,2], [1,1,2], [0,1,2]],
                    [[0,0,0], [0,0,2], [0,1,2], [0,1,0]], [[1,0,0], [1,0,2], [1,1,2], [1,1,0]],
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]], [[0,1,0], [1,1,0], [1,1,2], [0,1,2]]
                ]
            },
            quader_1x1x2_oben: {
                name: "Quader 1×1×2",
                edges: [
                    [[1,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[1,1,2]], [[1,1,2],[1,1,0]],
                    [[1,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[1,2,2]], [[1,2,2],[1,2,0]],
                    [[1,1,0],[1,2,0]], [[2,1,0],[2,2,0]], [[2,1,2],[2,2,2]], [[1,1,2],[1,2,2]]
                ],
                faces: [
                    [[1,1,0], [2,1,0], [2,2,0], [1,2,0]], [[1,1,2], [2,1,2], [2,2,2], [1,2,2]],
                    [[1,1,0], [1,1,2], [1,2,2], [1,2,0]], [[2,1,0], [2,1,2], [2,2,2], [2,2,0]],
                    [[1,1,0], [2,1,0], [2,1,2], [1,1,2]], [[1,2,0], [2,2,0], [2,2,2], [1,2,2]]
                ]
            },
            
            // ==================== DREIECKSPRISMEN ====================
            prisma_dreieck_RW_stehend: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[2,0,0],[2,2,0]], [[2,2,0],[2,0,2]], [[2,0,2],[2,0,0]],
                    [[0,0,0],[2,0,0]], [[0,2,0],[2,2,0]], [[0,0,2],[2,0,2]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [0,0,2]], [[2,0,0], [2,2,0], [2,0,2]],
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,2,0], [2,2,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]]
                ]
            },
            prisma_dreieck_GS_stehend: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[1,0,2]], [[1,0,2],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[1,2,2]], [[1,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[1,0,2],[1,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [1,0,2]], [[0,2,0], [2,2,0], [1,2,2]],
                    [[0,0,0], [0,2,0], [2,2,0], [2,0,0]], [[2,0,0], [2,2,0], [1,2,2], [1,0,2]],
                    [[0,0,0], [1,0,2], [1,2,2], [0,2,0]]
                ]
            },
            prisma_dreieck_liegend_z: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0]], [[0,0,2], [2,0,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            prisma_dreieck_liegend_y: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,2],[2,1,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2]], [[0,1,0], [2,1,0], [2,1,2]],
                    [[0,0,0], [0,1,0], [2,1,0], [2,0,0]], [[2,0,0], [2,1,0], [2,1,2], [2,0,2]],
                    [[0,0,0], [2,0,2], [2,1,2], [0,1,0]]
                ]
            },
            prisma_dreieck_klein: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[0,1,0]], [[0,1,0],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[1,0,0],[1,1,0]], [[1,1,0],[1,0,1]], [[1,0,1],[1,0,0]],
                    [[0,0,0],[1,0,0]], [[0,1,0],[1,1,0]], [[0,0,1],[1,0,1]]
                ],
                faces: [
                    [[0,0,0], [0,1,0], [0,0,1]], [[1,0,0], [1,1,0], [1,0,1]],
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,1,0], [1,1,0], [1,0,1], [0,0,1]],
                    [[0,0,0], [0,0,1], [1,0,1], [1,0,0]]
                ]
            },
            // Diagonales Prisma (wie auf dem Bild)
            prisma_diagonal: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[0,2,0]], [[0,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[0,2,2]], [[0,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[0,2,0],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [0,2,0]], [[0,0,2], [2,0,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [0,2,2], [0,2,0]],
                    [[0,0,0], [0,2,0], [0,2,2], [0,0,2]]
                ]
            },
            prisma_diagonal_2: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0]], [[0,0,2], [2,0,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            prisma_diagonal_3: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[0,2,2]], [[0,2,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[0,2,0],[0,2,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [2,2,0]], [[0,0,2], [0,2,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[0,2,0], [0,2,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            
            // ==================== PYRAMIDEN (gross 2×2 Basis) ====================
            pyramide_quadrat_hoch: {
                name: "Pyramide",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,2,1]], [[2,0,0],[1,2,1]], [[2,0,2],[1,2,1]], [[0,0,2],[1,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,2,1]], [[2,0,0], [2,0,2], [1,2,1]],
                    [[2,0,2], [0,0,2], [1,2,1]], [[0,0,2], [0,0,0], [1,2,1]]
                ]
            },
            pyramide_quadrat_flach: {
                name: "Pyramide (flach)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,1,1]], [[2,0,0],[1,1,1]], [[2,0,2],[1,1,1]], [[0,0,2],[1,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,1,1]], [[2,0,0], [2,0,2], [1,1,1]],
                    [[2,0,2], [0,0,2], [1,1,1]], [[0,0,2], [0,0,0], [1,1,1]]
                ]
            },
            pyramide_seitlich: {
                name: "Pyramide (seitlich)",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[0,2,2]], [[0,2,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,1,1]], [[0,2,0],[2,1,1]], [[0,2,2],[2,1,1]], [[0,0,2],[2,1,1]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [0,2,2], [0,0,2]],
                    [[0,0,0], [0,2,0], [2,1,1]], [[0,2,0], [0,2,2], [2,1,1]],
                    [[0,2,2], [0,0,2], [2,1,1]], [[0,0,2], [0,0,0], [2,1,1]]
                ]
            },
            pyramide_ecke: {
                name: "Pyramide (Spitze an Ecke)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,2,2]], [[2,0,0],[2,2,2]], [[2,0,2],[2,2,2]], [[0,0,2],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,2,2]], [[2,0,0], [2,0,2], [2,2,2]],
                    [[2,0,2], [0,0,2], [2,2,2]], [[0,0,2], [0,0,0], [2,2,2]]
                ]
            },
            
            // ==================== PYRAMIDEN (klein 1×1 Basis) ====================
            pyramide_klein_hoch: {
                name: "Pyramide (klein, hoch)",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[0,2,0]], [[1,0,1],[0,2,0]], [[0,0,1],[0,2,0]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]],
                    [[0,0,0], [1,0,0], [0,2,0]], [[1,0,0], [1,0,1], [0,2,0]],
                    [[1,0,1], [0,0,1], [0,2,0]], [[0,0,1], [0,0,0], [0,2,0]]
                ]
            },
            pyramide_klein_mitte: {
                name: "Pyramide (klein)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,1,1]], [[2,0,0],[1,1,1]], [[2,0,2],[1,1,1]], [[0,0,2],[1,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,1,1]], [[2,0,0], [2,0,2], [1,1,1]],
                    [[2,0,2], [0,0,2], [1,1,1]], [[0,0,2], [0,0,0], [1,1,1]]
                ]
            },
            
            // ==================== TETRAEDER ====================
            tetraeder_gross: {
                name: "Tetraeder",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[1,0,2]], [[1,0,2],[0,0,0]],
                    [[0,0,0],[1,2,1]], [[2,0,0],[1,2,1]], [[1,0,2],[1,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [1,0,2]],
                    [[0,0,0], [2,0,0], [1,2,1]], [[2,0,0], [1,0,2], [1,2,1]], [[1,0,2], [0,0,0], [1,2,1]]
                ]
            },
            tetraeder_RW: {
                name: "Tetraeder (rechtwinklig)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[0,2,0]], [[0,0,2],[0,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [0,0,2]],
                    [[0,0,0], [2,0,0], [0,2,0]], [[2,0,0], [0,0,2], [0,2,0]], [[0,0,2], [0,0,0], [0,2,0]]
                ]
            },
            tetraeder_klein: {
                name: "Tetraeder (klein)",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[0,1,0]], [[0,0,1],[0,1,0]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [0,0,1]],
                    [[0,0,0], [1,0,0], [0,1,0]], [[1,0,0], [0,0,1], [0,1,0]], [[0,0,1], [0,0,0], [0,1,0]]
                ]
            },
            
            // ==================== RECHTECKIGE PYRAMIDEN ====================
            pyramide_rechteck_1: {
                name: "Rechteckige Pyramide",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[1,2,0]], [[2,0,0],[1,2,0]], [[2,0,1],[1,2,0]], [[0,0,1],[1,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]],
                    [[0,0,0], [2,0,0], [1,2,0]], [[2,0,0], [2,0,1], [1,2,0]],
                    [[2,0,1], [0,0,1], [1,2,0]], [[0,0,1], [0,0,0], [1,2,0]]
                ]
            },
            pyramide_rechteck_2: {
                name: "Rechteckige Pyramide",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,1]], [[1,0,0],[0,2,1]], [[1,0,2],[0,2,1]], [[0,0,2],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]],
                    [[0,0,0], [1,0,0], [0,2,1]], [[1,0,0], [1,0,2], [0,2,1]],
                    [[1,0,2], [0,0,2], [0,2,1]], [[0,0,2], [0,0,0], [0,2,1]]
                ]
            },
            
            // ==================== SPEZIALFORMEN ====================
            dach: {
                name: "Dachform",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,1],[2,1,1]],
                    [[0,0,0],[0,1,1]], [[0,0,2],[0,1,1]], [[2,0,0],[2,1,1]], [[2,0,2],[2,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,1,1], [0,1,1]], 
                    [[0,0,2], [2,0,2], [2,1,1], [0,1,1]],
                    [[0,0,0], [0,0,2], [0,1,1]], [[2,0,0], [2,0,2], [2,1,1]]
                ]
            },
            keil: {
                name: "Keil",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]],
                    [[0,2,0],[2,2,0]],
                    [[0,0,2],[0,2,0]], [[2,0,2],[2,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]],
                    [[0,0,0], [0,0,2], [0,2,0]], [[2,0,0], [2,0,2], [2,2,0]],
                    [[0,0,2], [2,0,2], [2,2,0], [0,2,0]]
                ]
            },
            halber_wuerfel: {
                name: "Halber Würfel",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,2,0]], [[0,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]], 
                    [[0,2,0],[0,0,2]], [[0,0,2],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]],
                    [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [0,2,0], [0,0,2]],
                    [[0,2,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            
            // ==================== MEHR WÜRFEL POSITIONEN ====================
            wuerfel_klein_010: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,1,0],[1,1,0]], [[1,1,0],[1,1,1]], [[1,1,1],[0,1,1]], [[0,1,1],[0,1,0]],
                    [[0,2,0],[1,2,0]], [[1,2,0],[1,2,1]], [[1,2,1],[0,2,1]], [[0,2,1],[0,2,0]],
                    [[0,1,0],[0,2,0]], [[1,1,0],[1,2,0]], [[1,1,1],[1,2,1]], [[0,1,1],[0,2,1]]
                ],
                faces: [
                    [[0,1,0], [1,1,0], [1,2,0], [0,2,0]], [[0,1,1], [1,1,1], [1,2,1], [0,2,1]],
                    [[0,1,0], [0,1,1], [0,2,1], [0,2,0]], [[1,1,0], [1,1,1], [1,2,1], [1,2,0]],
                    [[0,1,0], [1,1,0], [1,1,1], [0,1,1]], [[0,2,0], [1,2,0], [1,2,1], [0,2,1]]
                ]
            },
            wuerfel_klein_001: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,0,1],[1,0,1]], [[1,0,1],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,1]],
                    [[0,1,1],[1,1,1]], [[1,1,1],[1,1,2]], [[1,1,2],[0,1,2]], [[0,1,2],[0,1,1]],
                    [[0,0,1],[0,1,1]], [[1,0,1],[1,1,1]], [[1,0,2],[1,1,2]], [[0,0,2],[0,1,2]]
                ],
                faces: [
                    [[0,0,1], [1,0,1], [1,1,1], [0,1,1]], [[0,0,2], [1,0,2], [1,1,2], [0,1,2]],
                    [[0,0,1], [0,0,2], [0,1,2], [0,1,1]], [[1,0,1], [1,0,2], [1,1,2], [1,1,1]],
                    [[0,0,1], [1,0,1], [1,0,2], [0,0,2]], [[0,1,1], [1,1,1], [1,1,2], [0,1,2]]
                ]
            },
            wuerfel_klein_110: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,1,0],[2,1,0]], [[2,1,0],[2,1,1]], [[2,1,1],[1,1,1]], [[1,1,1],[1,1,0]],
                    [[1,2,0],[2,2,0]], [[2,2,0],[2,2,1]], [[2,2,1],[1,2,1]], [[1,2,1],[1,2,0]],
                    [[1,1,0],[1,2,0]], [[2,1,0],[2,2,0]], [[2,1,1],[2,2,1]], [[1,1,1],[1,2,1]]
                ],
                faces: [
                    [[1,1,0], [2,1,0], [2,2,0], [1,2,0]], [[1,1,1], [2,1,1], [2,2,1], [1,2,1]],
                    [[1,1,0], [1,1,1], [1,2,1], [1,2,0]], [[2,1,0], [2,1,1], [2,2,1], [2,2,0]],
                    [[1,1,0], [2,1,0], [2,1,1], [1,1,1]], [[1,2,0], [2,2,0], [2,2,1], [1,2,1]]
                ]
            },
            wuerfel_klein_101: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,0,1],[2,0,1]], [[2,0,1],[2,0,2]], [[2,0,2],[1,0,2]], [[1,0,2],[1,0,1]],
                    [[1,1,1],[2,1,1]], [[2,1,1],[2,1,2]], [[2,1,2],[1,1,2]], [[1,1,2],[1,1,1]],
                    [[1,0,1],[1,1,1]], [[2,0,1],[2,1,1]], [[2,0,2],[2,1,2]], [[1,0,2],[1,1,2]]
                ],
                faces: [
                    [[1,0,1], [2,0,1], [2,1,1], [1,1,1]], [[1,0,2], [2,0,2], [2,1,2], [1,1,2]],
                    [[1,0,1], [1,0,2], [1,1,2], [1,1,1]], [[2,0,1], [2,0,2], [2,1,2], [2,1,1]],
                    [[1,0,1], [2,0,1], [2,0,2], [1,0,2]], [[1,1,1], [2,1,1], [2,1,2], [1,1,2]]
                ]
            },
            
            // ==================== MEHR QUADER POSITIONEN ====================
            quader_2x2x1_oben: {
                name: "Quader 2×2×1",
                edges: [
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[0,1,2]], [[0,1,2],[0,1,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[0,2,2]], [[0,2,2],[0,2,0]],
                    [[0,1,0],[0,2,0]], [[2,1,0],[2,2,0]], [[2,1,2],[2,2,2]], [[0,1,2],[0,2,2]]
                ],
                faces: [
                    [[0,1,0], [2,1,0], [2,2,0], [0,2,0]], [[0,1,2], [2,1,2], [2,2,2], [0,2,2]],
                    [[0,1,0], [0,1,2], [0,2,2], [0,2,0]], [[2,1,0], [2,1,2], [2,2,2], [2,2,0]],
                    [[0,1,0], [2,1,0], [2,1,2], [0,1,2]], [[0,2,0], [2,2,0], [2,2,2], [0,2,2]]
                ]
            },
            quader_1x2x2_rechts: {
                name: "Quader 1×2×2",
                edges: [
                    [[1,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[1,0,2]], [[1,0,2],[1,0,0]],
                    [[1,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[1,2,2]], [[1,2,2],[1,2,0]],
                    [[1,0,0],[1,2,0]], [[2,0,0],[2,2,0]], [[2,0,2],[2,2,2]], [[1,0,2],[1,2,2]]
                ],
                faces: [
                    [[1,0,0], [2,0,0], [2,2,0], [1,2,0]], [[1,0,2], [2,0,2], [2,2,2], [1,2,2]],
                    [[1,0,0], [1,0,2], [1,2,2], [1,2,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[1,0,0], [2,0,0], [2,0,2], [1,0,2]], [[1,2,0], [2,2,0], [2,2,2], [1,2,2]]
                ]
            },
            quader_2x1x2_hinten: {
                name: "Quader 2×1×2",
                edges: [
                    [[0,0,1],[2,0,1]], [[2,0,1],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,1]],
                    [[0,2,1],[2,2,1]], [[2,2,1],[2,2,2]], [[2,2,2],[0,2,2]], [[0,2,2],[0,2,1]],
                    [[0,0,1],[0,2,1]], [[2,0,1],[2,2,1]], [[2,0,2],[2,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,1], [2,0,1], [2,2,1], [0,2,1]], [[0,0,2], [2,0,2], [2,2,2], [0,2,2]],
                    [[0,0,1], [0,0,2], [0,2,2], [0,2,1]], [[2,0,1], [2,0,2], [2,2,2], [2,2,1]],
                    [[0,0,1], [2,0,1], [2,0,2], [0,0,2]], [[0,2,1], [2,2,1], [2,2,2], [0,2,2]]
                ]
            },
            
            // ==================== MEHR PRISMEN ====================
            prisma_diagonal_4: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,0,0]], [[2,0,0],[0,2,0]],
                    [[0,2,2],[2,2,2]], [[2,2,2],[2,0,2]], [[2,0,2],[0,2,2]],
                    [[0,2,0],[0,2,2]], [[2,2,0],[2,2,2]], [[2,0,0],[2,0,2]]
                ],
                faces: [
                    [[0,2,0], [2,2,0], [2,0,0]], [[0,2,2], [2,2,2], [2,0,2]],
                    [[0,2,0], [0,2,2], [2,2,2], [2,2,0]], [[2,2,0], [2,2,2], [2,0,2], [2,0,0]],
                    [[0,2,0], [2,0,0], [2,0,2], [0,2,2]]
                ]
            },
            prisma_klein_oben: {
                name: "Dreiecksprisma",
                edges: [
                    [[1,1,1],[1,2,1]], [[1,2,1],[1,1,2]], [[1,1,2],[1,1,1]],
                    [[2,1,1],[2,2,1]], [[2,2,1],[2,1,2]], [[2,1,2],[2,1,1]],
                    [[1,1,1],[2,1,1]], [[1,2,1],[2,2,1]], [[1,1,2],[2,1,2]]
                ],
                faces: [
                    [[1,1,1], [1,2,1], [1,1,2]], [[2,1,1], [2,2,1], [2,1,2]],
                    [[1,1,1], [2,1,1], [2,2,1], [1,2,1]], [[1,2,1], [2,2,1], [2,1,2], [1,1,2]],
                    [[1,1,1], [1,1,2], [2,1,2], [2,1,1]]
                ]
            },
            
            // ==================== MEHR PYRAMIDEN ====================
            pyramide_seitlich_rechts: {
                name: "Pyramide (seitlich)",
                edges: [
                    [[2,0,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[2,0,2]], [[2,0,2],[2,0,0]],
                    [[2,0,0],[0,1,1]], [[2,2,0],[0,1,1]], [[2,2,2],[0,1,1]], [[2,0,2],[0,1,1]]
                ],
                faces: [
                    [[2,0,0], [2,2,0], [2,2,2], [2,0,2]],
                    [[2,0,0], [2,2,0], [0,1,1]], [[2,2,0], [2,2,2], [0,1,1]],
                    [[2,2,2], [2,0,2], [0,1,1]], [[2,0,2], [2,0,0], [0,1,1]]
                ]
            },
            pyramide_ecke_2: {
                name: "Pyramide (Spitze an Ecke)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,2]], [[2,0,0],[0,2,2]], [[2,0,2],[0,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [0,2,2]], [[2,0,0], [2,0,2], [0,2,2]],
                    [[2,0,2], [0,0,2], [0,2,2]], [[0,0,2], [0,0,0], [0,2,2]]
                ]
            },
            pyramide_ecke_3: {
                name: "Pyramide (Spitze an Ecke)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,2,0]], [[2,0,0],[2,2,0]], [[2,0,2],[2,2,0]], [[0,0,2],[2,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,2,0]], [[2,0,0], [2,0,2], [2,2,0]],
                    [[2,0,2], [0,0,2], [2,2,0]], [[0,0,2], [0,0,0], [2,2,0]]
                ]
            },
            pyramide_klein_ecke: {
                name: "Pyramide (klein)",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[1,1,1]], [[1,0,0],[1,1,1]], [[1,0,1],[1,1,1]], [[0,0,1],[1,1,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]],
                    [[0,0,0], [1,0,0], [1,1,1]], [[1,0,0], [1,0,1], [1,1,1]],
                    [[1,0,1], [0,0,1], [1,1,1]], [[0,0,1], [0,0,0], [1,1,1]]
                ]
            },
            
            // ==================== MEHR TETRAEDER ====================
            tetraeder_ecke_2: {
                name: "Tetraeder",
                edges: [
                    [[2,0,0],[2,2,0]], [[2,2,0],[2,0,2]], [[2,0,2],[2,0,0]],
                    [[2,0,0],[0,0,0]], [[2,2,0],[0,0,0]], [[2,0,2],[0,0,0]]
                ],
                faces: [
                    [[2,0,0], [2,2,0], [2,0,2]],
                    [[2,0,0], [2,2,0], [0,0,0]], [[2,2,0], [2,0,2], [0,0,0]], [[2,0,2], [2,0,0], [0,0,0]]
                ]
            },
            tetraeder_ecke_3: {
                name: "Tetraeder",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,0,0]], [[0,2,0],[2,0,0]], [[0,0,2],[2,0,0]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [0,0,2]],
                    [[0,0,0], [0,2,0], [2,0,0]], [[0,2,0], [0,0,2], [2,0,0]], [[0,0,2], [0,0,0], [2,0,0]]
                ]
            },
            
            // ==================== MEHR KEILE ====================
            keil_2: {
                name: "Keil",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,2],[0,2,2]], [[2,0,2],[2,2,2]],
                    [[0,2,2],[2,2,2]],
                    [[0,0,0],[0,2,2]], [[2,0,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,2], [2,0,2], [2,2,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2]], [[2,0,0], [2,0,2], [2,2,2]],
                    [[0,0,0], [2,0,0], [2,2,2], [0,2,2]]
                ]
            },
            keil_3: {
                name: "Keil",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[0,0,2],[0,2,2]],
                    [[0,2,0],[0,2,2]],
                    [[2,0,0],[0,2,0]], [[2,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]],
                    [[0,0,0], [2,0,0], [0,2,0]], [[0,0,2], [2,0,2], [0,2,2]],
                    [[2,0,0], [2,0,2], [0,2,2], [0,2,0]]
                ]
            }
        };
        
        function init() {
            const canvas = document.getElementById('canvas3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            const aspect = canvas.width / canvas.height;
            const frustumSize = 5;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 1000
            );
            updateCameraPosition();
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            createGrid();
            createWireframeCube();
            createOrientationCube();
            updateCameraPosition(); // Set initial camera position for both main and orientation cube
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            canvas.addEventListener('click', onClick);
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd);
            
            newTask();
            handleResize();
            animate();
        }
        
        function updateCameraPosition() {
            const x = center.x + cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            const y = center.y + cameraDistance * Math.cos(cameraPhi);
            const z = center.z + cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.set(x, y, z);
            camera.lookAt(center);
            camera.updateProjectionMatrix();
            
            // Update orientation camera to match
            if (orientationCamera) {
                const dist = 5;
                orientationCamera.position.set(
                    dist * Math.sin(cameraPhi) * Math.sin(cameraTheta),
                    dist * Math.cos(cameraPhi),
                    dist * Math.sin(cameraPhi) * Math.cos(cameraTheta)
                );
                orientationCamera.lookAt(0, 0, 0);
            }
        }
        
        // Determine which faces of the cube are hidden from current camera view
        function getHiddenFaces() {
            const camPos = camera.position;
            const hidden = [];
            
            // Face x=0 hidden if camera is on positive x side
            if (camPos.x > center.x) hidden.push('x0');
            else hidden.push('x2');
            
            // Face y=0 hidden if camera is above center
            if (camPos.y > center.y) hidden.push('y0');
            else hidden.push('y2');
            
            // Face z=0 hidden if camera is on positive z side
            if (camPos.z > center.z) hidden.push('z0');
            else hidden.push('z2');
            
            return hidden;
        }
        
        // Check if a cube edge is hidden (on two hidden faces)
        function isCubeEdgeHidden(edgeDef) {
            const hiddenFaces = getHiddenFaces();
            let hiddenCount = 0;
            for (const face of edgeDef.faces) {
                if (hiddenFaces.includes(face)) hiddenCount++;
            }
            return hiddenCount >= 2;
        }
        
        // Check if a shape edge is hidden
        function isShapeEdgeHidden(p1, p2) {
            if (!currentShape || !currentShape.faces) return false;
            
            const camPos = camera.position.clone();
            
            // Edge midpoint
            const edgeMid = new THREE.Vector3(
                (p1.x + p2.x) / 2,
                (p1.y + p2.y) / 2,
                (p1.z + p2.z) / 2
            );
            
            // Get all faces that this edge belongs to
            const edgeFaceIndices = [];
            for (let fi = 0; fi < currentShape.faces.length; fi++) {
                const face = currentShape.faces[fi];
                const p1OnFace = face.some(v => 
                    Math.abs(v[0] - p1.x) < 0.01 && 
                    Math.abs(v[1] - p1.y) < 0.01 && 
                    Math.abs(v[2] - p1.z) < 0.01
                );
                const p2OnFace = face.some(v => 
                    Math.abs(v[0] - p2.x) < 0.01 && 
                    Math.abs(v[1] - p2.y) < 0.01 && 
                    Math.abs(v[2] - p2.z) < 0.01
                );
                if (p1OnFace && p2OnFace) {
                    edgeFaceIndices.push(fi);
                }
            }
            
            // If edge has no faces or only one face, it's visible
            if (edgeFaceIndices.length <= 1) return false;
            
            // METHOD 1: Check if edge is occluded by another face (raycasting)
            const rayDir = new THREE.Vector3().subVectors(edgeMid, camPos).normalize();
            const distToEdge = camPos.distanceTo(edgeMid);
            
            for (let fi = 0; fi < currentShape.faces.length; fi++) {
                // Skip faces that contain this edge
                if (edgeFaceIndices.includes(fi)) continue;
                
                const face = currentShape.faces[fi];
                const vertices = face.map(v => new THREE.Vector3(v[0], v[1], v[2]));
                
                const t = rayPolygonIntersect(camPos, rayDir, vertices);
                
                if (t !== null && t > 0.01 && t < distToEdge - 0.01) {
                    return true; // Occluded by another face
                }
            }
            
            // METHOD 2: Check if all adjacent faces are back-facing (backface culling)
            // Calculate shape centroid
            const allVerts = new Set();
            currentShape.edges.forEach(edge => {
                allVerts.add(edge[0].join(','));
                allVerts.add(edge[1].join(','));
            });
            const shapeCentroid = new THREE.Vector3();
            allVerts.forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                shapeCentroid.add(new THREE.Vector3(x, y, z));
            });
            shapeCentroid.divideScalar(allVerts.size);
            
            // Check each adjacent face
            for (const fi of edgeFaceIndices) {
                const face = currentShape.faces[fi];
                const vertices = face.map(v => new THREE.Vector3(v[0], v[1], v[2]));
                
                // Face centroid
                const faceCentroid = new THREE.Vector3();
                vertices.forEach(v => faceCentroid.add(v));
                faceCentroid.divideScalar(vertices.length);
                
                // Face normal
                const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];
                const e1 = new THREE.Vector3().subVectors(v1, v0);
                const e2 = new THREE.Vector3().subVectors(v2, v0);
                const normal = new THREE.Vector3().crossVectors(e1, e2).normalize();
                
                // Test which direction is "outside" by moving a test point
                const testDist = 0.5;
                const testPointA = faceCentroid.clone().add(normal.clone().multiplyScalar(testDist));
                const testPointB = faceCentroid.clone().sub(normal.clone().multiplyScalar(testDist));
                
                // The point farther from shape center is "outside"
                const distA = testPointA.distanceTo(shapeCentroid);
                const distB = testPointB.distanceTo(shapeCentroid);
                
                const outwardNormal = (distA > distB) ? normal : normal.clone().negate();
                
                // Direction from face to camera  
                const faceToCamera = new THREE.Vector3().subVectors(camPos, faceCentroid);
                
                // Face is front-facing if outward normal points towards camera
                if (outwardNormal.dot(faceToCamera) > 0) {
                    return false; // At least one face is visible, edge is visible
                }
            }
            
            // All adjacent faces are back-facing
            return true;
        }
        
        function rayPolygonIntersect(rayOrigin, rayDir, vertices) {
            const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];
            const e1 = new THREE.Vector3().subVectors(v1, v0);
            const e2 = new THREE.Vector3().subVectors(v2, v0);
            const normal = new THREE.Vector3().crossVectors(e1, e2);
            
            if (normal.lengthSq() < 0.0001) return null;
            normal.normalize();
            
            const denom = normal.dot(rayDir);
            if (Math.abs(denom) < 0.0001) return null;
            
            const t = new THREE.Vector3().subVectors(v0, rayOrigin).dot(normal) / denom;
            if (t < 0) return null;
            
            const P = rayOrigin.clone().add(rayDir.clone().multiplyScalar(t));
            
            // Point-in-polygon test
            const n = vertices.length;
            for (let i = 0; i < n; i++) {
                const va = vertices[i];
                const vb = vertices[(i + 1) % n];
                const edge = new THREE.Vector3().subVectors(vb, va);
                const toPoint = new THREE.Vector3().subVectors(P, va);
                const cross = new THREE.Vector3().crossVectors(edge, toPoint);
                if (cross.dot(normal) < -0.0001) return null;
            }
            
            return t;
        }
        
        // Shuffle array for fair distribution
        let shapeQueue = [];
        let lastShapeKey = null;
        
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        function getNextShape() {
            // Refill queue if empty
            if (shapeQueue.length === 0) {
                shapeQueue = shuffleArray(Object.keys(shapes));
                // Make sure first of new queue isn't same as last shown
                if (shapeQueue[0] === lastShapeKey && shapeQueue.length > 1) {
                    // Move it to the end
                    shapeQueue.push(shapeQueue.shift());
                }
            }
            lastShapeKey = shapeQueue.shift();
            return lastShapeKey;
        }
        
        function newTask() {
            clearAll();
            hideFeedback();
            const shapeKey = getNextShape();
            currentShape = shapes[shapeKey];
            drawTaskViews();
        }
        
        function createGrid() {
            for (let x = 0; x <= GRID_SIZE; x++) {
                for (let y = 0; y <= GRID_SIZE; y++) {
                    for (let z = 0; z <= GRID_SIZE; z++) {
                        // Visible point as small sphere
                        const pointGeometry = new THREE.SphereGeometry(0.065, 12, 12);
                        const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                        const point = new THREE.Mesh(pointGeometry, pointMaterial);
                        point.position.set(x, y, z);
                        point.userData = { point: { x, y, z }, isRing: true };
                        cubeGroup.add(point);
                        pointMeshes.push(point);
                        
                        // Invisible larger hitbox (bigger on mobile)
                        const hitSize = ('ontouchstart' in window) ? 0.25 : 0.18;
                        const hitGeometry = new THREE.SphereGeometry(hitSize, 8, 8);
                        const hitMaterial = new THREE.MeshBasicMaterial({ 
                            transparent: true, 
                            opacity: 0,
                            depthWrite: false
                        });
                        const hitBox = new THREE.Mesh(hitGeometry, hitMaterial);
                        hitBox.position.set(x, y, z);
                        hitBox.userData = { point: { x, y, z }, ringMesh: point };
                        cubeGroup.add(hitBox);
                        hitBoxes.push(hitBox);
                    }
                }
            }
            
            }
        
        // Mini orientation cube - separate scene and renderer
        let orientationScene, orientationCamera, orientationRenderer, orientationCube;
        
        function createFaceTexture(letter, bgColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Background color
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, 256, 256);
            
            if (letter) {
                // Black outline for better visibility
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 8;
                ctx.font = 'bold 180px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(letter, 128, 128);
                
                // White letter
                ctx.fillStyle = 'white';
                ctx.fillText(letter, 128, 128);
            }
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createOrientationCube() {
            // Create container div - inside canvas area, bottom right
            const canvasEl = document.getElementById('canvas3d');
            const container = document.createElement('div');
            container.id = 'orientationContainer';
            container.style.cssText = 'position: absolute; bottom: 10px; right: 10px; width: 100px; height: 100px; pointer-events: none; z-index: 100;';
            
            // Position relative to canvas
            const wrapper = document.createElement('div');
            wrapper.style.cssText = 'position: relative; display: block; width: fit-content; margin: 0 auto;';
            canvasEl.parentNode.insertBefore(wrapper, canvasEl);
            wrapper.appendChild(canvasEl);
            wrapper.appendChild(container);
            
            // Separate scene
            orientationScene = new THREE.Scene();
            orientationScene.background = null;
            
            // Orthographic camera like main view
            const frustumSize = 1.5;
            orientationCamera = new THREE.OrthographicCamera(
                -frustumSize/2, frustumSize/2,
                frustumSize/2, -frustumSize/2,
                0.1, 100
            );
            
            // Separate renderer
            orientationRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            orientationRenderer.setSize(100, 100);
            orientationRenderer.setClearColor(0x000000, 0);
            container.appendChild(orientationRenderer.domElement);
            
            // Create the cube group
            orientationCube = new THREE.Group();
            
            const s = 0.4; // half-size
            
            // Create faces with textures
            // Front (V) - Blue - at z = +s
            const frontTex = createFaceTexture('V', '#3498db');
            const frontGeom = new THREE.PlaneGeometry(s*2, s*2);
            const frontMat = new THREE.MeshBasicMaterial({ map: frontTex, side: THREE.FrontSide });
            const front = new THREE.Mesh(frontGeom, frontMat);
            front.position.z = s;
            orientationCube.add(front);
            
            // Back - at z = -s
            const backTex = createFaceTexture('', '#85c1e9');
            const backGeom = new THREE.PlaneGeometry(s*2, s*2);
            const backMat = new THREE.MeshBasicMaterial({ map: backTex, side: THREE.FrontSide });
            const back = new THREE.Mesh(backGeom, backMat);
            back.position.z = -s;
            back.rotation.y = Math.PI;
            orientationCube.add(back);
            
            // Right (R) - Green - at x = +s
            const rightTex = createFaceTexture('R', '#27ae60');
            const rightGeom = new THREE.PlaneGeometry(s*2, s*2);
            const rightMat = new THREE.MeshBasicMaterial({ map: rightTex, side: THREE.FrontSide });
            const right = new THREE.Mesh(rightGeom, rightMat);
            right.position.x = s;
            right.rotation.y = Math.PI/2;
            orientationCube.add(right);
            
            // Left - at x = -s
            const leftTex = createFaceTexture('', '#82e0aa');
            const leftGeom = new THREE.PlaneGeometry(s*2, s*2);
            const leftMat = new THREE.MeshBasicMaterial({ map: leftTex, side: THREE.FrontSide });
            const left = new THREE.Mesh(leftGeom, leftMat);
            left.position.x = -s;
            left.rotation.y = -Math.PI/2;
            orientationCube.add(left);
            
            // Top (O) - Orange - at y = +s
            const topTex = createFaceTexture('O', '#e67e22');
            const topGeom = new THREE.PlaneGeometry(s*2, s*2);
            const topMat = new THREE.MeshBasicMaterial({ map: topTex, side: THREE.FrontSide });
            const top = new THREE.Mesh(topGeom, topMat);
            top.position.y = s;
            top.rotation.x = -Math.PI/2;
            orientationCube.add(top);
            
            // Bottom - at y = -s
            const bottomTex = createFaceTexture('', '#f5b041');
            const bottomGeom = new THREE.PlaneGeometry(s*2, s*2);
            const bottomMat = new THREE.MeshBasicMaterial({ map: bottomTex, side: THREE.FrontSide });
            const bottom = new THREE.Mesh(bottomGeom, bottomMat);
            bottom.position.y = -s;
            bottom.rotation.x = Math.PI/2;
            orientationCube.add(bottom);
            
            // Add edges - all visible, no hidden/visible distinction
            const edgePositions = [
                // Bottom face edges
                [[-s, -s, -s], [s, -s, -s]],
                [[s, -s, -s], [s, -s, s]],
                [[s, -s, s], [-s, -s, s]],
                [[-s, -s, s], [-s, -s, -s]],
                // Top face edges
                [[-s, s, -s], [s, s, -s]],
                [[s, s, -s], [s, s, s]],
                [[s, s, s], [-s, s, s]],
                [[-s, s, s], [-s, s, -s]],
                // Vertical edges
                [[-s, -s, -s], [-s, s, -s]],
                [[s, -s, -s], [s, s, -s]],
                [[s, -s, s], [s, s, s]],
                [[-s, -s, s], [-s, s, s]]
            ];
            
            edgePositions.forEach(edge => {
                const start = new THREE.Vector3(edge[0][0], edge[0][1], edge[0][2]);
                const end = new THREE.Vector3(edge[1][0], edge[1][1], edge[1][2]);
                const length = start.distanceTo(end);
                
                const geometry = new THREE.CylinderGeometry(0.015, 0.015, length, 8);
                geometry.translate(0, length / 2, 0);
                geometry.rotateX(Math.PI / 2);
                
                const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const cylinder = new THREE.Mesh(geometry, material);
                cylinder.position.copy(start);
                cylinder.lookAt(end);
                
                orientationCube.add(cylinder);
            });
            
            orientationScene.add(orientationCube);
        }
        
        function createWireframeCube() {
            updateCubeEdges();
        }
        
        function updateCubeEdges() {
            // Remove old cube edges
            cubeEdgeLines.forEach(line => cubeGroup.remove(line));
            cubeEdgeLines = [];
            
            cubeEdgeDefinitions.forEach(edgeDef => {
                const isHidden = isCubeEdgeHidden(edgeDef);
                
                let material;
                if (isHidden) {
                    // Dotted line for hidden edges
                    material = new THREE.LineDashedMaterial({ 
                        color: 0xaaaaaa, 
                        dashSize: 0.03, 
                        gapSize: 0.06
                    });
                } else {
                    // Solid line for visible edges
                    material = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...edgeDef.from), 
                    new THREE.Vector3(...edgeDef.to)
                ]);
                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                cubeGroup.add(line);
                cubeEdgeLines.push(line);
            });
        }
        
        function addEdge(p1, p2) {
            const existingIndex = edges.findIndex(e => 
                (e.p1.x === p1.x && e.p1.y === p1.y && e.p1.z === p1.z &&
                 e.p2.x === p2.x && e.p2.y === p2.y && e.p2.z === p2.z) ||
                (e.p1.x === p2.x && e.p1.y === p2.y && e.p1.z === p2.z &&
                 e.p2.x === p1.x && e.p2.y === p1.y && e.p2.z === p1.z)
            );
            
            if (existingIndex !== -1) {
                // Edge exists - remove it (toggle)
                edges.splice(existingIndex, 1);
            } else {
                // Edge doesn't exist - add it
                edges.push({ p1, p2 });
            }
            
            updateEdgeVisuals();
            document.getElementById('edgeCount').textContent = edges.length;
            hideFeedback();
            clearFaces();
        }
        
        function updateEdgeVisuals() {
            edgeLines.forEach(line => cubeGroup.remove(line));
            edgeLines = [];
            
            edges.forEach(edge => {
                const isHidden = isShapeEdgeHidden(edge.p1, edge.p2);
                
                const start = new THREE.Vector3(edge.p1.x, edge.p1.y, edge.p1.z);
                const end = new THREE.Vector3(edge.p2.x, edge.p2.y, edge.p2.z);
                const direction = new THREE.Vector3().subVectors(end, start);
                const length = direction.length();
                
                if (isHidden) {
                    // Dashed line for hidden edges - create segments
                    const dashLength = 0.08;
                    const gapLength = 0.08;
                    const segmentLength = dashLength + gapLength;
                    const numSegments = Math.ceil(length / segmentLength);
                    
                    for (let i = 0; i < numSegments; i++) {
                        const tStart = (i * segmentLength) / length;
                        const tEnd = Math.min((i * segmentLength + dashLength) / length, 1);
                        
                        if (tStart >= 1) break;
                        
                        const segStart = start.clone().lerp(end, tStart);
                        const segEnd = start.clone().lerp(end, tEnd);
                        const segLength = segStart.distanceTo(segEnd);
                        
                        if (segLength < 0.01) continue;
                        
                        const segGeom = new THREE.CylinderGeometry(0.02, 0.02, segLength, 6);
                        segGeom.translate(0, segLength / 2, 0);
                        segGeom.rotateX(Math.PI / 2);
                        
                        const segMat = new THREE.MeshBasicMaterial({ 
                            color: 0x000000,
                            depthTest: false,
                            depthWrite: false,
                            transparent: true
                        });
                        
                        const segment = new THREE.Mesh(segGeom, segMat);
                        segment.position.copy(segStart);
                        segment.lookAt(segEnd);
                        segment.renderOrder = 1001;
                        
                        cubeGroup.add(segment);
                        edgeLines.push(segment);
                    }
                } else {
                    // Solid line for visible edges
                    const geometry = new THREE.CylinderGeometry(0.03, 0.03, length, 8);
                    geometry.translate(0, length / 2, 0);
                    geometry.rotateX(Math.PI / 2);
                    
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        depthTest: false,
                        depthWrite: false,
                        transparent: true
                    });
                    
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(start);
                    cylinder.lookAt(end);
                    cylinder.renderOrder = 1001;
                    
                    cubeGroup.add(cylinder);
                    edgeLines.push(cylinder);
                }
            });
        }
        
        function updateAllEdges() {
            updateCubeEdges();
            updateEdgeVisuals();
        }
        
        function checkSolution() {
            if (!currentShape) return;
            
            const solutionEdges = currentShape.edges;
            let allCorrect = true;
            
            for (const solEdge of solutionEdges) {
                const p1 = { x: solEdge[0][0], y: solEdge[0][1], z: solEdge[0][2] };
                const p2 = { x: solEdge[1][0], y: solEdge[1][1], z: solEdge[1][2] };
                
                const found = edges.some(e =>
                    (e.p1.x === p1.x && e.p1.y === p1.y && e.p1.z === p1.z &&
                     e.p2.x === p2.x && e.p2.y === p2.y && e.p2.z === p2.z) ||
                    (e.p1.x === p2.x && e.p1.y === p2.y && e.p1.z === p2.z &&
                     e.p2.x === p1.x && e.p2.y === p1.y && e.p2.z === p1.z)
                );
                
                if (!found) {
                    allCorrect = false;
                    break;
                }
            }
            
            const extraEdges = edges.length !== solutionEdges.length;
            const feedback = document.getElementById('feedback');
            
            if (allCorrect && !extraEdges) {
                feedback.textContent = '✓ Richtig! Alle Kanten stimmen.';
                feedback.className = 'feedback correct';
                showFaces();
            } else if (allCorrect && extraEdges) {
                feedback.textContent = '⚠ Fast richtig! Du hast zu viele Kanten.';
                feedback.className = 'feedback incorrect';
            } else {
                feedback.textContent = '✗ Noch nicht richtig. Es fehlen Kanten.';
                feedback.className = 'feedback incorrect';
            }
        }
        
        function showFaces() {
            if (!currentShape || !currentShape.faces) return;
            clearFaces();
            
            currentShape.faces.forEach(face => {
                const vertices = face.map(v => new THREE.Vector3(v[0], v[1], v[2]));
                
                // Calculate face normal for lighting
                const v1 = new THREE.Vector3().subVectors(vertices[1], vertices[0]);
                const v2 = new THREE.Vector3().subVectors(vertices[2], vertices[0]);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                
                // Light direction (from top-right-front)
                const lightDir = new THREE.Vector3(0.3, 0.7, 0.5).normalize();
                let brightness = Math.abs(normal.dot(lightDir));
                brightness = 0.6 + brightness * 0.4; // Range 0.6 to 1.0 (lighter)
                
                // Base color lighter mint green
                const baseColor = { r: 150, g: 220, b: 200 };
                const color = new THREE.Color(
                    (baseColor.r * brightness) / 255,
                    (baseColor.g * brightness) / 255,
                    (baseColor.b * brightness) / 255
                );
                
                let geometry;
                
                if (vertices.length === 3) {
                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[1].x, vertices[1].y, vertices[1].z,
                        vertices[2].x, vertices[2].y, vertices[2].z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                } else if (vertices.length === 4) {
                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[1].x, vertices[1].y, vertices[1].z,
                        vertices[2].x, vertices[2].y, vertices[2].z,
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[2].x, vertices[2].y, vertices[2].z,
                        vertices[3].x, vertices[3].y, vertices[3].z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                }
                
                if (geometry) {
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6,
                        depthWrite: false,
                        depthTest: false
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.renderOrder = -1;
                    cubeGroup.add(mesh);
                    faceMeshes.push(mesh);
                }
            });
            
            // Re-render edges on top of faces
            updateEdgeVisuals();
        }
        
        function clearFaces() {
            faceMeshes.forEach(mesh => cubeGroup.remove(mesh));
            faceMeshes = [];
        }
        
        function hideFeedback() {
            document.getElementById('feedback').className = 'feedback';
        }
        
        function getClickedPoint(event) {
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitBoxes);
            
            if (intersects.length > 0) {
                return intersects[0].object.userData;
            }
            return null;
        }
        
        function onClick(event) {
            if (isRotating) return;
            
            const hit = getClickedPoint(event);
            if (hit) {
                const point = hit.point;
                const ringMesh = hit.ringMesh;
                
                if (selectedPoint === null) {
                    selectedPoint = point;
                    ringMesh.material.color.setHex(0x2563eb);
                    document.getElementById('statusText').textContent = 'Wähle zweiten Punkt';
                } else {
                    if (point.x !== selectedPoint.x || point.y !== selectedPoint.y || point.z !== selectedPoint.z) {
                        addEdge(selectedPoint, point);
                    }
                    pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
                    selectedPoint = null;
                    document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
                }
            }
        }
        
        function onMouseDown(event) {
            const hit = getClickedPoint(event);
            if (!hit) {
                isRotating = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onMouseMove(event) {
            if (isRotating) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                cameraTheta -= deltaX * 0.01;
                cameraPhi += deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                updateCameraPosition();
                updateAllEdges();
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onMouseUp() { isRotating = false; }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                if (raycaster.intersectObjects(hitBoxes).length === 0) {
                    isRotating = true;
                    previousMousePosition = { x: touch.clientX, y: touch.clientY };
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (isRotating && event.touches.length === 1) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;
                
                cameraTheta -= deltaX * 0.01;
                cameraPhi += deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                updateCameraPosition();
                updateAllEdges();
                
                previousMousePosition = { x: touch.clientX, y: touch.clientY };
            }
        }
        
        function onTouchEnd(event) {
            if (isRotating) {
                isRotating = false;
                return;
            }
            
            const touch = event.changedTouches[0];
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitBoxes);
            
            if (intersects.length > 0) {
                const hit = intersects[0].object.userData;
                const point = hit.point;
                const ringMesh = hit.ringMesh;
                
                if (selectedPoint === null) {
                    selectedPoint = point;
                    ringMesh.material.color.setHex(0x2563eb);
                    document.getElementById('statusText').textContent = 'Wähle zweiten Punkt';
                } else {
                    if (point.x !== selectedPoint.x || point.y !== selectedPoint.y || point.z !== selectedPoint.z) {
                        addEdge(selectedPoint, point);
                    }
                    pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
                    selectedPoint = null;
                    document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
                }
            }
        }
        
        function setView(view) {
            const duration = 400;
            const startTheta = cameraTheta;
            const startPhi = cameraPhi;
            let targetTheta, targetPhi;
            
            switch(view) {
                case 'front': targetTheta = 0; targetPhi = Math.PI / 2; break;
                case 'right': targetTheta = Math.PI / 2; targetPhi = Math.PI / 2; break;
                case 'top': targetTheta = 0; targetPhi = 0.001; break;
                case 'iso': 
                default: targetTheta = Math.PI / 5; targetPhi = Math.PI * 0.38; break;
            }
            
            const startTime = Date.now();
            function animateView() {
                const progress = Math.min((Date.now() - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                cameraTheta = startTheta + (targetTheta - startTheta) * eased;
                cameraPhi = startPhi + (targetPhi - startPhi) * eased;
                updateCameraPosition();
                updateAllEdges();
                if (progress < 1) requestAnimationFrame(animateView);
            }
            animateView();
            
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        function clearAll() {
            edges = [];
            updateEdgeVisuals();
            document.getElementById('edgeCount').textContent = 0;
            pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
            selectedPoint = null;
            document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
            hideFeedback();
            clearFaces();
        }
        
        function showSolution() {
            if (!currentShape) return;
            clearAll();
            currentShape.edges.forEach((edge, index) => {
                setTimeout(() => {
                    addEdge(
                        { x: edge[0][0], y: edge[0][1], z: edge[0][2] },
                        { x: edge[1][0], y: edge[1][1], z: edge[1][2] }
                    );
                    if (index === currentShape.edges.length - 1) {
                        setTimeout(showFaces, 100);
                    }
                }, index * 80);
            });
        }
        
        function drawTaskViews() {
            if (!currentShape) return;
            drawView('viewFront', 'front');
            drawView('viewRight', 'right');
            drawView('viewTop', 'top');
        }
        
        function drawView(canvasId, view) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, w, h);
            
            const padding = 15;
            const size = Math.min(w, h) - padding * 2;
            const step = size / 2;
            const ox = padding, oy = padding;
            
            // Grid points as circles
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            for (let i = 0; i <= 2; i++) {
                for (let j = 0; j <= 2; j++) {
                    ctx.beginPath();
                    ctx.arc(ox + i * step, oy + j * step, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Edges
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            
            const projectedEdges = [];
            currentShape.edges.forEach(edge => {
                let p1, p2;
                if (view === 'front') {
                    p1 = { x: edge[0][0], y: 2 - edge[0][1] };
                    p2 = { x: edge[1][0], y: 2 - edge[1][1] };
                } else if (view === 'right') {
                    p1 = { x: 2 - edge[0][2], y: 2 - edge[0][1] };
                    p2 = { x: 2 - edge[1][2], y: 2 - edge[1][1] };
                } else {
                    p1 = { x: edge[0][0], y: edge[0][2] };
                    p2 = { x: edge[1][0], y: edge[1][2] };
                }
                projectedEdges.push({ p1, p2 });
            });
            
            const uniqueEdges = [];
            projectedEdges.forEach(edge => {
                if (Math.abs(edge.p1.x - edge.p2.x) < 0.01 && Math.abs(edge.p1.y - edge.p2.y) < 0.01) return;
                const isDuplicate = uniqueEdges.some(e => 
                    (Math.abs(e.p1.x - edge.p1.x) < 0.01 && Math.abs(e.p1.y - edge.p1.y) < 0.01 &&
                     Math.abs(e.p2.x - edge.p2.x) < 0.01 && Math.abs(e.p2.y - edge.p2.y) < 0.01) ||
                    (Math.abs(e.p1.x - edge.p2.x) < 0.01 && Math.abs(e.p1.y - edge.p2.y) < 0.01 &&
                     Math.abs(e.p2.x - edge.p1.x) < 0.01 && Math.abs(e.p2.y - edge.p1.y) < 0.01)
                );
                if (!isDuplicate) uniqueEdges.push(edge);
            });
            
            uniqueEdges.forEach(edge => {
                ctx.beginPath();
                ctx.moveTo(ox + edge.p1.x * step, oy + edge.p1.y * step);
                ctx.lineTo(ox + edge.p2.x * step, oy + edge.p2.y * step);
                ctx.stroke();
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Render orientation cube
            if (orientationRenderer && orientationScene && orientationCamera) {
                orientationRenderer.render(orientationScene, orientationCamera);
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('DOMContentLoaded', init);
        
        // Handle resize for responsive canvas
        function handleResize() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;
            const width = Math.min(600, container.clientWidth);
            const height = window.innerWidth <= 480 ? 300 : 450;
            
            canvas.width = width;
            canvas.height = height;
            
            if (renderer && camera) {
                renderer.setSize(width, height);
                const aspect = width / height;
                const frustumSize = 5;
                camera.left = -frustumSize * aspect / 2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = -frustumSize / 2;
                camera.updateProjectionMatrix();
            }
            
            // Resize task views
            const taskCanvases = ['viewFront', 'viewRight', 'viewTop'];
            const taskSize = window.innerWidth <= 360 ? 75 : (window.innerWidth <= 480 ? 90 : 120);
            taskCanvases.forEach(id => {
                const c = document.getElementById(id);
                c.width = taskSize;
                c.height = taskSize;
            });
            
            if (currentShape) drawTaskViews();
        }
        
        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>
