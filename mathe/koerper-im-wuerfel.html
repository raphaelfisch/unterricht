<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Körper im Würfel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #fff;
            color: #000;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        h1 { font-size: 1.2rem; font-weight: 500; margin-bottom: 20px; text-align: center; }
        
        .task-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 16px;
        }
        .view-box { text-align: center; }
        .view-box label { display: block; font-size: 0.85rem; color: #666; margin-bottom: 6px; }
        .view-box canvas { border: 1px solid #ccc; background: #fff; }
        
        .new-task-btn {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 0 auto 16px;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 0.95rem;
            background: #2563eb;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .new-task-btn:hover { background: #1d4ed8; }
        
        .workspace { width: 100%; }
        #canvas3d { 
            border: 1px solid #ccc; 
            cursor: grab; 
            display: block; 
            background: #fff;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }
        #canvas3d:active { cursor: grabbing; }
        
        .controls { 
            margin-top: 12px; 
            display: flex; 
            gap: 8px; 
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            font-family: inherit; font-size: 0.85rem; padding: 6px 14px;
            border: 1px solid #ccc; background: #fff; cursor: pointer; border-radius: 3px;
        }
        button:hover { background: #f5f5f5; }
        button.active { background: #000; color: #fff; border-color: #000; }
        button.success { background: #16a34a; color: #fff; border-color: #16a34a; }
        button.success:hover { background: #15803d; }
        
        .status { 
            margin-top: 12px; 
            font-size: 0.85rem; 
            color: #666; 
            text-align: center;
        }
        .divider { width: 1px; background: #ddd; margin: 0 4px; }
        .feedback { 
            margin-top: 8px; 
            padding: 8px 12px; 
            border-radius: 4px; 
            font-size: 0.85rem; 
            display: none;
            text-align: center;
        }
        .feedback.correct { display: block; background: #dcfce7; color: #166534; border: 1px solid #86efac; }
        .feedback.incorrect { display: block; background: #fef2f2; color: #991b1b; border: 1px solid #fca5a5; }
        
        /* Mobile responsive */
        @media (max-width: 480px) {
            body { padding: 10px; }
            h1 { font-size: 1rem; margin-bottom: 12px; }
            
            .task-section {
                gap: 8px;
                margin-bottom: 10px;
            }
            .view-box label { font-size: 0.7rem; margin-bottom: 3px; }
            .view-box canvas { 
                width: 90px !important; 
                height: 90px !important; 
            }
            
            .new-task-btn {
                padding: 8px 16px;
                font-size: 0.85rem;
                margin-bottom: 10px;
            }
            
            #canvas3d {
                height: 300px !important;
            }
            
            .controls {
                gap: 5px;
                margin-top: 8px;
            }
            button {
                font-size: 0.75rem;
                padding: 5px 8px;
            }
            
            .status {
                font-size: 0.75rem;
                margin-top: 8px;
            }
            .feedback {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
        }
        
        /* Very small screens */
        @media (max-width: 360px) {
            .view-box canvas { 
                width: 75px !important; 
                height: 75px !important; 
            }
            button {
                font-size: 0.7rem;
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <h1>Körper im Würfel</h1>
    
    <div class="task-section">
        <div class="view-box">
            <label>von vorne</label>
            <canvas id="viewFront" width="120" height="120"></canvas>
        </div>
        <div class="view-box">
            <label>von rechts</label>
            <canvas id="viewRight" width="120" height="120"></canvas>
        </div>
        <div class="view-box">
            <label>von oben</label>
            <canvas id="viewTop" width="120" height="120"></canvas>
        </div>
    </div>
    
    <button class="new-task-btn" onclick="newTask()">Neue Aufgabe</button>
    
    <div class="workspace">
        <canvas id="canvas3d" width="600" height="450"></canvas>
        <div class="controls">
            <button onclick="setView('front')">von vorne</button>
            <button onclick="setView('right')">von rechts</button>
            <button onclick="setView('top')">von oben</button>
            <button onclick="setView('iso')" class="active" id="btnIso">Schrägbild</button>
        </div>
        <div class="controls">
            <button onclick="undoLastEdge()">Rückgängig</button>
            <button onclick="clearAll()">Löschen</button>
            <button class="success" onclick="checkSolution()">✓ Prüfen</button>
            <button onclick="showSolution()">Lösung</button>
        </div>
        <div class="status">
            <span id="statusText">Klicke zwei Punkte um eine Kante zu zeichnen</span>
            · <span id="edgeCount">0</span> Kanten
        </div>
        <div class="feedback" id="feedback"></div>
    </div>

    <script>
        let scene, camera, renderer;
        let edges = [];
        let selectedPoint = null;
        let pointMeshes = [];
        let hitBoxes = [];
        let edgeLines = [];
        let cubeEdgeLines = [];
        let faceMeshes = [];
        let raycaster, mouse;
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cubeGroup;
        let currentShape = null;
        
        // Camera orbit - Standard isometric like reference image
        // Looking from front-right-top towards center
        let cameraTheta = Math.PI / 5;    // slightly less than 45° horizontal
        let cameraPhi = Math.PI * 0.38;   // about 68° from top (more frontal view)
        const center = new THREE.Vector3(1, 1, 1);
        const cameraDistance = 4;
        
        const GRID_SIZE = 2;
        
        // Cube edge definitions with face information
        const cubeEdgeDefinitions = [
            // Bottom face edges (y=0)
            { from: [0,0,0], to: [2,0,0], faces: ['y0', 'z0'] },
            { from: [2,0,0], to: [2,0,2], faces: ['y0', 'x2'] },
            { from: [2,0,2], to: [0,0,2], faces: ['y0', 'z2'] },
            { from: [0,0,2], to: [0,0,0], faces: ['y0', 'x0'] },
            // Top face edges (y=2)
            { from: [0,2,0], to: [2,2,0], faces: ['y2', 'z0'] },
            { from: [2,2,0], to: [2,2,2], faces: ['y2', 'x2'] },
            { from: [2,2,2], to: [0,2,2], faces: ['y2', 'z2'] },
            { from: [0,2,2], to: [0,2,0], faces: ['y2', 'x0'] },
            // Vertical edges
            { from: [0,0,0], to: [0,2,0], faces: ['x0', 'z0'] },
            { from: [2,0,0], to: [2,2,0], faces: ['x2', 'z0'] },
            { from: [2,0,2], to: [2,2,2], faces: ['x2', 'z2'] },
            { from: [0,0,2], to: [0,2,2], faces: ['x0', 'z2'] }
        ];
        
        const shapes = {
            // ==================== WÜRFEL ====================
            wuerfel_gross: {
                name: "Würfel 2×2×2",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[0,2,2]], [[0,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[2,0,2],[2,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,0,2], [2,0,2], [2,2,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]], [[0,2,0], [2,2,0], [2,2,2], [0,2,2]]
                ]
            },
            wuerfel_klein_000: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,1,0],[1,1,0]], [[1,1,0],[1,1,1]], [[1,1,1],[0,1,1]], [[0,1,1],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[1,1,0]], [[1,0,1],[1,1,1]], [[0,0,1],[0,1,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,0,1], [1,0,1], [1,1,1], [0,1,1]],
                    [[0,0,0], [0,0,1], [0,1,1], [0,1,0]], [[1,0,0], [1,0,1], [1,1,1], [1,1,0]],
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]], [[0,1,0], [1,1,0], [1,1,1], [0,1,1]]
                ]
            },
            wuerfel_klein_100: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[1,0,1]], [[1,0,1],[1,0,0]],
                    [[1,1,0],[2,1,0]], [[2,1,0],[2,1,1]], [[2,1,1],[1,1,1]], [[1,1,1],[1,1,0]],
                    [[1,0,0],[1,1,0]], [[2,0,0],[2,1,0]], [[2,0,1],[2,1,1]], [[1,0,1],[1,1,1]]
                ],
                faces: [
                    [[1,0,0], [2,0,0], [2,1,0], [1,1,0]], [[1,0,1], [2,0,1], [2,1,1], [1,1,1]],
                    [[1,0,0], [1,0,1], [1,1,1], [1,1,0]], [[2,0,0], [2,0,1], [2,1,1], [2,1,0]],
                    [[1,0,0], [2,0,0], [2,0,1], [1,0,1]], [[1,1,0], [2,1,0], [2,1,1], [1,1,1]]
                ]
            },
            wuerfel_klein_111: {
                name: "Würfel 1×1×1",
                edges: [
                    [[1,1,1],[2,1,1]], [[2,1,1],[2,1,2]], [[2,1,2],[1,1,2]], [[1,1,2],[1,1,1]],
                    [[1,2,1],[2,2,1]], [[2,2,1],[2,2,2]], [[2,2,2],[1,2,2]], [[1,2,2],[1,2,1]],
                    [[1,1,1],[1,2,1]], [[2,1,1],[2,2,1]], [[2,1,2],[2,2,2]], [[1,1,2],[1,2,2]]
                ],
                faces: [
                    [[1,1,1], [2,1,1], [2,2,1], [1,2,1]], [[1,1,2], [2,1,2], [2,2,2], [1,2,2]],
                    [[1,1,1], [1,1,2], [1,2,2], [1,2,1]], [[2,1,1], [2,1,2], [2,2,2], [2,2,1]],
                    [[1,1,1], [2,1,1], [2,1,2], [1,1,2]], [[1,2,1], [2,2,1], [2,2,2], [1,2,2]]
                ]
            },
            wuerfel_klein_011: {
                name: "Würfel 1×1×1",
                edges: [
                    [[0,1,1],[1,1,1]], [[1,1,1],[1,1,2]], [[1,1,2],[0,1,2]], [[0,1,2],[0,1,1]],
                    [[0,2,1],[1,2,1]], [[1,2,1],[1,2,2]], [[1,2,2],[0,2,2]], [[0,2,2],[0,2,1]],
                    [[0,1,1],[0,2,1]], [[1,1,1],[1,2,1]], [[1,1,2],[1,2,2]], [[0,1,2],[0,2,2]]
                ],
                faces: [
                    [[0,1,1], [1,1,1], [1,2,1], [0,2,1]], [[0,1,2], [1,1,2], [1,2,2], [0,2,2]],
                    [[0,1,1], [0,1,2], [0,2,2], [0,2,1]], [[1,1,1], [1,1,2], [1,2,2], [1,2,1]],
                    [[0,1,1], [1,1,1], [1,1,2], [0,1,2]], [[0,2,1], [1,2,1], [1,2,2], [0,2,2]]
                ]
            },
            
            // ==================== QUADER ====================
            quader_2x2x1: {
                name: "Quader 2×2×1",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[0,1,2]], [[0,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,2],[2,1,2]], [[0,0,2],[0,1,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,1,0], [0,1,0]], [[0,0,2], [2,0,2], [2,1,2], [0,1,2]],
                    [[0,0,0], [0,0,2], [0,1,2], [0,1,0]], [[2,0,0], [2,0,2], [2,1,2], [2,1,0]],
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]], [[0,1,0], [2,1,0], [2,1,2], [0,1,2]]
                ]
            },
            quader_2x1x2: {
                name: "Quader 2×1×2",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[2,2,1]], [[2,2,1],[0,2,1]], [[0,2,1],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[2,0,1],[2,2,1]], [[0,0,1],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,0,1], [2,0,1], [2,2,1], [0,2,1]],
                    [[0,0,0], [0,0,1], [0,2,1], [0,2,0]], [[2,0,0], [2,0,1], [2,2,1], [2,2,0]],
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]], [[0,2,0], [2,2,0], [2,2,1], [0,2,1]]
                ]
            },
            quader_1x2x2: {
                name: "Quader 1×2×2",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,2,0],[1,2,0]], [[1,2,0],[1,2,2]], [[1,2,2],[0,2,2]], [[0,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[1,2,0]], [[1,0,2],[1,2,2]], [[0,0,2],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,2,0], [0,2,0]], [[0,0,2], [1,0,2], [1,2,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[1,0,0], [1,0,2], [1,2,2], [1,2,0]],
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]], [[0,2,0], [1,2,0], [1,2,2], [0,2,2]]
                ]
            },
            quader_2x1x1: {
                name: "Quader 2×1×1",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,1]], [[2,1,1],[0,1,1]], [[0,1,1],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,1],[2,1,1]], [[0,0,1],[0,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,1,0], [0,1,0]], [[0,0,1], [2,0,1], [2,1,1], [0,1,1]],
                    [[0,0,0], [0,0,1], [0,1,1], [0,1,0]], [[2,0,0], [2,0,1], [2,1,1], [2,1,0]],
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]], [[0,1,0], [2,1,0], [2,1,1], [0,1,1]]
                ]
            },
            quader_1x2x1: {
                name: "Quader 1×2×1",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,2,0],[1,2,0]], [[1,2,0],[1,2,1]], [[1,2,1],[0,2,1]], [[0,2,1],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[1,2,0]], [[1,0,1],[1,2,1]], [[0,0,1],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,2,0], [0,2,0]], [[0,0,1], [1,0,1], [1,2,1], [0,2,1]],
                    [[0,0,0], [0,0,1], [0,2,1], [0,2,0]], [[1,0,0], [1,0,1], [1,2,1], [1,2,0]],
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]], [[0,2,0], [1,2,0], [1,2,1], [0,2,1]]
                ]
            },
            quader_1x1x2: {
                name: "Quader 1×1×2",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,0],[1,1,0]], [[1,1,0],[1,1,2]], [[1,1,2],[0,1,2]], [[0,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[1,1,0]], [[1,0,2],[1,1,2]], [[0,0,2],[0,1,2]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,0,2], [1,0,2], [1,1,2], [0,1,2]],
                    [[0,0,0], [0,0,2], [0,1,2], [0,1,0]], [[1,0,0], [1,0,2], [1,1,2], [1,1,0]],
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]], [[0,1,0], [1,1,0], [1,1,2], [0,1,2]]
                ]
            },
            quader_1x1x2_oben: {
                name: "Quader 1×1×2",
                edges: [
                    [[1,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[1,1,2]], [[1,1,2],[1,1,0]],
                    [[1,2,0],[2,2,0]], [[2,2,0],[2,2,2]], [[2,2,2],[1,2,2]], [[1,2,2],[1,2,0]],
                    [[1,1,0],[1,2,0]], [[2,1,0],[2,2,0]], [[2,1,2],[2,2,2]], [[1,1,2],[1,2,2]]
                ],
                faces: [
                    [[1,1,0], [2,1,0], [2,2,0], [1,2,0]], [[1,1,2], [2,1,2], [2,2,2], [1,2,2]],
                    [[1,1,0], [1,1,2], [1,2,2], [1,2,0]], [[2,1,0], [2,1,2], [2,2,2], [2,2,0]],
                    [[1,1,0], [2,1,0], [2,1,2], [1,1,2]], [[1,2,0], [2,2,0], [2,2,2], [1,2,2]]
                ]
            },
            
            // ==================== DREIECKSPRISMEN ====================
            prisma_dreieck_RW_stehend: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[2,0,0],[2,2,0]], [[2,2,0],[2,0,2]], [[2,0,2],[2,0,0]],
                    [[0,0,0],[2,0,0]], [[0,2,0],[2,2,0]], [[0,0,2],[2,0,2]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [0,0,2]], [[2,0,0], [2,2,0], [2,0,2]],
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]], [[0,2,0], [2,2,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]]
                ]
            },
            prisma_dreieck_GS_stehend: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[1,0,2]], [[1,0,2],[0,0,0]],
                    [[0,2,0],[2,2,0]], [[2,2,0],[1,2,2]], [[1,2,2],[0,2,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]], [[1,0,2],[1,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [1,0,2]], [[0,2,0], [2,2,0], [1,2,2]],
                    [[0,0,0], [0,2,0], [2,2,0], [2,0,0]], [[2,0,0], [2,2,0], [1,2,2], [1,0,2]],
                    [[0,0,0], [1,0,2], [1,2,2], [0,2,0]]
                ]
            },
            prisma_dreieck_liegend_z: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0]], [[0,0,2], [2,0,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            prisma_dreieck_liegend_y: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,0]],
                    [[0,1,0],[2,1,0]], [[2,1,0],[2,1,2]], [[2,1,2],[0,1,0]],
                    [[0,0,0],[0,1,0]], [[2,0,0],[2,1,0]], [[2,0,2],[2,1,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2]], [[0,1,0], [2,1,0], [2,1,2]],
                    [[0,0,0], [0,1,0], [2,1,0], [2,0,0]], [[2,0,0], [2,1,0], [2,1,2], [2,0,2]],
                    [[0,0,0], [2,0,2], [2,1,2], [0,1,0]]
                ]
            },
            prisma_dreieck_klein: {
                name: "Dreiecksprisma",
                edges: [
                    [[0,0,0],[0,1,0]], [[0,1,0],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[1,0,0],[1,1,0]], [[1,1,0],[1,0,1]], [[1,0,1],[1,0,0]],
                    [[0,0,0],[1,0,0]], [[0,1,0],[1,1,0]], [[0,0,1],[1,0,1]]
                ],
                faces: [
                    [[0,0,0], [0,1,0], [0,0,1]], [[1,0,0], [1,1,0], [1,0,1]],
                    [[0,0,0], [1,0,0], [1,1,0], [0,1,0]], [[0,1,0], [1,1,0], [1,0,1], [0,0,1]],
                    [[0,0,0], [0,0,1], [1,0,1], [1,0,0]]
                ]
            },
            // Diagonales Prisma (wie auf dem Bild)
            prisma_diagonal: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[0,2,0]], [[0,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[0,2,2]], [[0,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[0,2,0],[0,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [0,2,0]], [[0,0,2], [2,0,2], [0,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [0,2,2], [0,2,0]],
                    [[0,0,0], [0,2,0], [0,2,2], [0,0,2]]
                ]
            },
            prisma_diagonal_2: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0]], [[0,0,2], [2,0,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]], [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            prisma_diagonal_3: {
                name: "Dreiecksprisma (diagonal)",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[2,2,0]], [[2,2,0],[0,0,0]],
                    [[0,0,2],[0,2,2]], [[0,2,2],[2,2,2]], [[2,2,2],[0,0,2]],
                    [[0,0,0],[0,0,2]], [[0,2,0],[0,2,2]], [[2,2,0],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [2,2,0]], [[0,0,2], [0,2,2], [2,2,2]],
                    [[0,0,0], [0,0,2], [0,2,2], [0,2,0]], [[0,2,0], [0,2,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            },
            
            // ==================== PYRAMIDEN (gross 2×2 Basis) ====================
            pyramide_quadrat_hoch: {
                name: "Pyramide",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,2,1]], [[2,0,0],[1,2,1]], [[2,0,2],[1,2,1]], [[0,0,2],[1,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,2,1]], [[2,0,0], [2,0,2], [1,2,1]],
                    [[2,0,2], [0,0,2], [1,2,1]], [[0,0,2], [0,0,0], [1,2,1]]
                ]
            },
            pyramide_quadrat_flach: {
                name: "Pyramide (flach)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,1,1]], [[2,0,0],[1,1,1]], [[2,0,2],[1,1,1]], [[0,0,2],[1,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,1,1]], [[2,0,0], [2,0,2], [1,1,1]],
                    [[2,0,2], [0,0,2], [1,1,1]], [[0,0,2], [0,0,0], [1,1,1]]
                ]
            },
            pyramide_seitlich: {
                name: "Pyramide (seitlich)",
                edges: [
                    [[0,0,0],[0,2,0]], [[0,2,0],[0,2,2]], [[0,2,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,1,1]], [[0,2,0],[2,1,1]], [[0,2,2],[2,1,1]], [[0,0,2],[2,1,1]]
                ],
                faces: [
                    [[0,0,0], [0,2,0], [0,2,2], [0,0,2]],
                    [[0,0,0], [0,2,0], [2,1,1]], [[0,2,0], [0,2,2], [2,1,1]],
                    [[0,2,2], [0,0,2], [2,1,1]], [[0,0,2], [0,0,0], [2,1,1]]
                ]
            },
            pyramide_ecke: {
                name: "Pyramide (Spitze an Ecke)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[2,2,2]], [[2,0,0],[2,2,2]], [[2,0,2],[2,2,2]], [[0,0,2],[2,2,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,2,2]], [[2,0,0], [2,0,2], [2,2,2]],
                    [[2,0,2], [0,0,2], [2,2,2]], [[0,0,2], [0,0,0], [2,2,2]]
                ]
            },
            
            // ==================== PYRAMIDEN (klein 1×1 Basis) ====================
            pyramide_klein_hoch: {
                name: "Pyramide (klein, hoch)",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,1]], [[1,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[1,0,0],[0,2,0]], [[1,0,1],[0,2,0]], [[0,0,1],[0,2,0]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,0,1], [0,0,1]],
                    [[0,0,0], [1,0,0], [0,2,0]], [[1,0,0], [1,0,1], [0,2,0]],
                    [[1,0,1], [0,0,1], [0,2,0]], [[0,0,1], [0,0,0], [0,2,0]]
                ]
            },
            pyramide_klein_mitte: {
                name: "Pyramide (klein)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[1,1,1]], [[2,0,0],[1,1,1]], [[2,0,2],[1,1,1]], [[0,0,2],[1,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [1,1,1]], [[2,0,0], [2,0,2], [1,1,1]],
                    [[2,0,2], [0,0,2], [1,1,1]], [[0,0,2], [0,0,0], [1,1,1]]
                ]
            },
            
            // ==================== TETRAEDER ====================
            tetraeder_gross: {
                name: "Tetraeder",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[1,0,2]], [[1,0,2],[0,0,0]],
                    [[0,0,0],[1,2,1]], [[2,0,0],[1,2,1]], [[1,0,2],[1,2,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [1,0,2]],
                    [[0,0,0], [2,0,0], [1,2,1]], [[2,0,0], [1,0,2], [1,2,1]], [[1,0,2], [0,0,0], [1,2,1]]
                ]
            },
            tetraeder_RW: {
                name: "Tetraeder (rechtwinklig)",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[0,2,0]], [[0,0,2],[0,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [0,0,2]],
                    [[0,0,0], [2,0,0], [0,2,0]], [[2,0,0], [0,0,2], [0,2,0]], [[0,0,2], [0,0,0], [0,2,0]]
                ]
            },
            tetraeder_klein: {
                name: "Tetraeder (klein)",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[0,1,0]], [[1,0,0],[0,1,0]], [[0,0,1],[0,1,0]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [0,0,1]],
                    [[0,0,0], [1,0,0], [0,1,0]], [[1,0,0], [0,0,1], [0,1,0]], [[0,0,1], [0,0,0], [0,1,0]]
                ]
            },
            
            // ==================== RECHTECKIGE PYRAMIDEN ====================
            pyramide_rechteck_1: {
                name: "Rechteckige Pyramide",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,1]], [[2,0,1],[0,0,1]], [[0,0,1],[0,0,0]],
                    [[0,0,0],[1,2,0]], [[2,0,0],[1,2,0]], [[2,0,1],[1,2,0]], [[0,0,1],[1,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,1], [0,0,1]],
                    [[0,0,0], [2,0,0], [1,2,0]], [[2,0,0], [2,0,1], [1,2,0]],
                    [[2,0,1], [0,0,1], [1,2,0]], [[0,0,1], [0,0,0], [1,2,0]]
                ]
            },
            pyramide_rechteck_2: {
                name: "Rechteckige Pyramide",
                edges: [
                    [[0,0,0],[1,0,0]], [[1,0,0],[1,0,2]], [[1,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,1]], [[1,0,0],[0,2,1]], [[1,0,2],[0,2,1]], [[0,0,2],[0,2,1]]
                ],
                faces: [
                    [[0,0,0], [1,0,0], [1,0,2], [0,0,2]],
                    [[0,0,0], [1,0,0], [0,2,1]], [[1,0,0], [1,0,2], [0,2,1]],
                    [[1,0,2], [0,0,2], [0,2,1]], [[0,0,2], [0,0,0], [0,2,1]]
                ]
            },
            
            // ==================== SPEZIALFORMEN ====================
            dach: {
                name: "Dachform",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,1,1],[2,1,1]],
                    [[0,0,0],[0,1,1]], [[0,0,2],[0,1,1]], [[2,0,0],[2,1,1]], [[2,0,2],[2,1,1]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,1,1], [0,1,1]], 
                    [[0,0,2], [2,0,2], [2,1,1], [0,1,1]],
                    [[0,0,0], [0,0,2], [0,1,1]], [[2,0,0], [2,0,2], [2,1,1]]
                ]
            },
            keil: {
                name: "Keil",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,0,2]], [[2,0,2],[0,0,2]], [[0,0,2],[0,0,0]],
                    [[0,0,0],[0,2,0]], [[2,0,0],[2,2,0]],
                    [[0,2,0],[2,2,0]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,0,2], [0,0,2]],
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]],
                    [[0,0,0], [0,0,2], [0,2,0]], [[2,0,0], [2,0,2], [2,2,0]],
                    [[0,0,2], [2,0,2], [2,2,0], [0,2,0]]
                ]
            },
            halber_wuerfel: {
                name: "Halber Würfel",
                edges: [
                    [[0,0,0],[2,0,0]], [[2,0,0],[2,2,0]], [[2,2,0],[0,2,0]], [[0,2,0],[0,0,0]],
                    [[0,0,2],[2,0,2]], [[2,0,2],[2,2,2]],
                    [[0,0,0],[0,0,2]], [[2,0,0],[2,0,2]], [[2,2,0],[2,2,2]], [[0,2,0],[0,0,2]]
                ],
                faces: [
                    [[0,0,0], [2,0,0], [2,2,0], [0,2,0]],
                    [[0,0,0], [0,0,2], [2,0,2], [2,0,0]],
                    [[2,0,0], [2,0,2], [2,2,2], [2,2,0]],
                    [[0,0,0], [0,2,0], [0,0,2]],
                    [[0,2,0], [2,2,0], [2,2,2], [0,0,2]]
                ]
            }
        };
        
        function init() {
            const canvas = document.getElementById('canvas3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            const aspect = canvas.width / canvas.height;
            const frustumSize = 5;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 1000
            );
            updateCameraPosition();
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            createGrid();
            createWireframeCube();
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            canvas.addEventListener('click', onClick);
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd);
            
            newTask();
            handleResize();
            animate();
        }
        
        function updateCameraPosition() {
            const x = center.x + cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            const y = center.y + cameraDistance * Math.cos(cameraPhi);
            const z = center.z + cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.set(x, y, z);
            camera.lookAt(center);
            camera.updateProjectionMatrix();
        }
        
        // Determine which faces of the cube are hidden from current camera view
        function getHiddenFaces() {
            const camPos = camera.position;
            const hidden = [];
            
            // Face x=0 hidden if camera is on positive x side
            if (camPos.x > center.x) hidden.push('x0');
            else hidden.push('x2');
            
            // Face y=0 hidden if camera is above center
            if (camPos.y > center.y) hidden.push('y0');
            else hidden.push('y2');
            
            // Face z=0 hidden if camera is on positive z side
            if (camPos.z > center.z) hidden.push('z0');
            else hidden.push('z2');
            
            return hidden;
        }
        
        // Check if a cube edge is hidden (on two hidden faces)
        function isCubeEdgeHidden(edgeDef) {
            const hiddenFaces = getHiddenFaces();
            let hiddenCount = 0;
            for (const face of edgeDef.faces) {
                if (hiddenFaces.includes(face)) hiddenCount++;
            }
            return hiddenCount >= 2;
        }
        
        // Check if a shape edge is hidden
        function isShapeEdgeHidden(p1, p2) {
            const hiddenFaces = getHiddenFaces();
            let hiddenCount = 0;
            
            // Check which cube faces this edge lies on
            // Edge on x=0 face
            if (p1.x === 0 && p2.x === 0 && hiddenFaces.includes('x0')) hiddenCount++;
            // Edge on x=2 face
            if (p1.x === 2 && p2.x === 2 && hiddenFaces.includes('x2')) hiddenCount++;
            // Edge on y=0 face
            if (p1.y === 0 && p2.y === 0 && hiddenFaces.includes('y0')) hiddenCount++;
            // Edge on y=2 face
            if (p1.y === 2 && p2.y === 2 && hiddenFaces.includes('y2')) hiddenCount++;
            // Edge on z=0 face
            if (p1.z === 0 && p2.z === 0 && hiddenFaces.includes('z0')) hiddenCount++;
            // Edge on z=2 face
            if (p1.z === 2 && p2.z === 2 && hiddenFaces.includes('z2')) hiddenCount++;
            
            return hiddenCount >= 2;
        }
        
        function newTask() {
            clearAll();
            hideFeedback();
            const shapeKeys = Object.keys(shapes);
            const randomKey = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];
            currentShape = shapes[randomKey];
            drawTaskViews();
        }
        
        function createGrid() {
            for (let x = 0; x <= GRID_SIZE; x++) {
                for (let y = 0; y <= GRID_SIZE; y++) {
                    for (let z = 0; z <= GRID_SIZE; z++) {
                        // Visible ring
                        const ringGeometry = new THREE.TorusGeometry(0.06, 0.015, 8, 16);
                        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.position.set(x, y, z);
                        ring.userData = { point: { x, y, z }, isRing: true };
                        cubeGroup.add(ring);
                        pointMeshes.push(ring);
                        
                        // Invisible larger hitbox (bigger on mobile)
                        const hitSize = ('ontouchstart' in window) ? 0.25 : 0.18;
                        const hitGeometry = new THREE.SphereGeometry(hitSize, 8, 8);
                        const hitMaterial = new THREE.MeshBasicMaterial({ 
                            transparent: true, 
                            opacity: 0,
                            depthWrite: false
                        });
                        const hitBox = new THREE.Mesh(hitGeometry, hitMaterial);
                        hitBox.position.set(x, y, z);
                        hitBox.userData = { point: { x, y, z }, ringMesh: ring };
                        cubeGroup.add(hitBox);
                        hitBoxes.push(hitBox);
                    }
                }
            }
        }
        
        function createWireframeCube() {
            updateCubeEdges();
        }
        
        function updateCubeEdges() {
            // Remove old cube edges
            cubeEdgeLines.forEach(line => cubeGroup.remove(line));
            cubeEdgeLines = [];
            
            cubeEdgeDefinitions.forEach(edgeDef => {
                const isHidden = isCubeEdgeHidden(edgeDef);
                
                let material;
                if (isHidden) {
                    // Dotted line for hidden edges
                    material = new THREE.LineDashedMaterial({ 
                        color: 0xaaaaaa, 
                        dashSize: 0.03, 
                        gapSize: 0.06
                    });
                } else {
                    // Solid line for visible edges
                    material = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(...edgeDef.from), 
                    new THREE.Vector3(...edgeDef.to)
                ]);
                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                cubeGroup.add(line);
                cubeEdgeLines.push(line);
            });
        }
        
        function addEdge(p1, p2) {
            const exists = edges.some(e => 
                (e.p1.x === p1.x && e.p1.y === p1.y && e.p1.z === p1.z &&
                 e.p2.x === p2.x && e.p2.y === p2.y && e.p2.z === p2.z) ||
                (e.p1.x === p2.x && e.p1.y === p2.y && e.p1.z === p2.z &&
                 e.p2.x === p1.x && e.p2.y === p1.y && e.p2.z === p1.z)
            );
            if (exists) return;
            edges.push({ p1, p2 });
            updateEdgeVisuals();
            document.getElementById('edgeCount').textContent = edges.length;
            hideFeedback();
            clearFaces();
        }
        
        function updateEdgeVisuals() {
            edgeLines.forEach(line => cubeGroup.remove(line));
            edgeLines = [];
            
            const hasColoredFaces = faceMeshes.length > 0;
            
            edges.forEach(edge => {
                const isHidden = isShapeEdgeHidden(edge.p1, edge.p2);
                
                let material;
                if (isHidden) {
                    material = new THREE.LineDashedMaterial({ 
                        color: 0x000000, 
                        dashSize: 0.03, 
                        gapSize: 0.06,
                        depthTest: false,
                        depthWrite: false,
                        transparent: true
                    });
                } else {
                    material = new THREE.LineBasicMaterial({ 
                        color: 0x000000,
                        depthTest: false,
                        depthWrite: false,
                        transparent: true
                    });
                }
                
                const points = [
                    new THREE.Vector3(edge.p1.x, edge.p1.y, edge.p1.z),
                    new THREE.Vector3(edge.p2.x, edge.p2.y, edge.p2.z)
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                line.renderOrder = 999;
                
                cubeGroup.add(line);
                edgeLines.push(line);
            });
        }
        
        function updateAllEdges() {
            updateCubeEdges();
            updateEdgeVisuals();
        }
        
        function checkSolution() {
            if (!currentShape) return;
            
            const solutionEdges = currentShape.edges;
            let allCorrect = true;
            
            for (const solEdge of solutionEdges) {
                const p1 = { x: solEdge[0][0], y: solEdge[0][1], z: solEdge[0][2] };
                const p2 = { x: solEdge[1][0], y: solEdge[1][1], z: solEdge[1][2] };
                
                const found = edges.some(e =>
                    (e.p1.x === p1.x && e.p1.y === p1.y && e.p1.z === p1.z &&
                     e.p2.x === p2.x && e.p2.y === p2.y && e.p2.z === p2.z) ||
                    (e.p1.x === p2.x && e.p1.y === p2.y && e.p1.z === p2.z &&
                     e.p2.x === p1.x && e.p2.y === p1.y && e.p2.z === p1.z)
                );
                
                if (!found) {
                    allCorrect = false;
                    break;
                }
            }
            
            const extraEdges = edges.length !== solutionEdges.length;
            const feedback = document.getElementById('feedback');
            
            if (allCorrect && !extraEdges) {
                feedback.textContent = '✓ Richtig! Alle Kanten stimmen.';
                feedback.className = 'feedback correct';
                showFaces();
            } else if (allCorrect && extraEdges) {
                feedback.textContent = '⚠ Fast richtig! Du hast zu viele Kanten.';
                feedback.className = 'feedback incorrect';
            } else {
                feedback.textContent = '✗ Noch nicht richtig. Es fehlen Kanten.';
                feedback.className = 'feedback incorrect';
            }
        }
        
        function showFaces() {
            if (!currentShape || !currentShape.faces) return;
            clearFaces();
            
            currentShape.faces.forEach(face => {
                const vertices = face.map(v => new THREE.Vector3(v[0], v[1], v[2]));
                
                // Calculate face normal for lighting
                const v1 = new THREE.Vector3().subVectors(vertices[1], vertices[0]);
                const v2 = new THREE.Vector3().subVectors(vertices[2], vertices[0]);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                
                // Light direction (from top-right-front)
                const lightDir = new THREE.Vector3(0.3, 0.7, 0.5).normalize();
                let brightness = Math.abs(normal.dot(lightDir));
                brightness = 0.6 + brightness * 0.4; // Range 0.6 to 1.0 (lighter)
                
                // Base color lighter mint green
                const baseColor = { r: 150, g: 220, b: 200 };
                const color = new THREE.Color(
                    (baseColor.r * brightness) / 255,
                    (baseColor.g * brightness) / 255,
                    (baseColor.b * brightness) / 255
                );
                
                let geometry;
                
                if (vertices.length === 3) {
                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[1].x, vertices[1].y, vertices[1].z,
                        vertices[2].x, vertices[2].y, vertices[2].z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                } else if (vertices.length === 4) {
                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[1].x, vertices[1].y, vertices[1].z,
                        vertices[2].x, vertices[2].y, vertices[2].z,
                        vertices[0].x, vertices[0].y, vertices[0].z,
                        vertices[2].x, vertices[2].y, vertices[2].z,
                        vertices[3].x, vertices[3].y, vertices[3].z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                }
                
                if (geometry) {
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5,
                        depthWrite: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.renderOrder = 0;
                    cubeGroup.add(mesh);
                    faceMeshes.push(mesh);
                }
            });
            
            // Re-render edges on top of faces
            updateEdgeVisuals();
        }
        
        function clearFaces() {
            faceMeshes.forEach(mesh => cubeGroup.remove(mesh));
            faceMeshes = [];
        }
        
        function hideFeedback() {
            document.getElementById('feedback').className = 'feedback';
        }
        
        function getClickedPoint(event) {
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitBoxes);
            
            if (intersects.length > 0) {
                return intersects[0].object.userData;
            }
            return null;
        }
        
        function onClick(event) {
            if (isRotating) return;
            
            const hit = getClickedPoint(event);
            if (hit) {
                const point = hit.point;
                const ringMesh = hit.ringMesh;
                
                if (selectedPoint === null) {
                    selectedPoint = point;
                    ringMesh.material.color.setHex(0x2563eb);
                    document.getElementById('statusText').textContent = 'Wähle zweiten Punkt';
                } else {
                    if (point.x !== selectedPoint.x || point.y !== selectedPoint.y || point.z !== selectedPoint.z) {
                        addEdge(selectedPoint, point);
                    }
                    pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
                    selectedPoint = null;
                    document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
                }
            }
        }
        
        function onMouseDown(event) {
            const hit = getClickedPoint(event);
            if (!hit) {
                isRotating = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onMouseMove(event) {
            if (isRotating) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                cameraTheta -= deltaX * 0.01;
                cameraPhi += deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                updateCameraPosition();
                updateAllEdges();
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onMouseUp() { isRotating = false; }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const canvas = renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                if (raycaster.intersectObjects(hitBoxes).length === 0) {
                    isRotating = true;
                    previousMousePosition = { x: touch.clientX, y: touch.clientY };
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (isRotating && event.touches.length === 1) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;
                
                cameraTheta -= deltaX * 0.01;
                cameraPhi += deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                updateCameraPosition();
                updateAllEdges();
                
                previousMousePosition = { x: touch.clientX, y: touch.clientY };
            }
        }
        
        function onTouchEnd(event) {
            if (isRotating) {
                isRotating = false;
                return;
            }
            
            const touch = event.changedTouches[0];
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitBoxes);
            
            if (intersects.length > 0) {
                const hit = intersects[0].object.userData;
                const point = hit.point;
                const ringMesh = hit.ringMesh;
                
                if (selectedPoint === null) {
                    selectedPoint = point;
                    ringMesh.material.color.setHex(0x2563eb);
                    document.getElementById('statusText').textContent = 'Wähle zweiten Punkt';
                } else {
                    if (point.x !== selectedPoint.x || point.y !== selectedPoint.y || point.z !== selectedPoint.z) {
                        addEdge(selectedPoint, point);
                    }
                    pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
                    selectedPoint = null;
                    document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
                }
            }
        }
        
        function setView(view) {
            const duration = 400;
            const startTheta = cameraTheta;
            const startPhi = cameraPhi;
            let targetTheta, targetPhi;
            
            switch(view) {
                case 'front': targetTheta = 0; targetPhi = Math.PI / 2; break;
                case 'right': targetTheta = Math.PI / 2; targetPhi = Math.PI / 2; break;
                case 'top': targetTheta = 0; targetPhi = 0.01; break;
                case 'iso': 
                default: targetTheta = Math.PI / 5; targetPhi = Math.PI * 0.38; break;
            }
            
            const startTime = Date.now();
            function animateView() {
                const progress = Math.min((Date.now() - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                cameraTheta = startTheta + (targetTheta - startTheta) * eased;
                cameraPhi = startPhi + (targetPhi - startPhi) * eased;
                updateCameraPosition();
                updateAllEdges();
                if (progress < 1) requestAnimationFrame(animateView);
            }
            animateView();
            
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        function undoLastEdge() {
            if (edges.length > 0) {
                edges.pop();
                updateEdgeVisuals();
                document.getElementById('edgeCount').textContent = edges.length;
                hideFeedback();
                clearFaces();
            }
        }
        
        function clearAll() {
            edges = [];
            updateEdgeVisuals();
            document.getElementById('edgeCount').textContent = 0;
            pointMeshes.forEach(mesh => mesh.material.color.setHex(0x666666));
            selectedPoint = null;
            document.getElementById('statusText').textContent = 'Klicke zwei Punkte um eine Kante zu zeichnen';
            hideFeedback();
            clearFaces();
        }
        
        function showSolution() {
            if (!currentShape) return;
            clearAll();
            currentShape.edges.forEach((edge, index) => {
                setTimeout(() => {
                    addEdge(
                        { x: edge[0][0], y: edge[0][1], z: edge[0][2] },
                        { x: edge[1][0], y: edge[1][1], z: edge[1][2] }
                    );
                    if (index === currentShape.edges.length - 1) {
                        setTimeout(showFaces, 100);
                    }
                }, index * 80);
            });
        }
        
        function drawTaskViews() {
            if (!currentShape) return;
            drawView('viewFront', 'front');
            drawView('viewRight', 'right');
            drawView('viewTop', 'top');
        }
        
        function drawView(canvasId, view) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, w, h);
            
            const padding = 15;
            const size = Math.min(w, h) - padding * 2;
            const step = size / 2;
            const ox = padding, oy = padding;
            
            // Grid points as circles
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            for (let i = 0; i <= 2; i++) {
                for (let j = 0; j <= 2; j++) {
                    ctx.beginPath();
                    ctx.arc(ox + i * step, oy + j * step, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Edges
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            
            const projectedEdges = [];
            currentShape.edges.forEach(edge => {
                let p1, p2;
                if (view === 'front') {
                    p1 = { x: edge[0][0], y: 2 - edge[0][1] };
                    p2 = { x: edge[1][0], y: 2 - edge[1][1] };
                } else if (view === 'right') {
                    p1 = { x: 2 - edge[0][2], y: 2 - edge[0][1] };
                    p2 = { x: 2 - edge[1][2], y: 2 - edge[1][1] };
                } else {
                    p1 = { x: edge[0][0], y: edge[0][2] };
                    p2 = { x: edge[1][0], y: edge[1][2] };
                }
                projectedEdges.push({ p1, p2 });
            });
            
            const uniqueEdges = [];
            projectedEdges.forEach(edge => {
                if (Math.abs(edge.p1.x - edge.p2.x) < 0.01 && Math.abs(edge.p1.y - edge.p2.y) < 0.01) return;
                const isDuplicate = uniqueEdges.some(e => 
                    (Math.abs(e.p1.x - edge.p1.x) < 0.01 && Math.abs(e.p1.y - edge.p1.y) < 0.01 &&
                     Math.abs(e.p2.x - edge.p2.x) < 0.01 && Math.abs(e.p2.y - edge.p2.y) < 0.01) ||
                    (Math.abs(e.p1.x - edge.p2.x) < 0.01 && Math.abs(e.p1.y - edge.p2.y) < 0.01 &&
                     Math.abs(e.p2.x - edge.p1.x) < 0.01 && Math.abs(e.p2.y - edge.p1.y) < 0.01)
                );
                if (!isDuplicate) uniqueEdges.push(edge);
            });
            
            uniqueEdges.forEach(edge => {
                ctx.beginPath();
                ctx.moveTo(ox + edge.p1.x * step, oy + edge.p1.y * step);
                ctx.lineTo(ox + edge.p2.x * step, oy + edge.p2.y * step);
                ctx.stroke();
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            pointMeshes.forEach(mesh => mesh.lookAt(camera.position));
            renderer.render(scene, camera);
        }
        
        window.addEventListener('DOMContentLoaded', init);
        
        // Handle resize for responsive canvas
        function handleResize() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;
            const width = Math.min(600, container.clientWidth);
            const height = window.innerWidth <= 480 ? 300 : 450;
            
            canvas.width = width;
            canvas.height = height;
            
            if (renderer && camera) {
                renderer.setSize(width, height);
                const aspect = width / height;
                const frustumSize = 5;
                camera.left = -frustumSize * aspect / 2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = -frustumSize / 2;
                camera.updateProjectionMatrix();
            }
            
            // Resize task views
            const taskCanvases = ['viewFront', 'viewRight', 'viewTop'];
            const taskSize = window.innerWidth <= 360 ? 75 : (window.innerWidth <= 480 ? 90 : 120);
            taskCanvases.forEach(id => {
                const c = document.getElementById(id);
                c.width = taskSize;
                c.height = taskSize;
            });
            
            if (currentShape) drawTaskViews();
        }
        
        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>
