<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formel-Champion</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        button {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #fff;
            color: #000;
            padding: 20px;
            max-width: 750px;
            margin: 0 auto;
        }
        
        h1 { 
            font-size: 1.2rem; 
            font-weight: 500; 
            margin-bottom: 20px; 
            text-align: center; 
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 24px;
            border-bottom: 1px solid #eee;
            padding-bottom: 16px;
            flex-wrap: wrap;
        }
        .tab-btn {
            font-family: inherit;
            font-size: 0.95rem;
            padding: 8px 20px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
        }
        .tab-btn:hover { background: #f5f5f5; }
        .tab-btn.active {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Score Bar */
        .score-bar {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 20px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        .streak-fire { color: #f59e0b; }

        /* Level/Topic Selection */
        .level-select, .topic-select {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 24px;
        }
        .level-btn, .topic-btn {
            font-family: inherit;
            font-size: 0.85rem;
            padding: 6px 14px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
        }
        .level-btn:hover, .topic-btn:hover { background: #f5f5f5; }
        .level-btn.active, .topic-btn.active {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        /* Theory Section */
        .theory-section {
            margin-bottom: 32px;
        }
        .theory-section h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: #000;
        }
        .theory-section p {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #444;
            margin-bottom: 12px;
        }
        .theory-example {
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        .theory-example-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #000;
        }
        .theory-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin: 12px 0;
            padding: 12px;
            background: #fff;
            border-radius: 6px;
        }
        .theory-step-num {
            width: 24px;
            height: 24px;
            background: #000;
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        .theory-step-text {
            font-size: 0.9rem;
            color: #444;
            line-height: 1.5;
        }
        .highlight-blue { color: #1d4ed8; font-weight: 600; }
        .highlight-pink { color: #be185d; font-weight: 600; }
        .highlight-green { color: #16a34a; font-weight: 600; }

        .rule-box {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }
        .rule {
            padding: 12px 20px;
            border-radius: 6px;
            text-align: center;
            flex: 1;
            max-width: 200px;
            min-width: 150px;
        }
        .rule.multiply {
            background: #dbeafe;
            border: 1px solid #3b82f6;
        }
        .rule.divide {
            background: #dcfce7;
            border: 1px solid #22c55e;
        }
        .rule.sqrt {
            background: #fce7f3;
            border: 1px solid #ec4899;
        }
        .rule-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .rule.multiply .rule-title { color: #1d4ed8; }
        .rule.divide .rule-title { color: #16a34a; }
        .rule.sqrt .rule-title { color: #be185d; }
        .rule-desc {
            font-size: 0.8rem;
            color: #666;
        }

        /* Formula Display */
        .formula-card {
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            text-align: center;
        }
        .formula-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 4px;
        }
        .formula-category {
            font-size: 0.85rem;
            color: #666;
        }

        /* Equation Display */
        .equation-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin: 24px 0;
            font-size: 1.8rem;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        .equation-side {
            min-width: 100px;
            text-align: center;
            padding: 16px 20px;
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
        }
        .equation-equals {
            font-size: 1.4rem;
            color: #666;
            font-style: normal;
        }

        /* Target Info */
        .target-info {
            text-align: center;
            padding: 16px;
            background: #dbeafe;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 24px;
        }
        .target-info span {
            font-weight: 700;
            color: #1d4ed8;
        }

        /* Operations Grid */
        .operations-section {
            margin-bottom: 24px;
        }
        .operations-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 12px;
            text-align: center;
        }
        .operations-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            max-width: 600px;
            margin: 0 auto;
        }
        .op-pair {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .op-btn {
            padding: 12px 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: #fff;
            color: #000;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
            min-width: 75px;
            text-align: center;
            line-height: 1;
        }
        .op-btn sup {
            font-size: 0.75em;
            vertical-align: super;
            line-height: 0;
        }
        .op-btn:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        .op-btn.correct {
            background: #dcfce7;
            border-color: #22c55e;
            animation: correctPulse 0.5s;
        }
        .op-btn.wrong {
            background: #fef2f2;
            border-color: #ef4444;
            animation: shake 0.4s;
        }
        .op-btn.possible {
            background: #fef3c7;
            border-color: #f59e0b;
            animation: shake 0.4s;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        /* Steps Display */
        .steps-section {
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }
        .steps-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 12px;
        }
        .steps-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .step-item {
            display: grid;
            grid-template-columns: 32px 1fr 24px 1fr 24px auto;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: #fff;
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
        }
        .step-num {
            width: 28px;
            height: 28px;
            background: #3b82f6;
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .step-left, .step-right {
            font-size: 1.2rem;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        .step-left { text-align: right; }
        .step-right { text-align: left; }
        .step-equals {
            text-align: center;
            color: #666;
        }
        .step-divider {
            color: #3b82f6;
            font-weight: 300;
        }
        .step-op {
            color: #be185d;
            font-family: 'Times New Roman', serif;
            min-width: 50px;
        }

        /* Feedback */
        .feedback {
            text-align: center;
            font-size: 1rem;
            min-height: 28px;
            margin-bottom: 20px;
        }
        .feedback.correct { color: #16a34a; }
        .feedback.wrong { color: #dc2626; }

        /* Buttons */
        .button-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 16px;
        }
        .action-btn {
            font-family: inherit;
            font-size: 0.85rem;
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
        }
        .action-btn:hover { background: #f5f5f5; }
        .action-btn.primary {
            background: #2563eb;
            color: #fff;
            border-color: #2563eb;
        }
        .action-btn.primary:hover { background: #1d4ed8; }

        /* Undo/Redo */
        .undo-redo-row {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
        }
        .undo-redo-btn {
            font-family: inherit;
            font-size: 1.2rem;
            width: 44px;
            height: 44px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .undo-redo-btn:hover:not(:disabled) { 
            background: #f5f5f5; 
        }
        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Success Card */
        .success-card {
            background: #dcfce7;
            border: 2px solid #22c55e;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            margin: 20px 0;
            animation: successPop 0.4s ease;
        }
        @keyframes successPop {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .success-emoji {
            font-size: 2.5rem;
            margin-bottom: 12px;
        }
        .success-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #16a34a;
            margin-bottom: 16px;
        }
        .success-formula {
            font-size: 1.5rem;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            padding: 12px 20px;
            background: #fff;
            border-radius: 8px;
            display: inline-block;
            margin-bottom: 16px;
        }
        .success-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 16px;
        }
        .success-stat {
            text-align: center;
        }
        .success-stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #16a34a;
        }
        .success-stat-label {
            font-size: 0.8rem;
            color: #666;
        }

        /* Inline Success Message */
        .success-inline {
            background: #dcfce7;
            border: 2px solid #22c55e;
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
        }
        .success-inline-content {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        .success-inline-icon {
            font-size: 1.5rem;
        }
        .success-inline-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #16a34a;
        }
        .success-inline-points {
            font-size: 1rem;
            font-weight: 700;
            color: #16a34a;
            background: #fff;
            padding: 4px 10px;
            border-radius: 4px;
        }
        .success-inline-streak {
            font-size: 1rem;
            font-weight: 600;
            color: #f59e0b;
        }

        /* Hint */
        .hint-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #fef3c7;
            border: 2px solid #f59e0b;
            cursor: pointer;
            font-size: 1.3rem;
            display: none;
            z-index: 100;
        }
        .hint-btn:hover {
            background: #fde68a;
        }
        .hint-popup {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            font-size: 0.9rem;
            display: none;
            z-index: 100;
        }
        .hint-popup.show {
            display: block;
        }

        /* Timer */
        .timer-display {
            text-align: center;
            font-size: 1.1rem;
            color: #666;
        }
        .timer-display.warning {
            color: #dc2626;
            font-weight: 600;
        }

        /* Exam Styles */
        .exam-start, .exam-results {
            text-align: center;
            padding: 40px 20px;
        }
        .exam-start h2 {
            font-size: 1.2rem;
            margin-bottom: 16px;
        }
        .exam-start p {
            color: #666;
            margin-bottom: 24px;
        }
        .exam-results h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
        }
        .exam-score {
            font-size: 3rem;
            font-weight: 700;
            color: #16a34a;
            margin-bottom: 8px;
        }
        .exam-percent {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 24px;
        }
        .exam-wrong-section {
            margin-top: 24px;
            text-align: left;
        }
        .exam-wrong-section h3 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #dc2626;
        }
        .exam-wrong-item {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }
        .exam-wrong-header {
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .exam-wrong-header:hover {
            background: #fee2e2;
        }
        .exam-wrong-item .task {
            font-weight: 600;
        }
        .exam-wrong-toggle {
            font-size: 0.85rem;
            color: #666;
            transition: transform 0.2s;
        }
        .exam-wrong-item.open .exam-wrong-toggle {
            transform: rotate(180deg);
        }
        .exam-wrong-solution {
            display: none;
            padding: 0 12px 12px;
            border-top: 1px solid #fecaca;
            background: #fff;
        }
        .exam-wrong-item.open .exam-wrong-solution {
            display: block;
        }
        .exam-wrong-solution .step-item {
            margin: 8px 0;
            font-size: 0.9rem;
        }
        .exam-wrong-item .answers {
            font-size: 0.85rem;
            color: #666;
        }
        .exam-wrong-item .correct-answer {
            color: #16a34a;
            font-weight: 600;
        }

        /* Math Fractions */
        .frac {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 2px;
        }
        .frac-num {
            border-bottom: 1px solid currentColor;
            padding: 0 4px 2px;
        }
        .frac-den {
            padding: 2px 4px 0;
        }
        .sqrt-symbol {
            display: inline-flex;
            align-items: center;
        }
        .sqrt-symbol::before {
            content: '‚àö';
            margin-right: 2px;
        }
        .sqrt-content {
            border-top: 1px solid currentColor;
            padding: 0 4px;
        }

        /* Popup */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .popup-overlay.visible {
            display: flex;
        }
        .popup {
            background: #fff;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }
        .popup-content {
            padding: 20px;
            font-size: 0.95rem;
            color: #444;
            line-height: 1.6;
            text-align: center;
        }
        .popup-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
        }
        .popup-btn {
            font-family: inherit;
            font-size: 0.95rem;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
        }
        .popup-btn-cancel {
            background: #fff;
            color: #444;
            border: 1px solid #ccc;
        }
        .popup-btn-cancel:hover {
            background: #f5f5f5;
        }
        .popup-btn-confirm {
            background: #dc2626;
            color: #fff;
            border: none;
        }
        .popup-btn-confirm:hover {
            background: #b91c1c;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .equation-display {
                font-size: 1.4rem;
                gap: 10px;
            }
            .equation-side {
                min-width: 80px;
                padding: 12px 14px;
            }
            .step-item {
                grid-template-columns: 28px 1fr 20px 1fr 20px auto;
                font-size: 0.9rem;
                padding: 8px 10px;
            }
            .step-left, .step-right {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <h1>Formel-Champion</h1>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-btn active" onclick="showTab('theory')">Theorie</button>
        <button class="tab-btn" onclick="showTab('understand')">Verstehen</button>
        <button class="tab-btn" onclick="showTab('practice')">√úben</button>
        <button class="tab-btn" onclick="showTab('exam')">Pr√ºfung</button>
    </nav>

    <!-- TAB 1: THEORIE -->
    <div id="tab-theory" class="tab-content active">
        <div class="theory-section">
            <h2>Was bedeutet "nach einer Variable aufl√∂sen"?</h2>
            <p>Wenn du eine Formel nach einer Variable aufl√∂st, bringst du diese Variable <strong>alleine auf eine Seite</strong> der Gleichung. Das ist wichtig, wenn du den Wert dieser Variable berechnen m√∂chtest.</p>
            
            <div class="theory-example">
                <div class="theory-example-title">Beispiel: Rechteck-Fl√§che</div>
                <p>Die Formel f√ºr die Fl√§che eines Rechtecks ist:</p>
                <div class="equation-display" style="font-size: 1.5rem; margin: 16px 0;">
                    <span>A = a ¬∑ b</span>
                </div>
                <p>Wenn du die <span class="highlight-blue">Seite a</span> berechnen m√∂chtest, musst du nach <span class="highlight-blue">a</span> aufl√∂sen:</p>
                <div class="equation-display" style="font-size: 1.5rem; margin: 16px 0;">
                    <span class="highlight-blue">a</span> = <span class="frac"><span class="frac-num">A</span><span class="frac-den">b</span></span>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h2>Die wichtigsten Regeln</h2>
            <p>Um Formeln umzustellen, nutzt du die <strong>Umkehroperationen</strong> (Gegenoperationen). Was auf einer Seite gemacht wird, muss auch auf der anderen Seite gemacht werden!</p>
            
            <div class="rule-box">
                <div class="rule multiply">
                    <div class="rule-title">Multiplikation ‚Üî Division</div>
                    <div class="rule-desc">¬∑ 2 wird zu : 2</div>
                </div>
                <div class="rule divide">
                    <div class="rule-title">Division ‚Üî Multiplikation</div>
                    <div class="rule-desc">: 3 wird zu ¬∑ 3</div>
                </div>
                <div class="rule sqrt">
                    <div class="rule-title">Quadrat ‚Üî Wurzel</div>
                    <div class="rule-desc">x¬≤ wird zu ‚àöx</div>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h2>Schritt-f√ºr-Schritt Beispiel</h2>
            <div class="theory-example">
                <div class="theory-example-title">L√∂se nach r auf: U = 2 ¬∑ œÄ ¬∑ r</div>
                
                <div class="theory-step">
                    <div class="theory-step-num">1</div>
                    <div class="theory-step-text">
                        <strong>Ausgangsgleichung:</strong> U = 2 ¬∑ œÄ ¬∑ <span class="highlight-blue">r</span><br>
                        Das <span class="highlight-blue">r</span> ist mit 2 und œÄ multipliziert.
                    </div>
                </div>
                
                <div class="theory-step">
                    <div class="theory-step-num">2</div>
                    <div class="theory-step-text">
                        <strong>Teile durch 2:</strong> <span class="frac"><span class="frac-num">U</span><span class="frac-den">2</span></span> = œÄ ¬∑ <span class="highlight-blue">r</span><br>
                        Die 2 ist weg!
                    </div>
                </div>
                
                <div class="theory-step">
                    <div class="theory-step-num">3</div>
                    <div class="theory-step-text">
                        <strong>Teile durch œÄ:</strong> <span class="frac"><span class="frac-num">U</span><span class="frac-den">2 ¬∑ œÄ</span></span> = <span class="highlight-blue">r</span><br>
                        <span class="highlight-green">Fertig!</span> r steht alleine.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- TAB 2: VERSTEHEN -->
    <div id="tab-understand" class="tab-content">
        <div class="theory-section">
            <h2>Interaktives Beispiel</h2>
            <p>W√§hle eine Formel und sieh dir Schritt f√ºr Schritt an, wie man sie umstellt:</p>
        </div>

        <div class="topic-select" id="understand-formula-select">
            <button class="topic-btn active" onclick="selectUnderstandFormula(0, this)">A = a ¬∑ b</button>
            <button class="topic-btn" onclick="selectUnderstandFormula(1, this)">U = 2œÄr</button>
            <button class="topic-btn" onclick="selectUnderstandFormula(2, this)">A = œÄr¬≤</button>
            <button class="topic-btn" onclick="selectUnderstandFormula(3, this)">c¬≤ = a¬≤ + b¬≤</button>
        </div>

        <div class="level-select" id="understand-target-select">
            <!-- Filled dynamically -->
        </div>

        <div id="understand-demo">
            <!-- Filled dynamically -->
        </div>

        <div class="button-row">
            <button class="action-btn" id="understand-prev-btn" onclick="understandPrevStep()">‚Üê Zur√ºck</button>
            <button class="action-btn primary" id="understand-next-btn" onclick="understandNextStep()">Weiter ‚Üí</button>
        </div>
    </div>

    <!-- TAB 3: √úBEN -->
    <div id="tab-practice" class="tab-content">
        <div class="score-bar">
            <span>Punkte: <strong id="practice-score">0</strong></span>
            <span>Streak: <strong id="practice-streak">0</strong> <span id="practice-streak-fire" class="streak-fire" style="display:none;">üî•</span></span>
        </div>

        <div class="topic-select">
            <button class="topic-btn active" onclick="selectPracticeTopic('all', this)">üîÄ Alles</button>
            <button class="topic-btn" onclick="selectPracticeTopic('üìê Ebene Figuren', this)">üìê Fl√§chen</button>
            <button class="topic-btn" onclick="selectPracticeTopic('üì¶ K√∂rper & Volumen', this)">üì¶ K√∂rper</button>
            <button class="topic-btn" onclick="selectPracticeTopic('üìê Satz des Pythagoras', this)">üìê Pythagoras</button>
            <button class="topic-btn" onclick="selectPracticeTopic('‚ö° Physik-Formeln', this)">‚ö° Physik</button>
        </div>

        <div class="level-select">
            <button class="level-btn active" onclick="selectPracticeDifficulty('easy', this)">‚≠ê Einfach</button>
            <button class="level-btn" onclick="selectPracticeDifficulty('medium', this)">‚≠ê‚≠ê Mittel</button>
            <button class="level-btn" onclick="selectPracticeDifficulty('hard', this)">‚≠ê‚≠ê‚≠ê Schwer</button>
        </div>

        <div id="practice-game-area">
            <!-- Formula Card -->
            <div class="formula-card">
                <div class="formula-name" id="practice-formula-name">Rechteck (Fl√§che)</div>
                <div class="formula-category" id="practice-formula-category">üìê Ebene Figuren</div>
            </div>

            <!-- Equation Display -->
            <div class="equation-display">
                <div class="equation-side" id="practice-left-side">A</div>
                <div class="equation-equals">=</div>
                <div class="equation-side" id="practice-right-side">a ¬∑ b</div>
            </div>

            <!-- Target -->
            <div class="target-info">
                L√∂se nach <span id="practice-target">a</span> auf!
            </div>

            <!-- Operations -->
            <div class="operations-section">
                <div class="operations-title">W√§hle die richtige Operation:</div>
                <div class="operations-grid" id="practice-op-buttons"></div>
            </div>

            <!-- Steps -->
            <div class="steps-section">
                <div class="steps-title">üìù Deine Schritte</div>
                <div class="steps-list" id="practice-steps-list"></div>
            </div>

            <!-- Feedback -->
            <div class="feedback" id="practice-feedback"></div>

            <!-- Buttons -->
            <div class="button-row">
                <button class="action-btn" onclick="skipPracticeTask()">√úberspringen</button>
                <button class="action-btn primary" onclick="generatePracticeTask()" id="practice-next-btn" style="display:none;">N√§chste Aufgabe</button>
            </div>
        </div>

        <!-- Success Card (hidden by default) -->
        <div class="success-card" id="practice-success" style="display:none;">
            <div class="success-emoji">üéâ</div>
            <div class="success-title">Richtig gel√∂st!</div>
            <div class="success-formula" id="practice-success-formula"></div>
            <div class="success-stats">
                <div class="success-stat">
                    <div class="success-stat-value" id="practice-success-points">+100</div>
                    <div class="success-stat-label">Punkte</div>
                </div>
                <div class="success-stat">
                    <div class="success-stat-value" id="practice-success-streak">üî• 1</div>
                    <div class="success-stat-label">Streak</div>
                </div>
            </div>
            <button class="action-btn primary" onclick="continuePractice()">Weiter √ºben</button>
        </div>
    </div>

    <!-- TAB 4: PR√úFUNG -->
    <div id="tab-exam" class="tab-content">
        <!-- Start Screen -->
        <div id="exam-start" class="exam-start">
            <h2>Pr√ºfungsmodus</h2>
            <p>10 Aufgaben aus allen Schwierigkeiten<br>5 Minuten Zeit<br>Zeige was du kannst!</p>
            <button class="action-btn primary" onclick="startExam()" style="font-size: 1.1rem; padding: 12px 32px;">
                üöÄ Pr√ºfung starten
            </button>
        </div>

        <!-- Active Exam -->
        <div id="exam-active" style="display:none;">
            <div class="score-bar">
                <span>Aufgabe: <strong id="exam-current">1</strong>/10</span>
                <span id="exam-timer" class="timer-display">5:00</span>
            </div>

            <div class="formula-card">
                <div class="formula-name" id="exam-formula-name">Rechteck (Fl√§che)</div>
                <div class="formula-category" id="exam-formula-category">üìê Ebene Figuren</div>
            </div>

            <div class="equation-display">
                <div class="equation-side" id="exam-left-side">A</div>
                <div class="equation-equals">=</div>
                <div class="equation-side" id="exam-right-side">a ¬∑ b</div>
            </div>

            <div class="target-info">
                L√∂se nach <span id="exam-target">a</span> auf!
            </div>

            <div class="operations-section">
                <div class="operations-title">W√§hle die richtige Operation:</div>
                <div class="operations-grid" id="exam-op-buttons"></div>
            </div>

            <div class="steps-section">
                <div class="steps-title">üìù Deine Schritte</div>
                <div class="steps-list" id="exam-steps-list"></div>
            </div>

            <div class="undo-redo-row">
                <button class="undo-redo-btn" id="exam-undo-btn" onclick="examUndo()" disabled>‚Ü©</button>
                <button class="undo-redo-btn" id="exam-redo-btn" onclick="examRedo()" disabled>‚Ü™</button>
            </div>

            <div class="button-row">
                <button class="action-btn primary" id="exam-next-btn" onclick="nextExamTask()">N√§chste Aufgabe ‚Üí</button>
            </div>
        </div>

        <!-- Results -->
        <div id="exam-results" class="exam-results" style="display:none;">
            <h2>Pr√ºfung beendet!</h2>
            <div class="exam-score" id="exam-correct">8/10</div>
            <div class="exam-percent" id="exam-percent">80%</div>
            
            <div class="exam-wrong-section" id="exam-wrong-section" style="display:none;">
                <h3>Diese Aufgaben waren falsch:</h3>
                <div id="exam-wrong-list"></div>
            </div>

            <div class="button-row" style="margin-top: 24px;">
                <button class="action-btn primary" onclick="restartExam()">üîÑ Neue Pr√ºfung</button>
            </div>
        </div>
    </div>

    <!-- Hint Button -->
    <button class="hint-btn" id="hint-btn" onclick="toggleHint()">üí°</button>
    <div class="hint-popup" id="hint-popup"></div>

    <!-- Exam Abort Popup -->
    <div class="popup-overlay" id="exam-abort-overlay">
        <div class="popup">
            <div class="popup-header">
                <span>Pr√ºfung abbrechen?</span>
            </div>
            <div class="popup-content">
                <p>Willst du die Pr√ºfung wirklich abbrechen?</p>
                <div class="popup-buttons">
                    <button class="popup-btn popup-btn-cancel" id="exam-abort-no">Nein</button>
                    <button class="popup-btn popup-btn-confirm" id="exam-abort-yes">Ja</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== CONSTANTS ==========
        const MUL = '¬∑';
        const PI = 'œÄ';
        
        // ========== MATH HELPERS ==========
        function frac(num, den) {
            return `<span class="frac"><span class="frac-num">${num}</span><span class="frac-den">${den}</span></span>`;
        }
        
        function sqrt(content) {
            return `<span class="sqrt-symbol"><span class="sqrt-content">${content}</span></span>`;
        }
        
        function cbrt(content) {
            return `<sup>3</sup>${sqrt(content)}`;
        }
        
        function sup(base, exp) {
            return `${base}<sup>${exp}</sup>`;
        }
        
        function hl(text) {
            return `<span class="highlight-blue">${text}</span>`;
        }
        
        function renderLatex(text) {
            return text;
        }

        // ========== TAB NAVIGATION ==========
        let pendingTabSwitch = null;
        
        function showTab(tabName) {
            // Pr√ºfen ob eine Pr√ºfung l√§uft und der User einen anderen Tab w√§hlt
            if (typeof examState !== 'undefined' && examState.started && tabName !== 'exam') {
                pendingTabSwitch = tabName;
                document.getElementById('exam-abort-overlay').classList.add('visible');
                return;
            }
            
            switchToTab(tabName);
        }
        
        function switchToTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('tab-' + tabName).classList.add('active');
            document.querySelector(`.tab-btn[onclick*="${tabName}"]`).classList.add('active');
            
            const hintBtn = document.getElementById('hint-btn');
            if (tabName === 'practice') {
                hintBtn.style.display = 'block';
            } else {
                hintBtn.style.display = 'none';
                document.getElementById('hint-popup').classList.remove('show');
            }
            
            if (tabName === 'understand') {
                initUnderstand();
            } else if (tabName === 'practice') {
                if (!practiceState.initialized) {
                    initPractice();
                }
            }
        }
        
        // Popup Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            const examAbortOverlay = document.getElementById('exam-abort-overlay');
            const examAbortYes = document.getElementById('exam-abort-yes');
            const examAbortNo = document.getElementById('exam-abort-no');
            
            examAbortNo.addEventListener('click', () => {
                examAbortOverlay.classList.remove('visible');
                pendingTabSwitch = null;
            });
            
            examAbortYes.addEventListener('click', () => {
                examAbortOverlay.classList.remove('visible');
                // Pr√ºfung beenden
                clearInterval(examState.timerInterval);
                examState.started = false;
                document.getElementById('exam-active').style.display = 'none';
                document.getElementById('exam-start').style.display = 'block';
                // Zum gew√ºnschten Tab wechseln
                if (pendingTabSwitch) {
                    switchToTab(pendingTabSwitch);
                    pendingTabSwitch = null;
                }
            });
            
            examAbortOverlay.addEventListener('click', (e) => {
                if (e.target === examAbortOverlay) {
                    examAbortOverlay.classList.remove('visible');
                    pendingTabSwitch = null;
                }
            });
        });

        // ========== STATE SYSTEM ==========
        function createState(leftNum, leftDen, rightNum, rightDen, target) {
            return {
                leftNum: [...leftNum],
                leftDen: [...leftDen],
                rightNum: [...rightNum],
                rightDen: [...rightDen],
                target: target
            };
        }

        function cloneState(state) {
            return {
                leftNum: [...state.leftNum],
                leftDen: [...state.leftDen],
                rightNum: [...state.rightNum],
                rightDen: [...state.rightDen],
                target: state.target
            };
        }

        function renderFactor(factor) {
            if (factor === 'œÄ') return 'œÄ';
            if (factor.endsWith('¬≤')) return factor.slice(0, -1) + '<sup>2</sup>';
            if (factor.endsWith('¬≥')) return factor.slice(0, -1) + '<sup>3</sup>';
            return factor;
        }

        function renderSide(num, den, target) {
            const formatFactors = (factors) => {
                if (factors.length === 0) return '1';
                return factors.map(f => {
                    const rendered = renderFactor(f);
                    const baseVar = f.endsWith('¬≤') ? f.slice(0, -1) : (f.endsWith('¬≥') ? f.slice(0, -1) : f);
                    if (baseVar === target || f === target) {
                        return `<span class="highlight-blue">${rendered}</span>`;
                    }
                    return rendered;
                }).join(` ${MUL} `);
            };

            const numStr = formatFactors(num);
            
            if (den.length === 0) {
                return numStr;
            } else {
                return frac(numStr, formatFactors(den));
            }
        }

        function applyOpToState(state, opId) {
            const newState = cloneState(state);
            
            if (opId.startsWith('div_')) {
                const divisor = opId.replace('div_', '');
                let removedLeft = false, removedRight = false;
                const leftIdx = newState.leftNum.indexOf(divisor);
                if (leftIdx !== -1) {
                    newState.leftNum.splice(leftIdx, 1);
                    removedLeft = true;
                }
                const rightIdx = newState.rightNum.indexOf(divisor);
                if (rightIdx !== -1) {
                    newState.rightNum.splice(rightIdx, 1);
                    removedRight = true;
                }
                if (!removedLeft) newState.leftDen.push(divisor);
                if (!removedRight) newState.rightDen.push(divisor);
            }
            else if (opId.startsWith('mul_')) {
                const multiplier = opId.replace('mul_', '');
                let removedLeft = false, removedRight = false;
                const leftIdx = newState.leftDen.indexOf(multiplier);
                if (leftIdx !== -1) {
                    newState.leftDen.splice(leftIdx, 1);
                    removedLeft = true;
                }
                const rightIdx = newState.rightDen.indexOf(multiplier);
                if (rightIdx !== -1) {
                    newState.rightDen.splice(rightIdx, 1);
                    removedRight = true;
                }
                if (!removedLeft) newState.leftNum.push(multiplier);
                if (!removedRight) newState.rightNum.push(multiplier);
            }
            else if (opId === 'sqrt') {
                newState.leftNum = newState.leftNum.map(f => f.endsWith('¬≤') ? f.slice(0, -1) : f);
                newState.rightNum = newState.rightNum.map(f => f.endsWith('¬≤') ? f.slice(0, -1) : f);
                if (newState.target.endsWith('¬≤')) {
                    newState.target = newState.target.slice(0, -1);
                }
            }
            else if (opId === 'cbrt') {
                newState.leftNum = newState.leftNum.map(f => f.endsWith('¬≥') ? f.slice(0, -1) : f);
                newState.rightNum = newState.rightNum.map(f => f.endsWith('¬≥') ? f.slice(0, -1) : f);
                if (newState.target.endsWith('¬≥')) {
                    newState.target = newState.target.slice(0, -1);
                }
            }
            
            return newState;
        }

        function isStateSolved(state) {
            const target = state.target;
            const leftAlone = state.leftNum.length === 1 && state.leftNum[0] === target && state.leftDen.length === 0;
            const rightAlone = state.rightNum.length === 1 && state.rightNum[0] === target && state.rightDen.length === 0;
            return leftAlone || rightAlone;
        }

        function needsSqrtStep(state, formula) {
            if (!formula || !formula.needsSqrtAtEnd) return false;
            const target = state.target;
            const leftIsolated = state.leftNum.length === 1 && state.leftNum[0] === target && state.leftDen.length === 0;
            const rightIsolated = state.rightNum.length === 1 && state.rightNum[0] === target && state.rightDen.length === 0;
            return (leftIsolated || rightIsolated) && target.endsWith('¬≤');
        }

        function needsCbrtStep(state, formula) {
            if (!formula || !formula.needsCbrtAtEnd) return false;
            const target = state.target;
            const leftIsolated = state.leftNum.length === 1 && state.leftNum[0] === target && state.leftDen.length === 0;
            const rightIsolated = state.rightNum.length === 1 && state.rightNum[0] === target && state.rightDen.length === 0;
            return (leftIsolated || rightIsolated) && target.endsWith('¬≥');
        }

        function getBaseVariable(factor) {
            if (factor.endsWith('¬≤')) return factor.slice(0, -1);
            if (factor.endsWith('¬≥')) return factor.slice(0, -1);
            return factor;
        }

        function factorContainsTarget(factor, target) {
            if (factor === target) return true;
            if (getBaseVariable(factor) === target) return true;
            return false;
        }

        function countDistractors(state) {
            const targetInLeftNum = state.leftNum.some(f => factorContainsTarget(f, state.target));
            const targetInRightNum = state.rightNum.some(f => factorContainsTarget(f, state.target));
            const targetInLeftDen = state.leftDen.some(f => factorContainsTarget(f, state.target));
            const targetInRightDen = state.rightDen.some(f => factorContainsTarget(f, state.target));

            if (targetInLeftNum && !targetInLeftDen) {
                return state.leftNum.filter(f => !factorContainsTarget(f, state.target)).length + state.leftDen.length;
            } else if (targetInRightNum && !targetInRightDen) {
                return state.rightNum.filter(f => !factorContainsTarget(f, state.target)).length + state.rightDen.length;
            }
            return 999;
        }

        function findTargetLocation(state) {
            if (state.leftNum.some(f => factorContainsTarget(f, state.target))) return 'leftNum';
            if (state.leftDen.some(f => factorContainsTarget(f, state.target))) return 'leftDen';
            if (state.rightNum.some(f => factorContainsTarget(f, state.target))) return 'rightNum';
            if (state.rightDen.some(f => factorContainsTarget(f, state.target))) return 'rightDen';
            return null;
        }

        function isOperationHelpful(state, opId, formula) {
            if (opId === 'pow2' || opId === 'pow3') return false;

            if (opId === 'sqrt' || opId === 'cbrt') {
                const targetLocation = findTargetLocation(state);
                if (!targetLocation) return false;
                
                let factors, den;
                if (targetLocation === 'leftNum') {
                    factors = state.leftNum;
                    den = state.leftDen;
                } else if (targetLocation === 'rightNum') {
                    factors = state.rightNum;
                    den = state.rightDen;
                } else {
                    return false;
                }
                
                const powerSuffix = opId === 'sqrt' ? '¬≤' : '¬≥';
                const targetBase = getBaseVariable(state.target);
                const poweredFactor = factors.find(f => f.endsWith(powerSuffix) && (f === state.target || getBaseVariable(f) === targetBase));
                
                if (!poweredFactor) return false;
                if (factors.length !== 1) return false;
                if (den.length > 0) return false;
                
                return true;
            }

            const newState = applyOpToState(state, opId);
            const oldLocation = findTargetLocation(state);
            const newLocation = findTargetLocation(newState);

            if (!newLocation) return false;

            if ((oldLocation === 'leftDen' || oldLocation === 'rightDen') &&
                (newLocation === 'leftNum' || newLocation === 'rightNum')) {
                return true;
            }

            if ((oldLocation === 'leftNum' || oldLocation === 'rightNum') &&
                (newLocation === 'leftDen' || newLocation === 'rightDen')) {
                return false;
            }

            const before = countDistractors(state);
            const after = countDistractors(newState);
            return after < before;
        }

        // ========== SOLUTION STEPS GENERATOR ==========
        function getSolutionStepsHtml(formula, target) {
            // Generiere die korrekten L√∂sungsschritte basierend auf der Formel
            let steps = [];
            
            if (formula.getInitialState && !formula.useOldSystem) {
                let state = formula.getInitialState(target);
                const initialLeft = renderSide(state.leftNum, state.leftDen, state.target);
                const initialRight = renderSide(state.rightNum, state.rightDen, state.target);
                steps.push({ left: initialLeft, right: initialRight, op: '' });
                
                // Simuliere die L√∂sung
                let maxSteps = 10;
                while (!isStateSolved(state) && maxSteps > 0) {
                    maxSteps--;
                    
                    // Sammle alle m√∂glichen Faktoren
                    const allFactors = [...new Set([...state.leftNum, ...state.rightNum])];
                    const allDenFactors = [...new Set([...state.leftDen, ...state.rightDen])];
                    
                    let foundOp = null;
                    let opSymbol = '';
                    let newState = null;
                    
                    // Versuche Division durch nicht-Ziel Faktoren
                    for (const item of allFactors) {
                        if (item !== state.target && !item.endsWith('¬≤') && !item.endsWith('¬≥')) {
                            const opId = 'div_' + item;
                            if (isOperationHelpful(state, opId, formula)) {
                                newState = applyOpToState(cloneState(state), opId);
                                opSymbol = `: ${item}`;
                                foundOp = opId;
                                break;
                            }
                        }
                    }
                    
                    // Versuche Multiplikation mit Nenner-Elementen
                    if (!foundOp) {
                        for (const item of allDenFactors) {
                            if (item !== state.target) {
                                const opId = 'mul_' + item;
                                if (isOperationHelpful(state, opId, formula)) {
                                    newState = applyOpToState(cloneState(state), opId);
                                    opSymbol = `${MUL} ${item}`;
                                    foundOp = opId;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Wurzel/Kubikwurzel am Ende
                    if (!foundOp && isOperationHelpful(state, 'sqrt', formula)) {
                        newState = applyOpToState(cloneState(state), 'sqrt');
                        opSymbol = '‚àö';
                        foundOp = 'sqrt';
                    }
                    
                    if (!foundOp && isOperationHelpful(state, 'cbrt', formula)) {
                        newState = applyOpToState(cloneState(state), 'cbrt');
                        opSymbol = '‚àõ';
                        foundOp = 'cbrt';
                    }
                    
                    if (foundOp && newState) {
                        state = newState;
                        const stepLeft = renderSide(state.leftNum, state.leftDen, state.target);
                        const stepRight = renderSide(state.rightNum, state.rightDen, state.target);
                        steps.push({ left: stepLeft, right: stepRight, op: opSymbol });
                    } else {
                        break;
                    }
                }
            } else if (formula.getSteps) {
                // F√ºr Formeln mit vordefinierten Schritten (wie Pythagoras)
                const stepsData = formula.getSteps(target);
                steps.push({ left: stepsData.start.left, right: stepsData.start.right, op: '' });
                stepsData.steps.forEach(s => {
                    steps.push({ left: s.left, right: s.right, op: s.op });
                });
            }
            
            // Generiere HTML
            let html = '<div class="steps-list" style="margin-top: 8px;">';
            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                const nextOp = (i + 1 < steps.length) ? steps[i + 1].op : '';
                html += `
                    <div class="step-item" style="font-size: 0.9rem;">
                        <div class="step-num">${i}</div>
                        <div class="step-left">${step.left}</div>
                        <div class="step-equals">=</div>
                        <div class="step-right">${step.right}</div>
                        <div class="step-divider">${nextOp ? '|' : ''}</div>
                        <div class="step-op">${nextOp}</div>
                    </div>
                `;
            }
            html += '</div>';
            return html;
        }

        // ========== FORMULAS ==========
        const formulasByDifficulty = {
            easy: [
                {
                    name: "Rechteck (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = a ${MUL} b`,
                    variables: ["a", "b"],
                    getInitialState: (target) => createState(['A'], [], ['a', 'b'], [], target)
                },
                {
                    name: "Quadrat (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 4 ${MUL} a`,
                    variables: ["a"],
                    getInitialState: (target) => createState(['U'], [], ['4', 'a'], [], 'a')
                },
                {
                    name: "Dreieck (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${frac(`g ${MUL} h`, '2')}`,
                    variables: ["g", "h"],
                    getInitialState: (target) => createState(['A'], [], ['g', 'h'], ['2'], target)
                },
                {
                    name: "Parallelogramm (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = a ${MUL} h`,
                    variables: ["a", "h"],
                    getInitialState: (target) => createState(['A'], [], ['a', 'h'], [], target)
                },
                {
                    name: "Kreis (Umfang)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `U = 2 ${MUL} ${PI} ${MUL} r`,
                    variables: ["r"],
                    getInitialState: (target) => createState(['U'], [], ['2', 'œÄ', 'r'], [], target)
                },
                {
                    name: "Prisma (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = G ${MUL} h`,
                    variables: ["G", "h"],
                    getInitialState: (target) => createState(['V'], [], ['G', 'h'], [], target)
                },
                {
                    name: "Geschwindigkeit",
                    category: "‚ö° Physik-Formeln",
                    displayFormula: () => `v = ${frac('s', 't')}`,
                    variables: ["s", "t"],
                    getInitialState: (target) => createState(['v'], [], ['s'], ['t'], target)
                },
                {
                    name: "Ohmsches Gesetz",
                    category: "‚ö° Physik-Formeln",
                    displayFormula: () => `U = R ${MUL} I`,
                    variables: ["R", "I"],
                    getInitialState: (target) => createState(['U'], [], ['R', 'I'], [], target)
                }
            ],
            medium: [
                {
                    name: "Quadrat (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${sup('a','2')}`,
                    variables: ["a"],
                    getInitialState: (target) => createState(['A'], [], ['a¬≤'], [], 'a¬≤'),
                    needsSqrtAtEnd: true
                },
                {
                    name: "Kreis (Fl√§che)",
                    category: "üìê Ebene Figuren",
                    displayFormula: () => `A = ${PI} ${MUL} ${sup('r','2')}`,
                    variables: ["r"],
                    getInitialState: (target) => createState(['A'], [], ['œÄ', 'r¬≤'], [], 'r¬≤'),
                    needsSqrtAtEnd: true
                },
                {
                    name: "Pythagoras (c)",
                    category: "üìê Satz des Pythagoras",
                    displayFormula: () => `${sup('c','2')} = ${sup('a','2')} + ${sup('b','2')}`,
                    variables: ["c"],
                    useOldSystem: true,
                    allowedOps: ['sqrt', 'pow2'],
                    getSteps: function(target) {
                        return {
                            start: { left: sup(hl('c'),'2'), right: `${sup('a','2')} + ${sup('b','2')}` },
                            steps: [{ op: `‚àö`, opId: 'sqrt', left: hl('c'), right: sqrt(`${sup('a','2')} + ${sup('b','2')}`) }]
                        };
                    }
                },
                {
                    name: "Zylinder (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${PI} ${MUL} ${sup('r','2')} ${MUL} h`,
                    variables: ["r", "h"],
                    getInitialState: (target) => {
                        if (target === 'h') {
                            return createState(['V'], [], ['œÄ', 'r¬≤', 'h'], [], 'h');
                        }
                        return createState(['V'], [], ['œÄ', 'r¬≤', 'h'], [], 'r¬≤');
                    },
                    needsSqrtAtEnd: true
                }
            ],
            hard: [
                {
                    name: "Kugel (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${frac('4', '3')} ${MUL} ${PI} ${MUL} ${sup('r','3')}`,
                    variables: ["r"],
                    getInitialState: (target) => createState(['V'], [], ['4', 'œÄ', 'r¬≥'], ['3'], 'r¬≥'),
                    needsCbrtAtEnd: true
                },
                {
                    name: "Kegel (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${frac('1', '3')} ${MUL} ${PI} ${MUL} ${sup('r','2')} ${MUL} h`,
                    variables: ["r", "h"],
                    getInitialState: (target) => {
                        if (target === 'h') {
                            return createState(['V'], [], ['œÄ', 'r¬≤', 'h'], ['3'], 'h');
                        }
                        return createState(['V'], [], ['œÄ', 'r¬≤', 'h'], ['3'], 'r¬≤');
                    },
                    needsSqrtAtEnd: true
                },
                {
                    name: "Pyramide (Volumen)",
                    category: "üì¶ K√∂rper & Volumen",
                    displayFormula: () => `V = ${frac('1', '3')} ${MUL} G ${MUL} h`,
                    variables: ["G", "h"],
                    getInitialState: (target) => createState(['V'], [], ['G', 'h'], ['3'], target)
                },
                {
                    name: "Kinetische Energie",
                    category: "‚ö° Physik-Formeln",
                    displayFormula: () => `E = ${frac('1', '2')} ${MUL} m ${MUL} ${sup('v','2')}`,
                    variables: ["m", "v"],
                    getInitialState: (target) => {
                        if (target === 'm') {
                            return createState(['E'], [], ['m', 'v¬≤'], ['2'], 'm');
                        }
                        return createState(['E'], [], ['m', 'v¬≤'], ['2'], 'v¬≤');
                    },
                    needsSqrtAtEnd: true
                }
            ]
        };

        // ========== UNDERSTAND TAB ==========
        const understandFormulas = [
            {
                name: "Rechteck (Fl√§che)",
                formula: "A = a ¬∑ b",
                targets: {
                    'a': [
                        { left: 'A', right: 'a ¬∑ b', op: '', desc: 'Ausgangsformel' },
                        { left: frac('A', 'b'), right: 'a', op: ': b', desc: 'Beide Seiten durch b teilen' },
                        { left: 'a', right: frac('A', 'b'), op: '', desc: 'Seiten tauschen ‚Üí Fertig!' }
                    ],
                    'b': [
                        { left: 'A', right: 'a ¬∑ b', op: '', desc: 'Ausgangsformel' },
                        { left: frac('A', 'a'), right: 'b', op: ': a', desc: 'Beide Seiten durch a teilen' },
                        { left: 'b', right: frac('A', 'a'), op: '', desc: 'Seiten tauschen ‚Üí Fertig!' }
                    ]
                }
            },
            {
                name: "Kreis (Umfang)",
                formula: "U = 2 ¬∑ œÄ ¬∑ r",
                targets: {
                    'r': [
                        { left: 'U', right: '2 ¬∑ œÄ ¬∑ r', op: '', desc: 'Ausgangsformel' },
                        { left: frac('U', '2'), right: 'œÄ ¬∑ r', op: ': 2', desc: 'Beide Seiten durch 2 teilen' },
                        { left: frac('U', '2 ¬∑ œÄ'), right: 'r', op: ': œÄ', desc: 'Beide Seiten durch œÄ teilen' },
                        { left: 'r', right: frac('U', '2 ¬∑ œÄ'), op: '', desc: 'Seiten tauschen ‚Üí Fertig!' }
                    ]
                }
            },
            {
                name: "Kreis (Fl√§che)",
                formula: "A = œÄ ¬∑ r¬≤",
                targets: {
                    'r': [
                        { left: 'A', right: 'œÄ ¬∑ r¬≤', op: '', desc: 'Ausgangsformel' },
                        { left: frac('A', 'œÄ'), right: 'r¬≤', op: ': œÄ', desc: 'Beide Seiten durch œÄ teilen' },
                        { left: sqrt(frac('A', 'œÄ')), right: 'r', op: '‚àö', desc: 'Wurzel ziehen' },
                        { left: 'r', right: sqrt(frac('A', 'œÄ')), op: '', desc: 'Seiten tauschen ‚Üí Fertig!' }
                    ]
                }
            },
            {
                name: "Pythagoras",
                formula: "c¬≤ = a¬≤ + b¬≤",
                targets: {
                    'c': [
                        { left: 'c¬≤', right: 'a¬≤ + b¬≤', op: '', desc: 'Ausgangsformel' },
                        { left: 'c', right: sqrt('a¬≤ + b¬≤'), op: '‚àö', desc: 'Wurzel ziehen ‚Üí Fertig!' }
                    ],
                    'a': [
                        { left: 'c¬≤', right: 'a¬≤ + b¬≤', op: '', desc: 'Ausgangsformel' },
                        { left: 'c¬≤ ‚àí b¬≤', right: 'a¬≤', op: '‚àí b¬≤', desc: 'b¬≤ auf beiden Seiten abziehen' },
                        { left: sqrt('c¬≤ ‚àí b¬≤'), right: 'a', op: '‚àö', desc: 'Wurzel ziehen' },
                        { left: 'a', right: sqrt('c¬≤ ‚àí b¬≤'), op: '', desc: 'Seiten tauschen ‚Üí Fertig!' }
                    ]
                }
            }
        ];

        let understandState = {
            formulaIndex: 0,
            targetIndex: 0,
            stepIndex: 0,
            showOp: false  // Zeigt an, ob die Operation f√ºr den n√§chsten Schritt sichtbar ist
        };

        function initUnderstand() {
            selectUnderstandFormula(0, document.querySelector('#understand-formula-select .topic-btn'));
        }

        function selectUnderstandFormula(index, btn) {
            document.querySelectorAll('#understand-formula-select .topic-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            understandState.formulaIndex = index;
            understandState.targetIndex = 0;
            understandState.stepIndex = 0;
            understandState.showOp = false;
            
            updateUnderstandTargets();
            renderUnderstandStep();
        }

        function updateUnderstandTargets() {
            const formula = understandFormulas[understandState.formulaIndex];
            const targets = Object.keys(formula.targets);
            const container = document.getElementById('understand-target-select');
            
            container.innerHTML = '<span style="color: #666; margin-right: 8px;">Aufl√∂sen nach:</span>';
            targets.forEach((target, idx) => {
                const btn = document.createElement('button');
                btn.className = 'level-btn' + (idx === 0 ? ' active' : '');
                btn.textContent = target;
                btn.onclick = () => selectUnderstandTarget(idx, btn);
                container.appendChild(btn);
            });
        }

        function selectUnderstandTarget(index, btn) {
            document.querySelectorAll('#understand-target-select .level-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            understandState.targetIndex = index;
            understandState.stepIndex = 0;
            understandState.showOp = false;
            renderUnderstandStep();
        }

        function renderUnderstandStep() {
            const formula = understandFormulas[understandState.formulaIndex];
            const targets = Object.keys(formula.targets);
            const target = targets[understandState.targetIndex];
            const steps = formula.targets[target];
            const currentStep = understandState.stepIndex;
            const showOp = understandState.showOp;
            
            const container = document.getElementById('understand-demo');
            
            let html = `<div class="steps-section"><div class="steps-title">Schritte zum Aufl√∂sen nach ${target}:</div><div class="steps-list">`;
            
            for (let i = 0; i <= currentStep && i < steps.length; i++) {
                const step = steps[i];
                const nextStep = (i + 1 < steps.length) ? steps[i + 1] : null;
                
                // Operation anzeigen:
                // - Bei allen Schritten VOR dem aktuellen: immer die n√§chste Op zeigen
                // - Beim aktuellen Schritt: nur wenn showOp true ist
                let opToShow = '';
                if (i < currentStep && nextStep) {
                    opToShow = nextStep.op;
                } else if (i === currentStep && showOp && nextStep) {
                    opToShow = nextStep.op;
                }
                
                html += `
                    <div class="step-item">
                        <div class="step-num">${i}</div>
                        <div class="step-left">${step.left}</div>
                        <div class="step-equals">=</div>
                        <div class="step-right">${step.right}</div>
                        <div class="step-divider">${opToShow ? '|' : ''}</div>
                        <div class="step-op">${opToShow}</div>
                    </div>
                `;
            }
            
            html += '</div></div>';
            
            // Beschreibung anpassen je nach Phase
            const step = steps[currentStep];
            const nextStep = (currentStep + 1 < steps.length) ? steps[currentStep + 1] : null;
            
            let desc;
            if (showOp && nextStep) {
                // Operation wird gezeigt - zeige die Beschreibung des n√§chsten Schritts
                desc = `<strong>‚Üí ${nextStep.desc.replace(' ‚Üí Fertig!', '')}</strong>`;
            } else {
                desc = step.desc;
            }
            
            html += `<div class="feedback" style="margin-top: 16px; color: #666;">${desc}</div>`;
            
            container.innerHTML = html;
            
            // Button-Sichtbarkeit steuern
            const prevBtn = document.getElementById('understand-prev-btn');
            const nextBtn = document.getElementById('understand-next-btn');
            
            // Zur√ºck ausblenden wenn ganz am Anfang (Schritt 0 ohne Operation)
            const isAtStart = currentStep === 0 && !showOp;
            prevBtn.style.display = isAtStart ? 'none' : '';
            
            // Weiter ausblenden wenn ganz am Ende (letzter Schritt)
            const isAtEnd = currentStep === steps.length - 1;
            nextBtn.style.display = isAtEnd ? 'none' : '';
        }

        function understandNextStep() {
            const formula = understandFormulas[understandState.formulaIndex];
            const targets = Object.keys(formula.targets);
            const target = targets[understandState.targetIndex];
            const steps = formula.targets[target];
            
            const currentStep = understandState.stepIndex;
            const nextStep = (currentStep + 1 < steps.length) ? steps[currentStep + 1] : null;
            
            if (!understandState.showOp && nextStep && nextStep.op) {
                // Phase 1: Zeige erst die Operation
                understandState.showOp = true;
                renderUnderstandStep();
            } else if (understandState.stepIndex < steps.length - 1) {
                // Phase 2: Gehe zum n√§chsten Schritt
                understandState.stepIndex++;
                understandState.showOp = false;
                renderUnderstandStep();
            }
        }

        function understandPrevStep() {
            if (understandState.showOp) {
                // Wenn Operation sichtbar: erst Operation ausblenden
                understandState.showOp = false;
                renderUnderstandStep();
            } else if (understandState.stepIndex > 0) {
                // Zur√ºck zum vorherigen Schritt
                understandState.stepIndex--;
                
                // Pr√ºfen ob der vorherige Schritt eine Operation hat
                const formula = understandFormulas[understandState.formulaIndex];
                const targets = Object.keys(formula.targets);
                const target = targets[understandState.targetIndex];
                const steps = formula.targets[target];
                const currentStep = understandState.stepIndex;
                const nextStep = (currentStep + 1 < steps.length) ? steps[currentStep + 1] : null;
                
                // Wenn es eine Operation gibt, zeige sie (da wir von weiter vorne kommen)
                if (nextStep && nextStep.op) {
                    understandState.showOp = true;
                }
                
                renderUnderstandStep();
            }
        }

        // ========== PRACTICE TAB ==========
        const practiceState = {
            initialized: false,
            score: 0,
            streak: 0,
            topic: 'all',
            difficulty: 'easy',
            currentFormula: null,
            currentTarget: null,
            currentState: null,
            currentSteps: null,
            stepIndex: 0,
            stepsHistory: []
        };

        function initPractice() {
            practiceState.initialized = true;
            generatePracticeTask();
        }

        function selectPracticeTopic(topic, btn) {
            document.querySelectorAll('#tab-practice .topic-select .topic-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            practiceState.topic = topic;
            generatePracticeTask();
        }

        function selectPracticeDifficulty(diff, btn) {
            document.querySelectorAll('#tab-practice .level-select .level-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            practiceState.difficulty = diff;
            generatePracticeTask();
        }

        function generatePracticeTask() {
            document.getElementById('practice-success').style.display = 'none';
            document.getElementById('practice-game-area').style.display = 'block';
            document.getElementById('practice-next-btn').style.display = 'none';
            document.getElementById('practice-feedback').textContent = '';
            document.getElementById('practice-feedback').className = 'feedback';
            
            // Operations und √úberspringen-Button wieder einblenden
            document.querySelector('#practice-game-area .operations-section').style.display = '';
            document.querySelector('#practice-game-area .button-row .action-btn:first-child').style.display = '';
            
            let formulas = formulasByDifficulty[practiceState.difficulty];
            
            if (practiceState.topic !== 'all') {
                formulas = formulas.filter(f => f.category === practiceState.topic);
            }
            
            if (formulas.length === 0) {
                formulas = formulasByDifficulty[practiceState.difficulty];
            }
            
            const formula = formulas[Math.floor(Math.random() * formulas.length)];
            const target = formula.variables[Math.floor(Math.random() * formula.variables.length)];
            
            practiceState.currentFormula = formula;
            practiceState.currentTarget = target;
            practiceState.stepIndex = 0;
            practiceState.stepsHistory = [];
            
            if (formula.getInitialState && !formula.useOldSystem) {
                practiceState.currentState = formula.getInitialState(target);
                practiceState.currentSteps = null;
            } else if (formula.getSteps) {
                practiceState.currentSteps = formula.getSteps(target);
                practiceState.currentState = null;
            }
            
            document.getElementById('practice-formula-name').textContent = formula.name;
            document.getElementById('practice-formula-category').textContent = formula.category;
            document.getElementById('practice-target').textContent = getBaseVariable(target);
            
            updatePracticeEquation();
            renderPracticeOperations();
            resetPracticeSteps();
        }

        function updatePracticeEquation() {
            const left = document.getElementById('practice-left-side');
            const right = document.getElementById('practice-right-side');
            
            if (practiceState.currentState) {
                left.innerHTML = renderSide(practiceState.currentState.leftNum, practiceState.currentState.leftDen, practiceState.currentState.target);
                right.innerHTML = renderSide(practiceState.currentState.rightNum, practiceState.currentState.rightDen, practiceState.currentState.target);
            } else if (practiceState.currentSteps) {
                if (practiceState.stepIndex === 0) {
                    left.innerHTML = practiceState.currentSteps.start.left;
                    right.innerHTML = practiceState.currentSteps.start.right;
                } else {
                    const step = practiceState.currentSteps.steps[practiceState.stepIndex - 1];
                    left.innerHTML = step.left;
                    right.innerHTML = step.right;
                }
            }
        }

        function renderPracticeOperations() {
            const container = document.getElementById('practice-op-buttons');
            container.innerHTML = '';
            
            if (practiceState.currentState) {
                const state = practiceState.currentState;
                const allFactors = [...new Set([...state.leftNum, ...state.leftDen, ...state.rightNum, ...state.rightDen])];
                
                // Faktoren paarweise darstellen (: und ¬∑ √ºbereinander)
                allFactors.forEach(f => {
                    if (!f.endsWith('¬≤') && !f.endsWith('¬≥')) {
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        
                        const divBtn = document.createElement('button');
                        divBtn.className = 'op-btn';
                        divBtn.innerHTML = `: ${renderFactor(f)}`;
                        divBtn.onclick = () => handlePracticeOperation('div_' + f, divBtn);
                        
                        const mulBtn = document.createElement('button');
                        mulBtn.className = 'op-btn';
                        mulBtn.innerHTML = `${MUL} ${renderFactor(f)}`;
                        mulBtn.onclick = () => handlePracticeOperation('mul_' + f, mulBtn);
                        
                        pair.appendChild(divBtn);
                        pair.appendChild(mulBtn);
                        container.appendChild(pair);
                    }
                });
                
                // Wurzel-Operationen (immer als Paar mit Quadrat)
                if (state.target.endsWith('¬≤') || practiceState.currentFormula.needsSqrtAtEnd) {
                    const pair = document.createElement('div');
                    pair.className = 'op-pair';
                    
                    const sqrtBtn = document.createElement('button');
                    sqrtBtn.className = 'op-btn';
                    sqrtBtn.innerHTML = '‚àö';
                    sqrtBtn.onclick = () => handlePracticeOperation('sqrt', sqrtBtn);
                    
                    const powBtn = document.createElement('button');
                    powBtn.className = 'op-btn';
                    powBtn.innerHTML = '¬≤';
                    powBtn.onclick = () => handlePracticeOperation('pow2', powBtn);
                    
                    pair.appendChild(sqrtBtn);
                    pair.appendChild(powBtn);
                    container.appendChild(pair);
                }
                if (state.target.endsWith('¬≥') || practiceState.currentFormula.needsCbrtAtEnd) {
                    const pair = document.createElement('div');
                    pair.className = 'op-pair';
                    
                    const cbrtBtn = document.createElement('button');
                    cbrtBtn.className = 'op-btn';
                    cbrtBtn.innerHTML = '‚àõ';
                    cbrtBtn.onclick = () => handlePracticeOperation('cbrt', cbrtBtn);
                    
                    const powBtn = document.createElement('button');
                    powBtn.className = 'op-btn';
                    powBtn.innerHTML = '¬≥';
                    powBtn.onclick = () => handlePracticeOperation('pow3', powBtn);
                    
                    pair.appendChild(cbrtBtn);
                    pair.appendChild(powBtn);
                    container.appendChild(pair);
                }
            } else if (practiceState.currentSteps && practiceState.currentFormula.allowedOps) {
                // F√ºr Formeln mit vordefinierten Schritten (wie Pythagoras)
                const ops = practiceState.currentFormula.allowedOps;
                const processed = new Set();
                
                ops.forEach(opId => {
                    if (processed.has(opId)) return;
                    
                    // Wurzel und Quadrat als Paar
                    if (opId === 'sqrt' || opId === 'pow2') {
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        
                        const sqrtBtn = document.createElement('button');
                        sqrtBtn.className = 'op-btn';
                        sqrtBtn.innerHTML = '‚àö';
                        sqrtBtn.onclick = () => handlePracticeOperation('sqrt', sqrtBtn);
                        
                        const powBtn = document.createElement('button');
                        powBtn.className = 'op-btn';
                        powBtn.innerHTML = '¬≤';
                        powBtn.onclick = () => handlePracticeOperation('pow2', powBtn);
                        
                        pair.appendChild(sqrtBtn);
                        pair.appendChild(powBtn);
                        container.appendChild(pair);
                        
                        processed.add('sqrt');
                        processed.add('pow2');
                    }
                    // Kubikwurzel und Kubik als Paar
                    else if (opId === 'cbrt' || opId === 'pow3') {
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        
                        const cbrtBtn = document.createElement('button');
                        cbrtBtn.className = 'op-btn';
                        cbrtBtn.innerHTML = '‚àõ';
                        cbrtBtn.onclick = () => handlePracticeOperation('cbrt', cbrtBtn);
                        
                        const powBtn = document.createElement('button');
                        powBtn.className = 'op-btn';
                        powBtn.innerHTML = '¬≥';
                        powBtn.onclick = () => handlePracticeOperation('pow3', powBtn);
                        
                        pair.appendChild(cbrtBtn);
                        pair.appendChild(powBtn);
                        container.appendChild(pair);
                        
                        processed.add('cbrt');
                        processed.add('pow3');
                    }
                    // Andere Operationen einzeln
                    else {
                        let label = opId;
                        if (opId.startsWith('div_')) label = `: ${opId.replace('div_', '')}`;
                        else if (opId.startsWith('mul_')) label = `${MUL} ${opId.replace('mul_', '')}`;
                        else if (opId.startsWith('sub_')) label = `‚àí ${opId.replace('sub_', '')}`;
                        else if (opId.startsWith('add_')) label = `+ ${opId.replace('add_', '')}`;
                        
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        const btn = document.createElement('button');
                        btn.className = 'op-btn';
                        btn.innerHTML = label;
                        btn.onclick = () => handlePracticeOperation(opId, btn);
                        pair.appendChild(btn);
                        container.appendChild(pair);
                        
                        processed.add(opId);
                    }
                });
            }
        }

        function handlePracticeOperation(opId, btn) {
            if (practiceState.currentState) {
                const isHelpful = isOperationHelpful(practiceState.currentState, opId, practiceState.currentFormula);
                
                if (isHelpful) {
                    btn.classList.add('correct');
                    
                    const oldState = cloneState(practiceState.currentState);
                    practiceState.currentState = applyOpToState(practiceState.currentState, opId);
                    
                    addPracticeStep(opId);
                    practiceState.stepIndex++;
                    updatePracticeEquation();
                    renderPracticeOperations();
                    
                    setTimeout(() => {
                        btn.classList.remove('correct');
                        
                        if (needsSqrtStep(practiceState.currentState, practiceState.currentFormula)) {
                        } else if (needsCbrtStep(practiceState.currentState, practiceState.currentFormula)) {
                        } else if (isStateSolved(practiceState.currentState)) {
                            setTimeout(() => practiceSuccess(), 600);
                        }
                    }, 300);
                } else {
                    btn.classList.add('wrong');
                    practiceState.streak = 0;
                    practiceState.score = Math.max(0, practiceState.score - 10);
                    updatePracticeStats();
                    setTimeout(() => btn.classList.remove('wrong'), 400);
                }
            } else if (practiceState.currentSteps) {
                const correctOp = practiceState.currentSteps.steps[practiceState.stepIndex].opId;
                
                if (opId === correctOp) {
                    btn.classList.add('correct');
                    addPracticeStep(opId);
                    practiceState.stepIndex++;
                    updatePracticeEquation();
                    
                    setTimeout(() => {
                        btn.classList.remove('correct');
                        if (practiceState.stepIndex >= practiceState.currentSteps.steps.length) {
                            setTimeout(() => practiceSuccess(), 600);
                        }
                    }, 300);
                } else {
                    btn.classList.add('wrong');
                    practiceState.streak = 0;
                    practiceState.score = Math.max(0, practiceState.score - 10);
                    updatePracticeStats();
                    setTimeout(() => btn.classList.remove('wrong'), 400);
                }
            }
        }

        function addPracticeStep(opId) {
            const list = document.getElementById('practice-steps-list');
            const stepNum = practiceState.stepIndex;
            
            let opLabel = opId;
            if (opId === 'sqrt') opLabel = '‚àö';
            else if (opId === 'cbrt') opLabel = '‚àõ';
            else if (opId.startsWith('div_')) opLabel = `: ${opId.replace('div_', '')}`;
            else if (opId.startsWith('mul_')) opLabel = `${MUL} ${opId.replace('mul_', '')}`;
            
            const prevStep = list.lastElementChild;
            if (prevStep) {
                const prevOp = prevStep.querySelector('.step-op');
                const prevDivider = prevStep.querySelector('.step-divider');
                if (prevOp) prevOp.innerHTML = opLabel;
                if (prevDivider) prevDivider.textContent = '|';
            }
            
            let leftHtml, rightHtml;
            if (practiceState.currentState) {
                leftHtml = renderSide(practiceState.currentState.leftNum, practiceState.currentState.leftDen, practiceState.currentState.target);
                rightHtml = renderSide(practiceState.currentState.rightNum, practiceState.currentState.rightDen, practiceState.currentState.target);
            } else if (practiceState.currentSteps && practiceState.stepIndex < practiceState.currentSteps.steps.length) {
                const step = practiceState.currentSteps.steps[practiceState.stepIndex];
                leftHtml = step.left;
                rightHtml = step.right;
            }
            
            const div = document.createElement('div');
            div.className = 'step-item';
            div.innerHTML = `
                <div class="step-num">${stepNum + 1}</div>
                <div class="step-left">${leftHtml}</div>
                <div class="step-equals">=</div>
                <div class="step-right">${rightHtml}</div>
                <div class="step-divider"></div>
                <div class="step-op"></div>
            `;
            list.appendChild(div);
        }

        function resetPracticeSteps() {
            const list = document.getElementById('practice-steps-list');
            
            let leftHtml, rightHtml;
            if (practiceState.currentState) {
                leftHtml = renderSide(practiceState.currentState.leftNum, practiceState.currentState.leftDen, practiceState.currentState.target);
                rightHtml = renderSide(practiceState.currentState.rightNum, practiceState.currentState.rightDen, practiceState.currentState.target);
            } else if (practiceState.currentSteps) {
                leftHtml = practiceState.currentSteps.start.left;
                rightHtml = practiceState.currentSteps.start.right;
            }
            
            list.innerHTML = `
                <div class="step-item">
                    <div class="step-num">0</div>
                    <div class="step-left">${leftHtml}</div>
                    <div class="step-equals">=</div>
                    <div class="step-right">${rightHtml}</div>
                    <div class="step-divider"></div>
                    <div class="step-op"></div>
                </div>
            `;
        }

        function practiceSuccess() {
            practiceState.streak++;
            const points = 100 + (practiceState.streak - 1) * 25;
            practiceState.score += points;
            
            updatePracticeStats();
            
            // Operations ausblenden, aber Schritte sichtbar lassen
            document.querySelector('#practice-game-area .operations-section').style.display = 'none';
            
            // Erfolgsmeldung im Feedback-Bereich anzeigen
            const feedback = document.getElementById('practice-feedback');
            feedback.className = 'feedback success-inline';
            feedback.innerHTML = `
                <div class="success-inline-content">
                    <span class="success-inline-icon">üéâ</span>
                    <span class="success-inline-text">Richtig gel√∂st!</span>
                    <span class="success-inline-points">+${points} Punkte</span>
                    ${practiceState.streak >= 2 ? `<span class="success-inline-streak">üî• ${practiceState.streak} Streak</span>` : ''}
                </div>
            `;
            
            // Buttons umschalten
            document.querySelector('#practice-game-area .button-row .action-btn:first-child').style.display = 'none';
            document.getElementById('practice-next-btn').style.display = '';
        }

        function continuePractice() {
            generatePracticeTask();
        }

        function skipPracticeTask() {
            practiceState.streak = 0;
            updatePracticeStats();
            generatePracticeTask();
        }

        function updatePracticeStats() {
            document.getElementById('practice-score').textContent = practiceState.score;
            document.getElementById('practice-streak').textContent = practiceState.streak;
            
            const fire = document.getElementById('practice-streak-fire');
            if (practiceState.streak >= 3) {
                fire.style.display = 'inline';
            } else {
                fire.style.display = 'none';
            }
        }

        // ========== HINT ==========
        function toggleHint() {
            const popup = document.getElementById('hint-popup');
            if (popup.classList.contains('show')) {
                popup.classList.remove('show');
            } else {
                let hint = 'üí° ';
                
                if (practiceState.currentState) {
                    if (needsSqrtStep(practiceState.currentState, practiceState.currentFormula)) {
                        hint += 'Zieh die Quadratwurzel!';
                    } else if (needsCbrtStep(practiceState.currentState, practiceState.currentFormula)) {
                        hint += 'Zieh die Kubikwurzel!';
                    } else {
                        const allOpIds = [];
                        const state = practiceState.currentState;
                        const allFactors = [...new Set([...state.leftNum, ...state.leftDen, ...state.rightNum, ...state.rightDen])];
                        allFactors.forEach(f => {
                            if (!f.endsWith('¬≤') && !f.endsWith('¬≥')) {
                                allOpIds.push('div_' + f);
                                allOpIds.push('mul_' + f);
                            }
                        });
                        
                        const helpfulOps = allOpIds.filter(opId => isOperationHelpful(state, opId, practiceState.currentFormula));
                        
                        if (helpfulOps.length > 0) {
                            const randomOp = helpfulOps[Math.floor(Math.random() * helpfulOps.length)];
                            if (randomOp.startsWith('div_')) {
                                hint += 'Versuch mal zu teilen!';
                            } else if (randomOp.startsWith('mul_')) {
                                hint += 'Versuch mal zu multiplizieren!';
                            }
                        } else {
                            hint += 'Schau dir die Faktoren genau an!';
                        }
                    }
                } else if (practiceState.currentSteps && practiceState.stepIndex < practiceState.currentSteps.steps.length) {
                    const correctOp = practiceState.currentSteps.steps[practiceState.stepIndex].opId;
                    if (correctOp.includes('div')) hint += 'Versuch mal zu teilen!';
                    else if (correctOp.includes('mul')) hint += 'Versuch mal zu multiplizieren!';
                    else if (correctOp.includes('sqrt') || correctOp.includes('cbrt')) hint += 'Zieh eine Wurzel!';
                    else if (correctOp.includes('sub')) hint += 'Versuch mal zu subtrahieren!';
                    else hint += 'Welche Umkehroperation brauchst du?';
                }
                
                popup.textContent = hint;
                popup.classList.add('show');
            }
        }

        // ========== EXAM TAB ==========
        const examState = {
            tasks: [],
            currentTask: 0,
            answers: [],
            timerInterval: null,
            timeRemaining: 300,
            started: false,
            currentState: null,
            currentSteps: null,
            stepIndex: 0,
            history: [],
            historyIndex: -1
        };

        function generateExamTasks() {
            examState.tasks = [];
            const allFormulas = [
                ...formulasByDifficulty.easy,
                ...formulasByDifficulty.medium,
                ...formulasByDifficulty.hard
            ];
            
            for (let i = 0; i < 10; i++) {
                const formula = allFormulas[Math.floor(Math.random() * allFormulas.length)];
                const target = formula.variables[Math.floor(Math.random() * formula.variables.length)];
                examState.tasks.push({ formula, target, completed: false, correct: false });
            }
        }

        function startExam() {
            generateExamTasks();
            examState.currentTask = 0;
            examState.timeRemaining = 300;
            examState.started = true;
            
            document.getElementById('exam-start').style.display = 'none';
            document.getElementById('exam-results').style.display = 'none';
            document.getElementById('exam-active').style.display = 'block';
            
            loadExamTask();
            
            examState.timerInterval = setInterval(updateExamTimer, 1000);
        }

        function loadExamTask() {
            if (examState.currentTask >= 10) {
                endExam();
                return;
            }
            
            const task = examState.tasks[examState.currentTask];
            const formula = task.formula;
            const target = task.target;
            
            examState.stepIndex = 0;
            examState.history = [];
            examState.historyIndex = -1;
            
            if (formula.getInitialState && !formula.useOldSystem) {
                examState.currentState = formula.getInitialState(target);
                examState.currentSteps = null;
            } else if (formula.getSteps) {
                examState.currentSteps = formula.getSteps(target);
                examState.currentState = null;
            }
            
            document.getElementById('exam-current').textContent = examState.currentTask + 1;
            document.getElementById('exam-formula-name').textContent = formula.name;
            document.getElementById('exam-formula-category').textContent = formula.category;
            document.getElementById('exam-target').textContent = getBaseVariable(target);
            
            // Button-Text f√ºr letzte Aufgabe √§ndern
            const nextBtn = document.getElementById('exam-next-btn');
            if (examState.currentTask >= 9) {
                nextBtn.textContent = 'Pr√ºfung abschlie√üen ‚úì';
            } else {
                nextBtn.textContent = 'N√§chste Aufgabe ‚Üí';
            }
            
            updateExamEquation();
            renderExamOperations();
            resetExamSteps();
            updateExamUndoRedo();
        }

        function updateExamEquation() {
            const left = document.getElementById('exam-left-side');
            const right = document.getElementById('exam-right-side');
            
            if (examState.currentState) {
                left.innerHTML = renderSide(examState.currentState.leftNum, examState.currentState.leftDen, examState.currentState.target);
                right.innerHTML = renderSide(examState.currentState.rightNum, examState.currentState.rightDen, examState.currentState.target);
            } else if (examState.currentSteps) {
                if (examState.stepIndex === 0) {
                    left.innerHTML = examState.currentSteps.start.left;
                    right.innerHTML = examState.currentSteps.start.right;
                } else {
                    const step = examState.currentSteps.steps[examState.stepIndex - 1];
                    left.innerHTML = step.left;
                    right.innerHTML = step.right;
                }
            }
        }

        function renderExamOperations() {
            const container = document.getElementById('exam-op-buttons');
            container.innerHTML = '';
            
            const task = examState.tasks[examState.currentTask];
            const formula = task.formula;
            
            if (examState.currentState) {
                const state = examState.currentState;
                const allFactors = [...new Set([...state.leftNum, ...state.leftDen, ...state.rightNum, ...state.rightDen])];
                
                // Alle Faktoren anzeigen (auch quadrierte)
                allFactors.forEach(f => {
                    const pair = document.createElement('div');
                    pair.className = 'op-pair';
                    
                    const divBtn = document.createElement('button');
                    divBtn.className = 'op-btn';
                    divBtn.innerHTML = `: ${renderFactor(f)}`;
                    divBtn.onclick = () => handleExamOperation('div_' + f, divBtn);
                    
                    const mulBtn = document.createElement('button');
                    mulBtn.className = 'op-btn';
                    mulBtn.innerHTML = `${MUL} ${renderFactor(f)}`;
                    mulBtn.onclick = () => handleExamOperation('mul_' + f, mulBtn);
                    
                    pair.appendChild(divBtn);
                    pair.appendChild(mulBtn);
                    container.appendChild(pair);
                });
                
                // Wurzel/Quadrat immer anzeigen wenn quadrierte Faktoren vorhanden
                const hasSquared = allFactors.some(f => f.endsWith('¬≤'));
                if (hasSquared || state.target.endsWith('¬≤') || formula.needsSqrtAtEnd) {
                    const pair = document.createElement('div');
                    pair.className = 'op-pair';
                    
                    const sqrtBtn = document.createElement('button');
                    sqrtBtn.className = 'op-btn';
                    sqrtBtn.innerHTML = '‚àö';
                    sqrtBtn.onclick = () => handleExamOperation('sqrt', sqrtBtn);
                    
                    const powBtn = document.createElement('button');
                    powBtn.className = 'op-btn';
                    powBtn.innerHTML = '¬≤';
                    powBtn.onclick = () => handleExamOperation('pow2', powBtn);
                    
                    pair.appendChild(sqrtBtn);
                    pair.appendChild(powBtn);
                    container.appendChild(pair);
                }
                
                // Kubikwurzel/Kubik wenn kubische Faktoren vorhanden
                const hasCubed = allFactors.some(f => f.endsWith('¬≥'));
                if (hasCubed || state.target.endsWith('¬≥') || formula.needsCbrtAtEnd) {
                    const pair = document.createElement('div');
                    pair.className = 'op-pair';
                    
                    const cbrtBtn = document.createElement('button');
                    cbrtBtn.className = 'op-btn';
                    cbrtBtn.innerHTML = '‚àõ';
                    cbrtBtn.onclick = () => handleExamOperation('cbrt', cbrtBtn);
                    
                    const powBtn = document.createElement('button');
                    powBtn.className = 'op-btn';
                    powBtn.innerHTML = '¬≥';
                    powBtn.onclick = () => handleExamOperation('pow3', powBtn);
                    
                    pair.appendChild(cbrtBtn);
                    pair.appendChild(powBtn);
                    container.appendChild(pair);
                }
            } else if (examState.currentSteps && formula.allowedOps) {
                // F√ºr Formeln mit vordefinierten Schritten (wie Pythagoras)
                const ops = formula.allowedOps;
                const processed = new Set();
                
                ops.forEach(opId => {
                    if (processed.has(opId)) return;
                    
                    // Wurzel und Quadrat als Paar
                    if (opId === 'sqrt' || opId === 'pow2') {
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        
                        const sqrtBtn = document.createElement('button');
                        sqrtBtn.className = 'op-btn';
                        sqrtBtn.innerHTML = '‚àö';
                        sqrtBtn.onclick = () => handleExamOperation('sqrt', sqrtBtn);
                        
                        const powBtn = document.createElement('button');
                        powBtn.className = 'op-btn';
                        powBtn.innerHTML = '¬≤';
                        powBtn.onclick = () => handleExamOperation('pow2', powBtn);
                        
                        pair.appendChild(sqrtBtn);
                        pair.appendChild(powBtn);
                        container.appendChild(pair);
                        
                        processed.add('sqrt');
                        processed.add('pow2');
                    }
                    // Kubikwurzel und Kubik als Paar
                    else if (opId === 'cbrt' || opId === 'pow3') {
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        
                        const cbrtBtn = document.createElement('button');
                        cbrtBtn.className = 'op-btn';
                        cbrtBtn.innerHTML = '‚àõ';
                        cbrtBtn.onclick = () => handleExamOperation('cbrt', cbrtBtn);
                        
                        const powBtn = document.createElement('button');
                        powBtn.className = 'op-btn';
                        powBtn.innerHTML = '¬≥';
                        powBtn.onclick = () => handleExamOperation('pow3', powBtn);
                        
                        pair.appendChild(cbrtBtn);
                        pair.appendChild(powBtn);
                        container.appendChild(pair);
                        
                        processed.add('cbrt');
                        processed.add('pow3');
                    }
                    // Andere Operationen einzeln
                    else {
                        let label = opId;
                        if (opId.startsWith('div_')) label = `: ${opId.replace('div_', '')}`;
                        else if (opId.startsWith('mul_')) label = `${MUL} ${opId.replace('mul_', '')}`;
                        
                        const pair = document.createElement('div');
                        pair.className = 'op-pair';
                        const btn = document.createElement('button');
                        btn.className = 'op-btn';
                        btn.innerHTML = label;
                        btn.onclick = () => handleExamOperation(opId, btn);
                        pair.appendChild(btn);
                        container.appendChild(pair);
                        
                        processed.add(opId);
                    }
                });
            }
        }

        function handleExamOperation(opId, btn) {
            const task = examState.tasks[examState.currentTask];
            const formula = task.formula;
            
            if (examState.currentState) {
                // History: alten State speichern bevor Operation angewendet wird
                // Alle Eintr√§ge nach aktuellem Index l√∂schen (f√ºr Redo-√úberschreibung)
                examState.history = examState.history.slice(0, examState.historyIndex + 1);
                examState.history.push({
                    state: cloneState(examState.currentState),
                    stepIndex: examState.stepIndex,
                    opId: opId
                });
                examState.historyIndex = examState.history.length - 1;
                
                // Operation anwenden
                examState.currentState = applyOpToState(examState.currentState, opId);
                
                addExamStep(opId);
                examState.stepIndex++;
                updateExamEquation();
                renderExamOperations();
                updateExamUndoRedo();
            } else if (examState.currentSteps) {
                const correctOp = examState.currentSteps.steps[examState.stepIndex].opId;
                
                if (opId === correctOp) {
                    addExamStep(opId);
                    examState.stepIndex++;
                    updateExamEquation();
                }
            }
        }
        
        function examUndo() {
            if (examState.historyIndex < 0 || examState.history.length === 0) return;
            
            // Zur√ºck zum vorherigen State
            const entry = examState.history[examState.historyIndex];
            examState.currentState = cloneState(entry.state);
            examState.stepIndex = entry.stepIndex;
            examState.historyIndex--;
            
            updateExamEquation();
            renderExamOperations();
            rebuildExamStepsFromHistory();
            updateExamUndoRedo();
        }
        
        function examRedo() {
            if (examState.historyIndex >= examState.history.length - 1) return;
            
            examState.historyIndex++;
            const entry = examState.history[examState.historyIndex];
            
            // Operation erneut anwenden
            examState.currentState = applyOpToState(cloneState(entry.state), entry.opId);
            examState.stepIndex = entry.stepIndex + 1;
            
            updateExamEquation();
            renderExamOperations();
            rebuildExamStepsFromHistory();
            updateExamUndoRedo();
        }
        
        function updateExamUndoRedo() {
            const undoBtn = document.getElementById('exam-undo-btn');
            const redoBtn = document.getElementById('exam-redo-btn');
            
            if (undoBtn) undoBtn.disabled = examState.historyIndex < 0;
            if (redoBtn) redoBtn.disabled = examState.historyIndex >= examState.history.length - 1;
        }
        
        function rebuildExamStepsFromHistory() {
            const list = document.getElementById('exam-steps-list');
            const task = examState.tasks[examState.currentTask];
            const formula = task.formula;
            
            // Initial state holen
            let initialState;
            if (formula.getInitialState && !formula.useOldSystem) {
                initialState = formula.getInitialState(task.target);
            }
            
            if (!initialState) return;
            
            const initialLeft = renderSide(initialState.leftNum, initialState.leftDen, initialState.target);
            const initialRight = renderSide(initialState.rightNum, initialState.rightDen, initialState.target);
            
            // Mit Ausgangsformel starten
            list.innerHTML = `
                <div class="step-item">
                    <div class="step-num">0</div>
                    <div class="step-left">${initialLeft}</div>
                    <div class="step-equals">=</div>
                    <div class="step-right">${initialRight}</div>
                    <div class="step-divider">${examState.historyIndex >= 0 ? '|' : ''}</div>
                    <div class="step-op">${examState.historyIndex >= 0 ? formatOpLabel(examState.history[0].opId) : ''}</div>
                </div>
            `;
            
            // Steps aus History aufbauen
            let currentState = cloneState(initialState);
            for (let i = 0; i <= examState.historyIndex; i++) {
                const entry = examState.history[i];
                currentState = applyOpToState(currentState, entry.opId);
                
                const leftHtml = renderSide(currentState.leftNum, currentState.leftDen, currentState.target);
                const rightHtml = renderSide(currentState.rightNum, currentState.rightDen, currentState.target);
                
                const nextOp = (i < examState.historyIndex && examState.history[i + 1]) 
                    ? formatOpLabel(examState.history[i + 1].opId) 
                    : '';
                const divider = nextOp ? '|' : '';
                
                const div = document.createElement('div');
                div.className = 'step-item';
                div.innerHTML = `
                    <div class="step-num">${i + 1}</div>
                    <div class="step-left">${leftHtml}</div>
                    <div class="step-equals">=</div>
                    <div class="step-right">${rightHtml}</div>
                    <div class="step-divider">${divider}</div>
                    <div class="step-op">${nextOp}</div>
                `;
                list.appendChild(div);
            }
        }
        
        function formatOpLabel(opId) {
            if (opId === 'sqrt') return '‚àö';
            if (opId === 'cbrt') return '‚àõ';
            if (opId === 'pow2') return '¬≤';
            if (opId === 'pow3') return '¬≥';
            if (opId.startsWith('div_')) {
                const factor = opId.replace('div_', '');
                return `: ${renderFactor(factor)}`;
            }
            if (opId.startsWith('mul_')) {
                const factor = opId.replace('mul_', '');
                return `${MUL} ${renderFactor(factor)}`;
            }
            return opId;
        }

        function nextExamTask() {
            const task = examState.tasks[examState.currentTask];
            const formula = task.formula;
            
            // User-Schritte speichern
            const stepsList = document.getElementById('exam-steps-list');
            task.userStepsHtml = stepsList.innerHTML;
            
            // Pr√ºfen ob die Aufgabe gel√∂st wurde
            let isSolved = false;
            if (examState.currentState) {
                isSolved = isStateSolved(examState.currentState) && 
                           !needsSqrtStep(examState.currentState, formula) && 
                           !needsCbrtStep(examState.currentState, formula);
            } else if (examState.currentSteps) {
                isSolved = examState.stepIndex >= examState.currentSteps.steps.length;
            }
            
            task.completed = true;
            task.correct = isSolved;
            
            examState.currentTask++;
            loadExamTask();
        }

        function addExamStep(opId) {
            const list = document.getElementById('exam-steps-list');
            
            const opLabel = formatOpLabel(opId);
            
            const prevStep = list.lastElementChild;
            if (prevStep) {
                const prevOp = prevStep.querySelector('.step-op');
                const prevDivider = prevStep.querySelector('.step-divider');
                if (prevOp) prevOp.innerHTML = opLabel;
                if (prevDivider) prevDivider.textContent = '|';
            }
            
            let leftHtml, rightHtml;
            if (examState.currentState) {
                leftHtml = renderSide(examState.currentState.leftNum, examState.currentState.leftDen, examState.currentState.target);
                rightHtml = renderSide(examState.currentState.rightNum, examState.currentState.rightDen, examState.currentState.target);
            } else if (examState.currentSteps && examState.stepIndex < examState.currentSteps.steps.length) {
                const step = examState.currentSteps.steps[examState.stepIndex];
                leftHtml = step.left;
                rightHtml = step.right;
            }
            
            const div = document.createElement('div');
            div.className = 'step-item';
            div.innerHTML = `
                <div class="step-num">${examState.stepIndex + 1}</div>
                <div class="step-left">${leftHtml}</div>
                <div class="step-equals">=</div>
                <div class="step-right">${rightHtml}</div>
                <div class="step-divider"></div>
                <div class="step-op"></div>
            `;
            list.appendChild(div);
        }

        function resetExamSteps() {
            const list = document.getElementById('exam-steps-list');
            
            let leftHtml, rightHtml;
            if (examState.currentState) {
                leftHtml = renderSide(examState.currentState.leftNum, examState.currentState.leftDen, examState.currentState.target);
                rightHtml = renderSide(examState.currentState.rightNum, examState.currentState.rightDen, examState.currentState.target);
            } else if (examState.currentSteps) {
                leftHtml = examState.currentSteps.start.left;
                rightHtml = examState.currentSteps.start.right;
            }
            
            list.innerHTML = `
                <div class="step-item">
                    <div class="step-num">0</div>
                    <div class="step-left">${leftHtml}</div>
                    <div class="step-equals">=</div>
                    <div class="step-right">${rightHtml}</div>
                    <div class="step-divider"></div>
                    <div class="step-op"></div>
                </div>
            `;
        }

        function updateExamTimer() {
            examState.timeRemaining--;
            
            const minutes = Math.floor(examState.timeRemaining / 60);
            const seconds = examState.timeRemaining % 60;
            const timerDisplay = document.getElementById('exam-timer');
            timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (examState.timeRemaining <= 60) {
                timerDisplay.classList.add('warning');
            }
            
            if (examState.timeRemaining <= 0) {
                endExam();
            }
        }

        function endExam() {
            clearInterval(examState.timerInterval);
            examState.started = false;
            
            document.getElementById('exam-active').style.display = 'none';
            document.getElementById('exam-results').style.display = 'block';
            
            const correct = examState.tasks.filter(t => t.correct).length;
            const percent = Math.round((correct / 10) * 100);
            
            document.getElementById('exam-correct').textContent = `${correct}/10`;
            document.getElementById('exam-percent').textContent = `${percent}%`;
            
            const wrongTasks = examState.tasks.filter(t => !t.correct);
            const wrongSection = document.getElementById('exam-wrong-section');
            const wrongList = document.getElementById('exam-wrong-list');
            
            if (wrongTasks.length > 0) {
                wrongSection.style.display = 'block';
                wrongList.innerHTML = '';
                
                wrongTasks.forEach((task, index) => {
                    const div = document.createElement('div');
                    div.className = 'exam-wrong-item';
                    const solutionHtml = getSolutionStepsHtml(task.formula, task.target);
                    const targetDisplay = getBaseVariable(task.target);
                    div.innerHTML = `
                        <div class="exam-wrong-header" onclick="this.parentElement.classList.toggle('open')">
                            <div class="task">${task.formula.name} ‚Äì nach ${targetDisplay} aufl√∂sen</div>
                            <div class="exam-wrong-toggle">‚ñº</div>
                        </div>
                        <div class="exam-wrong-solution">
                            <div style="font-size: 0.85rem; color: #dc2626; margin-bottom: 8px; font-weight: 600;">Deine L√∂sung:</div>
                            <div class="steps-list" style="margin-bottom: 16px;">
                                ${task.userStepsHtml || '<div style="color: #666; font-style: italic;">Keine Schritte</div>'}
                            </div>
                            <div style="font-size: 0.85rem; color: #16a34a; margin-bottom: 8px; font-weight: 600;">Richtige L√∂sung:</div>
                            ${solutionHtml}
                        </div>
                    `;
                    wrongList.appendChild(div);
                });
            } else {
                wrongSection.style.display = 'none';
            }
        }

        function restartExam() {
            document.getElementById('exam-results').style.display = 'none';
            document.getElementById('exam-start').style.display = 'block';
        }
    </script>
</body>
</html>
