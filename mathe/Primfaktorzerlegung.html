<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Primfaktorzerlegung</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            padding: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        h1 {
            color: #4ecdc4;
            font-size: 1.4em;
            margin: 10px 0 2px 0;
            flex-shrink: 0;
        }
        
        .hinweis {
            color: #666;
            font-size: 0.7em;
            margin-bottom: 5px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .btn {
            width: 50px;
            height: 50px;
            font-size: 22px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            background: #4ecdc4;
            color: white;
            cursor: pointer;
            -webkit-appearance: none;
        }
        
        .btn:active {
            background: #3db8b0;
            transform: scale(0.95);
        }
        
        #zahl {
            font-size: 24px;
            font-weight: bold;
            width: 80px;
            padding: 5px;
            text-align: center;
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            background: #0d0d1a;
            color: white;
            -moz-appearance: textfield;
        }
        
        #zahl::-webkit-outer-spin-button,
        #zahl::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        #zahl:focus {
            outline: none;
            border-color: #ffeaa7;
        }
        
        #ergebnis {
            font-size: 1.3em;
            color: #ffeaa7;
            margin: 5px 0;
            flex-shrink: 0;
        }
        
        #dimensionInfo {
            font-size: 0.9em;
            color: #7c3aed;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0d0d1a;
            border-radius: 12px;
            margin: 5px auto;
            overflow: hidden;
            aspect-ratio: 1 / 1;
        }
        
        #c {
            display: block;
            border-radius: 8px;
            touch-action: none;
            width: 100%;
            height: 100%;
        }
        
        .info {
            margin-top: 10px;
            color: #666;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    
    <h1>Primfaktorzerlegung</h1>
    <div class="hinweis">Zahlen von 2 bis 1000</div>
    
    <div class="controls">
        <button class="btn" id="bMinus10">−10</button>
        <button class="btn" id="bMinus1">−1</button>
        <input type="number" id="zahl" value="60" min="1" max="1000">
        <button class="btn" id="bPlus1">+1</button>
        <button class="btn" id="bPlus10">+10</button>
    </div>
    
    <div id="ergebnis">60 = 2² · 3 · 5</div>
    <div id="dimensionInfo"></div>
    
    <div class="canvas-container">
        <canvas id="c" width="420" height="380"></canvas>
    </div>
    
    <div class="info" id="infoText"></div>

    <script>
    var n = 60;
    var primExponenten = {}; // z.B. {2: 2, 3: 1, 5: 1} für 60
    var primListe = [];      // sortierte Liste der Primzahlen [2, 3, 5]
    var gitterGroesse = [];  // [3, 2, 2] für 60
    var anzahlDimensionen = 0;
    
    var drehWinkelH = 0; // Horizontale Rotation (links/rechts)
    var drehWinkelV = 0; // Vertikale Rotation (oben/unten), begrenzt auf ±30°
    var maxDrehWinkelV = Math.PI / 6; // 30 Grad
    
    var canvas = document.getElementById('c');
    var ctx = canvas.getContext('2d');
    var W, H;
    
    var kugelFarbe = '#4ecdc4';
    var kugelFarbeAusgewaehlt = '#ff9f43'; // Orange für ausgewählte Zahl
    var verbindungFarben = {
        x: '#ff6b6b',  // Rot für x-Achse
        y: '#ffeaa7',  // Gelb für y-Achse
        z: '#a29bfe'   // Violett für z-Achse
    };
    var operatorFarben = ['#ff6b6b', '#ffeaa7', '#a29bfe']; // x, y, z
    
    // Responsive Canvas - quadratisch
    function resizeCanvas() {
        // Berechne verfügbare Höhe (Fenster minus Header, Controls, Ergebnis, Info)
        var header = document.querySelector('h1');
        var controls = document.querySelector('.controls');
        var ergebnis = document.getElementById('ergebnis');
        var info = document.querySelector('.info');
        
        var usedHeight = header.offsetHeight + controls.offsetHeight + ergebnis.offsetHeight + (info ? info.offsetHeight : 0) + 60; // 60 für margins
        var availableHeight = window.innerHeight - usedHeight;
        var availableWidth = window.innerWidth - 20; // 20 für padding
        
        // Quadratisch: nimm das Minimum
        var size = Math.min(availableHeight, availableWidth);
        size = Math.max(size, 250); // Mindestgrösse
        
        // Setze Container-Grösse
        var container = document.querySelector('.canvas-container');
        container.style.width = size + 'px';
        container.style.height = size + 'px';
        
        W = size;
        H = size;
        
        canvas.width = W;
        canvas.height = H;
        
        zeichne();
    }
    
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', function() {
        setTimeout(resizeCanvas, 100);
    });
    
    // Button Events
    function setupButton(id, fn) {
        var btn = document.getElementById(id);
        btn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            fn();
        }, {passive: false});
        btn.addEventListener('click', fn);
    }
    
    setupButton('bMinus10', function() { n = Math.max(2, n - 10); aktualisiere(); });
    setupButton('bMinus1', function() { n = Math.max(2, n - 1); aktualisiere(); });
    setupButton('bPlus1', function() { n = Math.min(1000, n + 1); aktualisiere(); });
    setupButton('bPlus10', function() { n = Math.min(1000, n + 10); aktualisiere(); });
    
    // Input-Feld direkte Eingabe
    var zahlInput = document.getElementById('zahl');
    zahlInput.addEventListener('change', function() {
        var wert = parseInt(this.value);
        if(!isNaN(wert) && wert >= 2 && wert <= 1000) {
            n = wert;
            aktualisiere();
        } else {
            this.value = n;
        }
    });
    zahlInput.addEventListener('keydown', function(e) {
        if(e.key === 'Enter') {
            this.blur();
        }
    });
    
    function primfaktorzerlegung(zahl) {
        var exponenten = {};
        var d = 2;
        var rest = zahl;
        while(rest > 1) {
            while(rest % d === 0) {
                exponenten[d] = (exponenten[d] || 0) + 1;
                rest = rest / d;
            }
            d++;
            if(d * d > rest && rest > 1) {
                exponenten[rest] = (exponenten[rest] || 0) + 1;
                break;
            }
        }
        return exponenten;
    }
    
    function berechneGitter() {
        primExponenten = primfaktorzerlegung(n);
        primListe = Object.keys(primExponenten).map(Number).sort(function(a,b){ return a - b; });
        anzahlDimensionen = primListe.length;
        
        // Gittergrösse: Exponent + 1 für jede Dimension
        gitterGroesse = [];
        for(var i = 0; i < primListe.length; i++) {
            gitterGroesse.push(primExponenten[primListe[i]] + 1);
        }
    }
    
    function berechneWert(position) {
        // position ist Array [x, y, z] oder [x, y] oder [x]
        var wert = 1;
        for(var i = 0; i < position.length; i++) {
            wert *= Math.pow(primListe[i], position[i]);
        }
        return wert;
    }
    
    function aktualisiere() {
        document.getElementById('zahl').value = n;
        berechneGitter();
        
        // Drehwinkel zurücksetzen auf Standardansicht
        drehWinkelH = 0;
        drehWinkelV = 0;
        
        // Hochzahlen
        var hoch = ['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹'];
        function toHoch(x) {
            var s = String(x), r = '';
            for(var i = 0; i < s.length; i++) r += hoch[parseInt(s[i])];
            return r;
        }
        
        var teile = [];
        for(var i = 0; i < primListe.length; i++) {
            var p = primListe[i];
            var exp = primExponenten[p];
            teile.push(exp > 1 ? p + toHoch(exp) : String(p));
        }
        
        // Primzahl-Check
        var istPrimzahl = (anzahlDimensionen === 1 && gitterGroesse[0] === 2);
        
        if(istPrimzahl) {
            document.getElementById('ergebnis').textContent = n + ' = Primzahl';
        } else {
            document.getElementById('ergebnis').textContent = n + ' = ' + teile.join(' · ');
        }
        
        if(anzahlDimensionen >= 4) {
            document.getElementById('dimensionInfo').textContent = '';
            document.getElementById('infoText').textContent = '';
        } else if(istPrimzahl) {
            document.getElementById('dimensionInfo').textContent = '';
            document.getElementById('infoText').textContent = '';
        } else if(anzahlDimensionen === 3) {
            document.getElementById('dimensionInfo').textContent = '';
            document.getElementById('infoText').textContent = '';
        } else {
            document.getElementById('dimensionInfo').textContent = '';
            document.getElementById('infoText').textContent = '';
        }
        
        zeichne();
    }
    
    function projekt(x, y, z) {
        // Isometrische Projektion
        // Blick auf die vordere untere Ecke des Würfels
        // 1 ist bei (0,0,0) = die Spitze unten vorne (nächste Ecke zum Betrachter)
        // x → nach rechts hinten (·2)
        // y → nach links hinten (·3)
        // z → nach oben (·5)
        
        // Skalierungsfaktor basierend auf Canvas-Grösse
        var skala = Math.min(W, H) / 400;
        
        // Tausche x und y, und invertiere damit (0,0,0) vorne ist
        var xInv = -y;
        var yInv = -x;
        
        // Horizontale Rotation um Z-Achse
        var cosH = Math.cos(drehWinkelH);
        var sinH = Math.sin(drehWinkelH);
        var xRot = xInv * cosH - yInv * sinH;
        var yRot = xInv * sinH + yInv * cosH;
        var zRot = z;
        
        // Vertikale Rotation um X-Achse (kippen)
        var cosV = Math.cos(drehWinkelV);
        var sinV = Math.sin(drehWinkelV);
        var yRot2 = yRot * cosV - zRot * sinV;
        var zRot2 = yRot * sinV + zRot * cosV;
        
        // Isometrische Projektion (30 Grad Winkel)
        var isoX = (xRot * 28 - yRot2 * 28) * skala;
        var isoY = (-xRot * 16 - yRot2 * 16 + zRot2 * 32) * skala;
        
        var px = W/2 + isoX;
        var py = H/2 - isoY;
        
        // Tiefe für Sortierung (grösser = weiter hinten)
        var tiefe = -xRot - yRot2 + zRot2 * 0.1;
        
        return { px: px, py: py, pz: tiefe, skala: skala };
    }
    
    function zeichne() {
        ctx.fillStyle = '#0d0d1a';
        ctx.fillRect(0, 0, W, H);
        
        if(anzahlDimensionen === 0) return;
        
        if(anzahlDimensionen >= 4) {
            // 4+ Dimensionen können nicht dargestellt werden
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(anzahlDimensionen + ' verschiedene Primfaktoren', W/2, H/2 - 15);
            ctx.fillText('können nicht dargestellt werden', W/2, H/2 + 15);
            return;
        }
        
        // Primzahl - nur 1 Faktor mit Exponent 1
        if(anzahlDimensionen === 1 && gitterGroesse[0] === 2) {
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(n + ' ist eine Primzahl', W/2, H/2);
            return;
        }
        
        if(anzahlDimensionen === 3) {
            zeichne3D();
        } else if(anzahlDimensionen === 2) {
            zeichne2D();
        } else {
            zeichne1D();
        }
    }
    
    function zeichne3D() {
        var gx = gitterGroesse[0];
        var gy = gitterGroesse[1];
        var gz = gitterGroesse[2];
        
        var punkte = [];
        var verbindungen = [];
        
        // Offset damit Gitter zentriert ist
        var ox = (gx-1)/2, oy = (gy-1)/2, oz = (gz-1)/2;
        
        // Sammle alle Punkte
        // (0,0,0) = vorne links unten = Wert 1
        for(var x = 0; x < gx; x++) {
            for(var y = 0; y < gy; y++) {
                for(var z = 0; z < gz; z++) {
                    var p = projekt(x-ox, y-oy, z-oz);
                    var wert = berechneWert([x, y, z]);
                    punkte.push({ 
                        x: x, y: y, z: z,
                        px: p.px, py: p.py, pz: p.pz, skala: p.skala,
                        wert: wert
                    });
                }
            }
        }
        
        // Verbindungen aufbauen mit Achsenrichtung
        for(var i = 0; i < punkte.length; i++) {
            var p1 = punkte[i];
            for(var j = i + 1; j < punkte.length; j++) {
                var p2 = punkte[j];
                var dx = Math.abs(p1.x - p2.x);
                var dy = Math.abs(p1.y - p2.y);
                var dz = Math.abs(p1.z - p2.z);
                // Nur direkte Nachbarn verbinden
                if(dx === 1 && dy === 0 && dz === 0) {
                    verbindungen.push({von: i, zu: j, achse: 'x'});
                } else if(dx === 0 && dy === 1 && dz === 0) {
                    verbindungen.push({von: i, zu: j, achse: 'y'});
                } else if(dx === 0 && dy === 0 && dz === 1) {
                    verbindungen.push({von: i, zu: j, achse: 'z'});
                }
            }
        }
        
        // Finde min/max Tiefe für Schattierung
        var minTiefe = Infinity, maxTiefe = -Infinity;
        for(var i = 0; i < punkte.length; i++) {
            if(punkte[i].pz < minTiefe) minTiefe = punkte[i].pz;
            if(punkte[i].pz > maxTiefe) maxTiefe = punkte[i].pz;
        }
        var tiefenBereich = maxTiefe - minTiefe || 1;
        
        // Finde die vorderste Kugel (kleinste pz)
        var vorderstePz = Infinity;
        for(var i = 0; i < punkte.length; i++) {
            if(punkte[i].pz < vorderstePz) vorderstePz = punkte[i].pz;
        }
        
        // Kugelradius für Verbindungen (muss mit zeichneKugel3D übereinstimmen)
        var skala = Math.min(W, H) / 400;
        var kugelRadius = Math.max(8, 12 * skala);
        
        // Erstelle Zeichenobjekte für Kugeln und Verbindungen
        var zeichenObjekte = [];
        
        // Füge Kugeln hinzu
        for(var i = 0; i < punkte.length; i++) {
            var p = punkte[i];
            zeichenObjekte.push({
                typ: 'kugel',
                tiefe: p.pz,
                punkt: p
            });
        }
        
        // Füge Verbindungen hinzu - Tiefe ist der VORDERE Endpunkt
        // So wird die Verbindung nach den hinteren Kugeln aber vor den vorderen gezeichnet
        for(var i = 0; i < verbindungen.length; i++) {
            var v = verbindungen[i];
            var p1 = punkte[v.von];
            var p2 = punkte[v.zu];
            var vordereTiefe = Math.min(p1.pz, p2.pz);
            zeichenObjekte.push({
                typ: 'verbindung',
                tiefe: vordereTiefe,
                p1: p1,
                p2: p2,
                achse: v.achse
            });
        }
        
        // Sortiere alles nach Tiefe (hintere zuerst = grössere Tiefe zuerst)
        zeichenObjekte.sort(function(a, b) {
            if(Math.abs(b.tiefe - a.tiefe) > 0.001) {
                return b.tiefe - a.tiefe;
            }
            // Bei gleicher Tiefe: Verbindungen vor Kugeln (Kugeln verdecken Verbindungsenden)
            if(a.typ === 'verbindung' && b.typ === 'kugel') return 1;
            if(a.typ === 'kugel' && b.typ === 'verbindung') return -1;
            return 0;
        });
        
        // Hilfsfunktion: Zeichne Verbindung vom Kugelrand
        function zeichneVerbindungVomRand(p1, p2, farbe) {
            var dx = p2.px - p1.px;
            var dy = p2.py - p1.py;
            var laenge = Math.sqrt(dx * dx + dy * dy);
            if(laenge < kugelRadius * 2) return;
            
            var nx = dx / laenge;
            var ny = dy / laenge;
            
            var startX = p1.px + nx * kugelRadius;
            var startY = p1.py + ny * kugelRadius;
            var endX = p2.px - nx * kugelRadius;
            var endY = p2.py - ny * kugelRadius;
            
            var avgTiefe = (p1.pz + p2.pz) / 2;
            var tiefeFaktor = 0.4 + 0.6 * (1 - (avgTiefe - minTiefe) / tiefenBereich);
            
            var rgb = hexZuRgb(farbe);
            ctx.strokeStyle = 'rgba(' + Math.floor(rgb.r * tiefeFaktor) + ',' + Math.floor(rgb.g * tiefeFaktor) + ',' + Math.floor(rgb.b * tiefeFaktor) + ', 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        // Zeichne alles in sortierter Reihenfolge
        for(var i = 0; i < zeichenObjekte.length; i++) {
            var obj = zeichenObjekte[i];
            
            if(obj.typ === 'verbindung') {
                zeichneVerbindungVomRand(obj.p1, obj.p2, verbindungFarben[obj.achse]);
            } else {
                var p = obj.punkt;
                var tiefeFaktor = 0.5 + 0.5 * (1 - (p.pz - minTiefe) / tiefenBereich);
                var istAusgewaehlt = (p.wert === n);
                zeichneKugel3D(p.px, p.py, p.wert, p.skala, tiefeFaktor, istAusgewaehlt);
            }
        }
        
        // Zeichne Operatoren
        zeichneOperator3D(ox, oy, oz, gx, gy, gz);
    }
    
    function hexZuRgb(hex) {
        var r = parseInt(hex.substr(1, 2), 16);
        var g = parseInt(hex.substr(3, 2), 16);
        var b = parseInt(hex.substr(5, 2), 16);
        return {r: r, g: g, b: b};
    }
    
    function zeichneKugel3D(px, py, wert, skala, tiefeFaktor, istAusgewaehlt) {
        var radius = Math.max(8, 12 * skala);
        var textGroesse = Math.max(7, Math.floor(9 * skala));
        
        // Farbe basierend auf Auswahl und Tiefe
        var basisFarbe = istAusgewaehlt ? kugelFarbeAusgewaehlt : kugelFarbe;
        var rgb = hexZuRgb(basisFarbe);
        
        // Kugel-Gradient mit Tiefenschattierung
        var grad = ctx.createRadialGradient(
            px - radius*0.3, py - radius*0.3, 0,
            px, py, radius
        );
        
        var helligkeit = tiefeFaktor;
        grad.addColorStop(0, 'rgb(' + Math.floor(Math.min(255, rgb.r * 1.3 * helligkeit)) + ',' + Math.floor(Math.min(255, rgb.g * 1.3 * helligkeit)) + ',' + Math.floor(Math.min(255, rgb.b * 1.3 * helligkeit)) + ')');
        grad.addColorStop(0.7, 'rgb(' + Math.floor(rgb.r * helligkeit) + ',' + Math.floor(rgb.g * helligkeit) + ',' + Math.floor(rgb.b * helligkeit) + ')');
        grad.addColorStop(1, 'rgb(' + Math.floor(rgb.r * 0.6 * helligkeit) + ',' + Math.floor(rgb.g * 0.6 * helligkeit) + ',' + Math.floor(rgb.b * 0.6 * helligkeit) + ')');
        
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Wert auf Kugel
        ctx.fillStyle = istAusgewaehlt ? '#000' : 'rgba(0,0,0,' + (0.6 + 0.4 * tiefeFaktor) + ')';
        ctx.font = 'bold ' + textGroesse + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(wert, px, py);
    }
    
    function zeichne2D() {
        var gx = gitterGroesse[0];
        var gy = gitterGroesse[1];
        
        var punkte = [];
        var verbindungen = [];
        
        // Skalierungsfaktor
        var skala = Math.min(W, H) / 400;
        
        // Berechne Layout - mehr Rand für Operatoren
        var rand = 70 * skala;
        var maxBreite = W - rand * 2;
        var maxHoehe = H - rand * 2;
        var maxAbstand = 60 * skala;
        var abstand = Math.min(maxBreite / Math.max(gx - 1, 1), maxHoehe / Math.max(gy - 1, 1), maxAbstand);
        if(gx === 1) abstand = Math.min(maxHoehe / Math.max(gy - 1, 1), maxAbstand);
        if(gy === 1) abstand = Math.min(maxBreite / Math.max(gx - 1, 1), maxAbstand);
        
        var breite = (gx - 1) * abstand;
        var hoehe = (gy - 1) * abstand;
        var startX = (W - breite) / 2 + 10 * skala;
        var startY = (H - hoehe) / 2 - 10 * skala;
        
        // Sammle Punkte
        for(var y = 0; y < gy; y++) {
            for(var x = 0; x < gx; x++) {
                var px = startX + x * abstand;
                var py = startY + hoehe - y * abstand; // y=0 unten
                var wert = berechneWert([x, y]);
                punkte.push({ x: x, y: y, px: px, py: py, wert: wert });
            }
        }
        
        // Verbindungen mit Achsenrichtung
        for(var i = 0; i < punkte.length; i++) {
            for(var j = i + 1; j < punkte.length; j++) {
                var p1 = punkte[i];
                var p2 = punkte[j];
                var dx = Math.abs(p1.x - p2.x);
                var dy = Math.abs(p1.y - p2.y);
                if(dx === 1 && dy === 0) {
                    verbindungen.push({von: i, zu: j, achse: 'x'});
                } else if(dx === 0 && dy === 1) {
                    verbindungen.push({von: i, zu: j, achse: 'y'});
                }
            }
        }
        
        // Zeichne Verbindungen mit Achsenfarben
        ctx.lineWidth = Math.max(2, 3 * skala);
        for(var i = 0; i < verbindungen.length; i++) {
            var v = verbindungen[i];
            var p1 = punkte[v.von];
            var p2 = punkte[v.zu];
            ctx.strokeStyle = verbindungFarben[v.achse];
            ctx.beginPath();
            ctx.moveTo(p1.px, p1.py);
            ctx.lineTo(p2.px, p2.py);
            ctx.stroke();
        }
        
        // Zeichne Kugeln
        for(var i = 0; i < punkte.length; i++) {
            var p = punkte[i];
            zeichneKugel(p.px, p.py, p.wert, skala);
        }
        
        // Zeichne Operatoren
        zeichneOperator2D(startX, startY, breite, hoehe, skala);
    }
    
    function zeichne1D() {
        var gx = gitterGroesse[0];
        
        var punkte = [];
        
        // Skalierungsfaktor
        var skala = Math.min(W, H) / 400;
        
        var rand = 50 * skala;
        var maxBreite = W - rand * 2;
        var maxAbstand = 55 * skala;
        var abstand = Math.min(maxBreite / Math.max(gx - 1, 1), maxAbstand);
        var breite = (gx - 1) * abstand;
        var startX = (W - breite) / 2;
        var startY = H / 2;
        
        for(var x = 0; x < gx; x++) {
            var px = startX + x * abstand;
            var wert = berechneWert([x]);
            punkte.push({ x: x, px: px, py: startY, wert: wert });
        }
        
        // Zeichne Verbindungen mit x-Achsenfarbe
        ctx.strokeStyle = verbindungFarben.x;
        ctx.lineWidth = Math.max(2, 3 * skala);
        for(var i = 0; i < punkte.length - 1; i++) {
            ctx.beginPath();
            ctx.moveTo(punkte[i].px, punkte[i].py);
            ctx.lineTo(punkte[i+1].px, punkte[i+1].py);
            ctx.stroke();
        }
        
        // Zeichne Kugeln
        for(var i = 0; i < punkte.length; i++) {
            var p = punkte[i];
            zeichneKugel(p.px, p.py, p.wert, skala);
        }
        
        // Zeichne Operator
        zeichneOperator1D(startX, startY, breite, skala);
    }
    
    function zeichneKugel(px, py, wert, skala) {
        var radius = Math.max(8, 12 * skala);
        var textGroesse = Math.max(7, Math.floor(9 * skala));
        
        var istAusgewaehlt = (wert === n);
        var basisFarbe = istAusgewaehlt ? kugelFarbeAusgewaehlt : kugelFarbe;
        var rgb = hexZuRgb(basisFarbe);
        
        // Kugel-Gradient
        var grad = ctx.createRadialGradient(
            px - radius*0.3, py - radius*0.3, 0,
            px, py, radius
        );
        grad.addColorStop(0, 'rgb(' + Math.min(255, Math.floor(rgb.r * 1.3)) + ',' + Math.min(255, Math.floor(rgb.g * 1.3)) + ',' + Math.min(255, Math.floor(rgb.b * 1.3)) + ')');
        grad.addColorStop(0.7, basisFarbe);
        grad.addColorStop(1, 'rgb(' + Math.floor(rgb.r * 0.6) + ',' + Math.floor(rgb.g * 0.6) + ',' + Math.floor(rgb.b * 0.6) + ')');
        
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Wert auf Kugel
        ctx.fillStyle = '#000';
        ctx.font = 'bold ' + textGroesse + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(wert, px, py);
    }
    
    function zeichneOperatorSymbol(cx, cy, zahl, richtungX, richtungY, farbe, skala) {
        skala = skala || 1;
        var radius = 16 * skala;
        var pfeilAbstand = radius + 4 * skala;
        var pfeilLaenge = 15 * skala;
        
        // Pfeil VOR dem Kreis (Eingang)
        var startPfeilX = cx - richtungX * (pfeilAbstand + pfeilLaenge);
        var startPfeilY = cy - richtungY * (pfeilAbstand + pfeilLaenge);
        var endVorKreisX = cx - richtungX * pfeilAbstand;
        var endVorKreisY = cy - richtungY * pfeilAbstand;
        
        ctx.strokeStyle = farbe;
        ctx.lineWidth = Math.max(1, 2 * skala);
        ctx.beginPath();
        ctx.moveTo(startPfeilX, startPfeilY);
        ctx.lineTo(endVorKreisX, endVorKreisY);
        ctx.stroke();
        
        // Pfeil NACH dem Kreis (Ausgang) mit Pfeilspitze
        var startNachKreisX = cx + richtungX * pfeilAbstand;
        var startNachKreisY = cy + richtungY * pfeilAbstand;
        var endPfeilX = cx + richtungX * (pfeilAbstand + pfeilLaenge);
        var endPfeilY = cy + richtungY * (pfeilAbstand + pfeilLaenge);
        
        ctx.beginPath();
        ctx.moveTo(startNachKreisX, startNachKreisY);
        ctx.lineTo(endPfeilX, endPfeilY);
        ctx.stroke();
        
        // Pfeilspitze
        var pfeilKopf = 8 * skala;
        var winkel = Math.atan2(richtungY, richtungX);
        ctx.beginPath();
        ctx.moveTo(endPfeilX, endPfeilY);
        ctx.lineTo(endPfeilX - pfeilKopf * Math.cos(winkel - 0.4), endPfeilY - pfeilKopf * Math.sin(winkel - 0.4));
        ctx.moveTo(endPfeilX, endPfeilY);
        ctx.lineTo(endPfeilX - pfeilKopf * Math.cos(winkel + 0.4), endPfeilY - pfeilKopf * Math.sin(winkel + 0.4));
        ctx.stroke();
        
        // Kreis (über den Pfeilen)
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = '#0d0d1a';
        ctx.fill();
        ctx.strokeStyle = farbe;
        ctx.lineWidth = Math.max(1, 2 * skala);
        ctx.stroke();
        
        // Multiplikationszeichen und Zahl
        ctx.fillStyle = farbe;
        ctx.font = 'bold ' + Math.max(10, Math.floor(14 * skala)) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('·' + zahl, cx, cy);
    }
    
    function zeichneOperator1D(startX, startY, breite, skala) {
        skala = skala || 1;
        // Operator unter dem Gitter, Pfeil nach rechts
        var cx = startX + breite / 2;
        var cy = startY + 50 * skala;
        zeichneOperatorSymbol(cx, cy, primListe[0], 1, 0, operatorFarben[0], skala);
    }
    
    function zeichneOperator2D(startX, startY, breite, hoehe, skala) {
        skala = skala || 1;
        // X-Operator unter dem Gitter
        var cxX = startX + breite / 2;
        var cyX = startY + hoehe + 55 * skala;
        zeichneOperatorSymbol(cxX, cyX, primListe[0], 1, 0, operatorFarben[0], skala);
        
        // Y-Operator links vom Gitter
        var cxY = startX - 55 * skala;
        var cyY = startY + hoehe / 2;
        zeichneOperatorSymbol(cxY, cyY, primListe[1], 0, -1, operatorFarben[1], skala);
    }
    
    function zeichneOperator3D(ox, oy, oz, gx, gy, gz) {
        // Skalierungsfaktor
        var skala = Math.min(W, H) / 400;
        
        // Operatoren an den Rändern des Fensters
        // x → unten rechts, Pfeil nach rechts-oben (= rechts hinten im 3D)
        // y → unten links, Pfeil nach links-oben (= links hinten im 3D)
        // z → links zentriert, Pfeil nach oben
        
        var rand = 45 * skala;
        
        // X-Operator (unten rechts)
        zeichneOperatorSymbol(W - rand, H - rand, primListe[0], 0.85, -0.5, operatorFarben[0], skala);
        
        // Y-Operator (unten links)
        zeichneOperatorSymbol(rand, H - rand, primListe[1], -0.85, -0.5, operatorFarben[1], skala);
        
        // Z-Operator (links zentriert)
        zeichneOperatorSymbol(rand - 10 * skala, H/2, primListe[2], 0, -1, operatorFarben[2], skala);
    }
    
    // Touch für 3D Rotation
    var touchAktiv = false, touchX = 0, touchY = 0;
    
    canvas.addEventListener('touchstart', function(e) {
        if(anzahlDimensionen === 3 && e.touches.length === 1) {
            touchAktiv = true;
            touchX = e.touches[0].clientX;
            touchY = e.touches[0].clientY;
            e.preventDefault();
        }
    }, {passive: false});
    
    canvas.addEventListener('touchmove', function(e) {
        if(touchAktiv && anzahlDimensionen === 3) {
            var dx = e.touches[0].clientX - touchX;
            var dy = e.touches[0].clientY - touchY;
            drehWinkelH += dx * 0.01;
            drehWinkelV += dy * 0.01;
            // Begrenze vertikale Rotation auf ±30°
            drehWinkelV = Math.max(-maxDrehWinkelV, Math.min(maxDrehWinkelV, drehWinkelV));
            touchX = e.touches[0].clientX;
            touchY = e.touches[0].clientY;
            zeichne();
            e.preventDefault();
        }
    }, {passive: false});
    
    canvas.addEventListener('touchend', function() { touchAktiv = false; });
    
    // Maus für Desktop
    var mausAktiv = false, mausX = 0, mausY = 0;
    
    canvas.addEventListener('mousedown', function(e) {
        if(anzahlDimensionen === 3) { 
            mausAktiv = true; 
            mausX = e.clientX;
            mausY = e.clientY;
        }
    });
    
    canvas.addEventListener('mousemove', function(e) {
        if(mausAktiv && anzahlDimensionen === 3) {
            drehWinkelH += (e.clientX - mausX) * 0.01;
            drehWinkelV += (e.clientY - mausY) * 0.01;
            // Begrenze vertikale Rotation auf ±30°
            drehWinkelV = Math.max(-maxDrehWinkelV, Math.min(maxDrehWinkelV, drehWinkelV));
            mausX = e.clientX;
            mausY = e.clientY;
            zeichne();
        }
    });
    
    canvas.addEventListener('mouseup', function() { mausAktiv = false; });
    canvas.addEventListener('mouseleave', function() { mausAktiv = false; });
    
    // Start
    resizeCanvas();
    aktualisiere();
    </script>
</body>
</html>
